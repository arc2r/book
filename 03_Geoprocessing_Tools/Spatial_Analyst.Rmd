```{r}
library(sf)
library(tidyverse)
library(raster)
```


# Spatial Analyst Toolbox

<!-- ## Conditional Toolset -->








<!-- ## Density Toolset -->

### Kernel Denisity


There are several Function that can be tweaked to calculate KDE for `sf`-Point object:

- `tmaptools::smooth_map()`: Depricated (is there a successor?)
- `spatstat::density.ppp()`: Takes only objects of Class `ppp`
- `MASS::kde2d()`: Takes x/y coordinates as vectors and returns a matrix

In this example, I take `MASS:kde2d()` and tweak it to take `sf` and return `raster`. First, let's create some sample data:

```{r}
set.seed(10)
mypoints <- data.frame(x = rnorm(1000),y = rnorm(1000)) %>%
  st_as_sf(coords = c(1,2))

plot(mypoints)
```


```{r}
my_kde <- function(points,cellsize, bandwith, extent = NULL){
  require(MASS)
  require(raster)
  require(sf)
  if(is.null(extent)){
    extent_vec <- st_bbox(points)[c(1,3,2,4)]
  } else{
    extent_vec <- st_bbox(extent)[c(1,3,2,4)]
  }
  
  n_y <- ceiling((extent_vec[4]-extent_vec[3])/cellsize)
  n_x <- ceiling((extent_vec[2]-extent_vec[1])/cellsize)
  
  extent_vec[2] <- extent_vec[1]+(n_x*cellsize)-cellsize
  extent_vec[4] <- extent_vec[3]+(n_y*cellsize)-cellsize

  coords <- st_coordinates(points)
  matrix <- kde2d(coords[,1],coords[,2],h = bandwith,n = c(n_x,n_y),lims = extent_vec)
  raster(matrix)
}
```

```{r}

mypoints_kde <- my_kde(mypoints,0.01,1)
library(stars)

ggplot() +
  geom_stars(data = st_as_stars(mypoints_kde)) +
  geom_sf(data = mypoints, alpha = 0.2, fill = "black") +
  scale_fill_viridis_c() +
  labs(fill = "KDE") +
  theme_void() 


```


<!-- ### Line Density -->

<!-- ### Point Density -->

<!-- ## Distance Toolset -->

<!-- ## Extraction Toolset -->

<!-- ## Generalization Toolset -->

<!-- ## Interpolation Toolset -->

<!-- ## Map Algebra Toolset -->

<!-- ## Math Toolset -->

<!-- ## Neighborhood Toolset -->

<!-- ## Overlay Toolset -->

<!-- ### Fuzzy Membership -->
<!-- ### Fuzzy Overlay -->
<!-- ### Locate Regions -->
<!-- ### Weighted Overlay -->
<!-- ### Weighted Sum -->


## Reclass Toolset

<!-- ### Lookup -->
<!-- ### Reclass by ASCII File -->
<!-- ### Reclass by Table -->
### Reclassify






<!-- ### Rescale by Function -->
<!-- ### Slice -->


<!-- ## Surface Toolset -->

### Slope and Aspect


```{r}
library(raster)
swissAlti3d <- raster("sample_data/Raster/swissALTI3D2019.tif")
plot(swissAlti3d)
```

In ArcGIS pro the tool used for computing the slope of a raster dataset with elevation
data is called `Slope (3D Analyst)`. It identifies the steepness at each cell of a raster surface.
The lower the slope value, the flatter the terrain; the higher the slope value, the steeper the terrain.  
In R, __raster package__ includes the function _terrain()_, which helps us compute
*slope*, *aspect* and other terrain characteristics from a raster with elevation data.  
Let's start by computing the _slope_ of the **swissAlti3d** raster dataset.

```{r}
# Computing the slope of a raster dataset using the terrain() function
swissAlti3d_slope <- terrain(swissAlti3d, opt="slope", unit="degrees")
plot(swissAlti3d_slope)
```
  
In the function above, we define the operation we want to perform as the second
argument of the function (_opt = "slope"_). Furthermore, we also define the units
of the final result.  
Similarly, we compute the _aspect_ of the given dataset, as follows:

```{r}
# Computing the aspect of the terrain dataset
swissAlti3d_aspect <- terrain(swissAlti3d, opt="aspect", unit="degrees")
plot(swissAlti3d_aspect)
```  
  
So, R gives us the option to retrieve multiple terrain characteristics of a raster
dataset, using only one function. The aforementioned spatial operation in ArcGIS pro
could be performed using the tool `Aspect (Spatial Analyst)`.


<!-- ### Contour -->
<!-- ### Contour List -->
<!-- ### Contour with Barriers -->
<!-- ### Curvature -->
<!-- ### Cut Fill -->
<!-- ### Hillshade -->
<!-- ### Observer Points -->
<!-- ### Slope -->
<!-- ### Viewshed -->
<!-- ### Viewshed 2 -->
<!-- ### Visibility -->


<!-- ## Zonal Toolset -->






