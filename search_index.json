[["index.html", "All things R Spatial arc2r: An introduction to spatial-R for recovering ArcGIS users 1 What this book is about 1.1 How it started 1.2 What might make your journey difficult 1.3 Why you should transition anyway 1.4 How to use this book", " All things R Spatial arc2r: An introduction to spatial-R for recovering ArcGIS users Nils Ratnaweera and Nikolaos Bakogiannis 1 What this book is about This is a resource for people wanting to learn spatial-R (Analysis, Visualization) in R and are coming with a background in ArcGIS. This resource should provide some help on this journey. We assume you have some prior experience with R. If this is not the case, we recommend you familiarize yourself with R first. This book leans heavily on how the Toolboxes and Toolsets are documented in ArcGIS Pro. Is is not a book to read from cover to cover, but to look up specific things of which you only know the ArcGIS terminology for. This book is a work in progress, the current version is from the 2021-02-09 20:00:56 (UTC). We highly appreciate contributions to this book: If you have anything to add, please file an issue or make a pull request. We are big fans of using magrittr’s pipe function %&gt;% and heavily use it throughout this book. In addition for vector data, we use packages from the tidyverse (especially filter(), mutate() and summarise().) 1.1 How it started We had long since thought about the necessity of a resource which helps ArcGIS users transition to R or Python. Nils had tweeted about this (see below) without getting much reception, and and one point just decided to start his own resource. Since our research group teaches and introduction to GIS and an advanced GIS course mostly based on ArcGIS, we decided to pick up where Nils hat started and develop the resource in with internal funding of our University. Figure 1.1: Nils’ Tweet might not have received much attention, but it did spark a conversation within our group 1.2 What might make your journey difficult What are the main difficulties when switching from ArcGIS to R? The fundamental building block of ArcGIS is a visual representation of your data (i.e. the map). The fundamental building block in R is your RScript. The visual aspect makes ArcGIS more approachable, but also less scaleable. When you acquire ArcGIS, you are served from a single source. In R, there are a plethora of developers creating packages for you to use, which can be quite overwhelming While there are always multiple ways to solve a problem in ArcGIS, there are always many more ways to solve it in R When you transition from a proprietary Software like ArcGIS to FOSS, you have to relearn many of the concepts because the proprietary software usually does not adhere to common standards. ArcGIS follows the concept of creating a tool for every situation you might encounter. With this approach, they provide a selection of &gt; 1’000 geoprocessing tools to your disposal. Generally speaking, the authors of Packages will try to keep the number of functions as small as possible, since this reduces maintenance. 1.3 Why you should transition anyway We strongly advocate the use of a programming language to tackle GIS tasks for the following reasons: 1.4 How to use this book "],["Data.html", "2 Data", " 2 Data As an ArcGIS user, you are probably very familiar with the two major geodata formats, raster data and vector data. shapefiles and geodatabases with feature classes are most commonly used for vector data in the ESRI World. For raster data, geotiffs and ESRI GRID files inside geodatabases are used very frequently. As you work with OpenSource GIS Tools and Data, you will come across a much richer ecosystem of data formats. //todo add some examples of geodata-formats (gpkg, sqlite) //body link to switchfromshapefile.org In ArcGIS, you add a new dataset to your project using the “Add Data” button in the “Map” Pane. ArcGIS then “helps” you in various ways that R will not. For example, ArcGIS: … only displays files with extensions that are typically associated with geodata (e.g. .tif, .shp etc) … Automatically bundels files multifile-files (files with a common prefix, e.g. shapefiles) and displays it as a single dataset … let’s you visually examine the content of .gdb-files … displays the datatype / geometrytype of a dataset as a little icon … automatically uses the correct mechanisms to import a dataset R provides less help when importing a dataset which can be seen as a disadvantage, but in many cases is more preferable. R interferes less and assumes an informed user who has good knowledge of the data. Just like when importing datasets using read.csv, read.delim and so on, you need to prior knowledge of your data to import it correctly: You need to know the delimiter used to separate columns, and the encoding used to store the information. The same holds true when importing geodata in R: depending on the type of geodata, we need different packages to handle the data and different functions to import it. For handling vector data, the package sf now has replaced its predecessor sp. sf is so powerful and simple, that it has helped bring GIS workflows to non-GIS R users. For handling raster data, the package raster is still in heavy use but is in the process of being replaced by it’s successor, terra. "],["import_vector.html", "2.1 Importing vector data with sf", " 2.1 Importing vector data with sf Most vector data that you use in everyday GIS work are what are called “simple features.” Simple features are an open standard developed by the Open Geospatial Consortium (OGC). The most common feature types are displayed in figure @ref(fig:sf_types). (#fig:sf_types)The 7 (of 17) most important simple feature types. Image from Lovelace, Nowosad, and Muenchow (2021) To handle these simple features in R, we need the library sf. library(sf) ## Linking to GEOS 3.8.1, GDAL 3.1.4, PROJ 6.3.1 To import a vector dataset into R, we can use the function read_sf as in the example below. ARE_waedenswil &lt;- read_sf(&quot;sample_data/Entsorgung_Waedenswil/ARE_waedenswil.shp&quot;) ARE_waedenswil ## Simple feature collection with 13 features and 5 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 2689594 ymin: 1228563 xmax: 2694829 ymax: 1234095 ## projected CRS: CH1903+ / LV95 ## [90m# A tibble: 13 x 6[39m ## ID KLASSE KLASSE_DE KLASSE_FR KLASSE_NUM geometry ## [3m[90m&lt;int&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;chr&gt;[39m[23m [3m[90m&lt;dbl&gt;[39m[23m [3m[90m&lt;MULTIPOLYGON [m]&gt;[39m[23m ## [90m 1[39m 69 D D - gering… D - faible… 4 (((2692378 1233048, 2692373 … ## [90m 2[39m [4m1[24m371 D D - gering… D - faible… 4 (((2689720 1232195, 2689767 … ## [90m 3[39m [4m3[24m578 D D - gering… D - faible… 4 (((2692766 1232135, 2692690 … ## [90m 4[39m [4m3[24m591 D D - gering… D - faible… 4 (((2691861 1232707, 2691907 … ## [90m 5[39m [4m3[24m696 A A - sehr g… A - très b… 1 (((2693943 1231286, 2693834 … ## [90m 6[39m [4m3[24m901 B B - gute E… B - bonne … 2 (((2693183 1231097, 2693113 … ## [90m 7[39m [4m4[24m137 B B - gute E… B - bonne … 2 (((2690970 1232339, 2690947 … ## [90m 8[39m [4m4[24m161 B B - gute E… B - bonne … 2 (((2691724 1232478, 2691701 … ## [90m 9[39m [4m4[24m225 B B - gute E… B - bonne … 2 (((2692266 1232198, 2692243 … ## [90m10[39m [4m4[24m401 C C - mittel… C - desser… 3 (((2694681 1230763, 2694659 … ## [90m11[39m [4m5[24m208 C C - mittel… C - desser… 3 (((2693064 1229206, 2693041 … ## [90m12[39m [4m5[24m319 C C - mittel… C - desser… 3 (((2690879 1233702, 2690856 … ## [90m13[39m [4m5[24m514 C C - mittel… C - desser… 3 (((2693168 1229907, 2693145 … And you are done! The shapefile is now imported into your R Session and you can start working with it. Much of the beauty in sf comes from it’s simplicity: As you see from importing the shapefile, it is very much like a data.frame, a structure that you are probably know very well. In fact, it is a data.frame, as you can see here: is.data.frame(ARE_waedenswil) ## [1] TRUE sf provides methods for various generics, e.g. you can use plot() on the object for a simple visualisation. plot(ARE_waedenswil) "],["import_raster_raster.html", "2.2 Importing raster data with raster", " 2.2 Importing raster data with raster To import raster data, we need a package that can specifically handle raster datasets. The package raster has for a long time been the go-to package for this. However, this package is currently in the process of being replaced with a successor, terra. Since raster is still in heavy use, we will show you how you handle raster data with this package. 2.2.1 Single band raster Download the sample dataset here and unzip it into your project folder. This dataset is a freely available sample for the swissALTI3D data. The full sample, including files at different resolutions, can be downloaded from here. Now load the library raster the function raster to import the tif-file included in the zip file. Make sure you have set the path to your tif-file correctly. library(raster) ## Loading required package: sp swissalti3d &lt;- raster(&quot;sample_data/swissalti3D/SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196.tif&quot;) ## Warning in showSRID(uprojargs, format = &quot;PROJ&quot;, multiline = &quot;NO&quot;, prefer_proj ## = prefer_proj): Discarded datum Unknown based on Bessel 1841 ellipsoid in Proj4 ## definition The dataset is now imported into your project and ready to be viewed, analysed and processed. If we call the object in our console, we can see that the dataset was imported as a RasterLayer and can see some important statistics which you would typically find via Layer Properties -&gt; Source in ArcGIS. swissalti3d ## class : RasterLayer ## dimensions : 100, 100, 10000 (nrow, ncol, ncell) ## resolution : 10, 10 (x, y) ## extent : 2600000, 2601000, 1196000, 1197000 (xmin, xmax, ymin, ymax) ## crs : +proj=somerc +lat_0=46.9524055555556 +lon_0=7.43958333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +units=m +no_defs ## source : /Users/runner/work/book/book/sample_data/swissalti3D/SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196.tif ## names : SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196 ## values : 623.3814, 858.2705 (min, max) To visualize the dataset, we can simply call plot on our new object. plot(swissalti3d) 2.2.2 Multiband Raster //todo explain how to import multiband raster "],["import_raster_terra.html", "2.3 Importing raster data with terra", " 2.3 Importing raster data with terra With the terra package, data is imported using the function rast. library(terra) ## terra version 1.0.10 swissalti3d &lt;- terra::rast(&quot;sample_data/swissalti3D/SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196.tif&quot;) Just like before, calling the object in our console will give us the class name and some meta information on the dataset. swissalti3d ## class : SpatRaster ## dimensions : 100, 100, 1 (nrow, ncol, nlyr) ## resolution : 10, 10 (x, y) ## extent : 2600000, 2601000, 1196000, 1197000 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=somerc +lat_0=46.9524055555556 +lon_0=7.43958333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ## source : SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196.tif ## name : SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196 ## min value : 623.3814 ## max value : 858.2705 And calling plot on our object visualizes it spatially. plot(swissalti3d) //todo add method for rasters with multiple layers "],["Making_Maps.html", "3 Making Maps", " 3 Making Maps In ArcGIS, the fundamental approach to working with data is through a visual interface. The first thing that happens when you import a dataset into an ArcGIS project is that you get an interactive map visualizing that data. In R on the other hand, when you import a dataset into your project you have only created a connection to that dataset, and may it will be read into your computer’s memory. To visualize your data (which you should do frequently), you need an extra step. This difference between R and ArcGIS is probably what makes ArcGIS so approachable and R so intimidating for beginners. But making a quick visualisation of your geodata is very easy in R, it sometimes just takes a simple line of code. In R, we have to differentiate two different types of outputs: Static maps which can be printed on paper and dynamic maps which you can interact with. Static maps are usually stored in JPG, Tiff of PDF Format which dynamic maps are rendered using html, and javascript. In the beginning, you don’t have to worry about these formats because RStudio automatically displays the maps in the correct pane (“Plot” for static maps and “Viewer” for dynamic maps). A dynamic map is what you get “for free” in ArcGIS within your “Map Window,” a Static map is what you would get when you export a “Layout” to jpg or pdf to use in a report. Prerequisite: Before you start making maps, you will have to familiarize yourself with importing raster or vector data into R. Read chapter 2 to get up to speed. "],["Static_Maps.html", "3.1 Static Maps", " 3.1 Static Maps As we saw in chapter 2, we can quickly visualize geodata by simply calling plot on the dataset. library(arc2r) library(sf) ## Linking to GEOS 3.8.1, GDAL 3.1.4, PROJ 6.3.1 library(raster) plot(gemeinde_zh[&quot;bezirksnam&quot;]) plot(swissAlti3D) This is fine for quick view of the data, but as you want to add more layers, legend etc. using base::plot() becomes complicated. There are many alternative methods to visualizing spatial data, we will showcase our favourite methods here. 3.1.1 Package ggplot2 If you are familiar with ggplot2 you can rejoice: Plotting sf objects has become very easy with this package. If you do not know this package yet, we recommend you familiarize yourself with it first before diving into this chapter. We will continue to work with the datasets used above 3.1.1.1 sf objects library(ggplot2) ggplot(gemeinde_zh) + geom_sf() In its most basic form, we can visualize the geometry of our sf object.As always in ggplot2, if you want to use a column from your dataset as an input for, say, colour, you need to specify this with aes(): ggplot(gemeinde_zh) + geom_sf(aes(fill = bezirksnam)) To change the default graticules from WGS84 to a custom Coordinate System, we can use the argument datum in coord_sf and call the EPSG Code of our desired coordinate system. //todo add chapter on CRS //body ArcGIS Users are usually not familiar with ESPG Codes, we should provide an introduction somewhere and reference this here. ggplot(gemeinde_zh) + geom_sf(aes(fill = bezirksnam)) + coord_sf(datum = 2056) How we can use our standard ggplot2 methods to polish this plot: ggplot(gemeinde_zh) + geom_sf(aes(fill = bezirksnam), colour = &quot;white&quot;) + labs(title = &quot;Gemeinden des Kantons Zürich nach Bezirk&quot;,fill = &quot;&quot;) + theme_void() + theme(legend.position = &quot;bottom&quot;) 3.1.1.2 raster objects //todo use a raster object with the same extent as the sf object While sf objects are very easily integrated in ggplot2, raster data is a little harder. There are various ways to plot a raster object with ggplot2. A simple, adhoc approach is converting the RasterLayer object into a data.frame and then plotting it with geom_raster. swissAlti3D_df &lt;- as.data.frame(swissAlti3D,xy = TRUE) # xy = TRUE adds the x and y coordinates to our dataframe as columns # Note the column names of our dataframe head(swissAlti3D_df) ## x y SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196 ## 1 2600005 1196995 673.6359 ## 2 2600015 1196995 673.6822 ## 3 2600025 1196995 674.3226 ## 4 2600035 1196995 675.7197 ## 5 2600045 1196995 679.8717 ## 6 2600055 1196995 684.2903 ggplot(swissAlti3D_df, aes(x, y, fill = SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196)) + geom_raster() Note that this approach, ggplot is not aware of the coordinate system assigned to our dataset. The x and y coordinates from our dataframe are assumed to be in a cartesian coordinate system. This implies two things: This approach only works with datasets in a projected coordinate system (where the raster is assumed to be on a plane) We have to specify that the coordinate system in the two direction are equal with cord_equal() (coord_sf() will not work if we don’t have any sf objects) //todo add example of WGS84 raster ggplot(swissAlti3D_df, aes(x, y, fill = SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196)) + geom_raster() + scale_fill_viridis_c() + theme_void() + coord_equal() + theme(legend.position = &quot;bottom&quot;) //todo combine sf and raster //body add an example of how sf and raster can be layered. This needs an additional dataset. 3.1.2 Package tmap While ggplot2 was extended to work with spatial data, the package tmap was specifically designed to create maps. The developer created this package leaning on the “grammar of graphics” approach which is also implemented in ggplot2, so many of the concepts are the same (e.g. the concept of “layers” and using the +-sign). One main difference is that tmap does not use NSE, so column names always need to be quoted. library(tmap) tmap_mode(&quot;plot&quot;) # &lt;- to create static plots ## tmap mode set to plotting tm_shape(gemeinde_zh) + tm_polygons(col = &quot;bezirksnam&quot;) The fact that tmap is designed for maps makes it much easier to add map elements, such as a North Arrow. tm_shape(gemeinde_zh) + tm_polygons(col = &quot;bezirksnam&quot;) + tm_compass() It also means that visualizing a RasterLayer is built in to the package: tm_shape(swissAlti3D) + tm_raster() The most amazing thing about tmap probably is tmap_mode(\"view\"). Run this code and then the two chunks above, you will be amazed. Learn more about this in chapter Interactive Maps. "],["Dynamic_Maps.html", "3.2 Interactive Maps", " 3.2 Interactive Maps As introduced in chapter Making Maps, an interactive Map is the fundamental building block of ArcGIS. In R, we need to do some extra work to create such an interactive map, but this extra work sometimes means just one line of code. There are multiple packages that simplify creating maps: leaflet mapview tmap plotly mapview and tmap both build on the package leaflet, which in turn builds on leaflet, an open source JavaScript Library for interactive maps. There really is not much need to learn leaflet, since using mapview or tmap is much simpler. The package plotly builds on plotly, a very versatile graphics library that provides an API for R, Python and Julia. It is an amazing tool, but we will focus more on mapview and tmap. 3.2.1 Package mapview The package mapview is highly automated and you get a very decent map when calling the function mapview::mapview on your geodata, without any additional arguments. The aim of the package is to be quick and easy, as emphasized in the documentation: It’s main goal is to fill the gap of quick […] interactive plotting to examine and visually investigate both aspects of spatial data, the geometries and their attributes. library(arc2r) library(sf) library(raster) library(mapview) ## GDAL version &gt;= 3.1.0 | setting mapviewOptions(fgb = TRUE) This next line of code generates a representation of your data (in this case, gemeindegrenzen_zh), much like the default map in ArcGIS. RSTUDIO_USER_IDENTITY &lt;- Sys.getenv(&quot;RSTUDIO_USER_IDENTITY&quot;) mapview(gemeindegrenzen_zh) If the emphasis lies on creating a highly customized map, then tmap may be more appropriate. 3.2.2 Package tmap Like mentioned in the previous chapter, the package tmap facilitates creating highly customized maps. But the greatest strength in tmap comes from it’s versatility: All you need to do is specify how you want your data to be displayed, and tmap can render this into an interactive map of a static one that you can print. All you need to do is change the mode within the function tmap_mode() to view. library(tmap) tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing As shown in chapter ??, the tmap syntax very similar to ggplot2s, in the sense that connect “layers” using a + sign. tm_shape(gemeindegrenzen_zh) + tm_polygons() This interactive map is very similar to the one generated by mapview, which is not surprising since they are both built on top of leaflet. 3.2.3 Further ressources For more information on tmap, check out the package’s gihub site: https://github.com/mtennekes/tmap For more information on interactive maps in general, head over to the great book “Geocomputation with R”: https://geocompr.robinlovelace.net/adv-map.html#interactive-maps "],["Selection.html", "4 Selection", " 4 Selection A very commonly used tool in ArcGIS is the concept of “Selection.” The idea is, that you select features from your vector dataset in one of the following three ways: Select: Interactively by clicking in your map Select By Attributes: By specifying (non-spatial) criteria based on the attribute table Select By Location: By specifying spatial criteria based on the relationship to another dataset. Figure 4.1: A very commonly used tool: The selection tools from the ArcGIS Pro Map Pane Using the tools via these buttons (4.1 have two effects. The selected features are highlighted visually Any operation performed with a dataset that has an active selection respects this selection. In other words, the operation is only performed on the selected features. This second effect is cause for many confusing errors, either because the user forgot that a selection was active or the there were zero elements matching the specified criteria and so the operation was performed on an empty dataset. For this reason, this type of “floating selection” is not very useful and was never implemented in R. However, two of the three described methods to select data are supported in R, but with a different approach. The selected data leaves the original data unchanged, but must assigned to a new R object1. Interactive selection (button “Select” in 4.1 is a priori not reproducible and therefore not supported in R. By the way: In the world of SQL this type of operation is not called “selection” but “filtering.” Consequently, that is also the name used in R. In R as well as SQL, a select is done on columns in a dataset, not on rows (i.e. if you want to retain only a subset of the columns in a dataset). or, if you are familiar with pipes, piped into a new operation↩︎ "],["Select_by_Attribute.html", "4.1 Select by Attribute", " 4.1 Select by Attribute //todo does this stay here or move to Analysis -&gt; Extract -&gt; Select? One of the popular approaches in ArcGIS pro for selecting features in a layer is by using an attribute query. The action is performed using the Select By Attributes tool. Select By Attributes tool allows us to provide an SQL query expression to select features that match the selection criteria. R on the other hand offers quite easy and straightforward options to perform similar operations. Let’s examine one of them. As a first step, we might want to import a shapefile. To do so, we can use sf package to work with vector data in R. Important to know is that the rgdal package automatically loads when sf is loaded. In the code snippet below, we read the shapefile, which represents the parking spots for bicycles within the canton of Zurich. The dataset is publicly available for download in the following link: (https://opendata.swiss/en/dataset/veloparkierungsanlagen). library(sf) library(ggplot2) parkBikes &lt;- st_read(&quot;sample_data/Kanton_Zuerich/Veloparkierungsanlagen/OGD_VELOPARKIERANLAGEN_P.shp&quot;) ## Reading layer `OGD_VELOPARKIERANLAGEN_P&#39; from data source `/Users/runner/work/book/book/sample_data/Kanton_Zuerich/Veloparkierungsanlagen/OGD_VELOPARKIERANLAGEN_P.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 511 features and 28 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2669965 ymin: 1229454 xmax: 2707390 ymax: 1280235 ## projected CRS: CH1903+ / LV95 After importing the dataset, let’s say we want to filter it by selecting only the parking spots that lie within a specific municipality (Gemeinde) in the canton of Zurich. More specifically, we will select only the parking spots within the municipality of Winterthur. For the aforementioned operation, R offers the function filter(), which lies within the dplyr package. This functions works as follows: filter(dataset, condition) library(dplyr) parkBikes_winti &lt;- filter(parkBikes,GEMEINDE == &quot;Winterthur&quot;) The operation above produces the same outcome as the one depicted in the figure below 4.2. Figure 4.2: Select by Attributes in ArcGIS pro "],["Select_by_Location.html", "4.2 Select by Location", " 4.2 Select by Location A very common operations when dealing with geodata is the process of selecting features based on a spatial relationship to another object (layer). In ArcGIS pro this process is usually performed using the Select by Location tool. This tool offers selecting features based on the following relationships: intersect: The features in the input layer will be selected if they intersect a selecting feature. This is the default. intersect_3d: The features in the input layer will be selected if they intersect a selecting feature in three-dimensional space (x, y, and z). within_a_distance: The features in the input layer will be selected if they are within the specified distance (using Euclidean distance) of a selecting feature. Use the search_distance parameter to specify the distance. within_a_distance_3d: The features in the input layer will be selected if they are within a specified distance of a selecting feature in three-dimensional space. Use the search_distance parameter to specify the distance. within_a_distance_geodesic: The features in the input layer will be selected if they are within a specified distance of a selecting feature. Distance between features will be calculated using a geodesic formula that takes into account the curvature of the spheroid and correctly handles data near and across the dateline and poles. Use the search_distance parameter to specify the distance. contains: The features in the input layer will be selected if they contain a selecting feature. completely_contains: The features in the input layer will be selected if they completely contain a selecting feature. contains_clementini: This spatial relationship yields the same results as COMPLETELY_CONTAINS with the exception that if the selecting feature is entirely on the boundary of the input feature (no part is properly inside or outside), the feature will not be selected. CLEMENTINI defines the boundary polygon as the line separating inside and outside, the boundary of a line is defined as its end points, and the boundary of a point is always empty. within: The features in the input layer will be selected if they are within a selecting feature. completely_within: The features in the input layer will be selected if they are completely within or contained by a selecting feature. within_clementini: The result will be identical to WITHIN with the exception that if the entirety of the feature in the input layer is on the boundary of the feature in the selecting layer, the feature will not be selected. CLEMENTINI defines the boundary polygon as the line separating inside and outside, the boundary of a line is defined as its end points, and the boundary of a point is always empty. are_identical_to: The features in the input layer will be selected if they are identical (in geometry) to a selecting feature. boundary_touches: The features in the input layer will be selected if they have a boundary that touches a selecting feature. When the input features are lines or polygons, the boundary of the input feature can only touch the boundary of the selecting feature, and no part of the input feature can cross the boundary of the selecting feature. share_a_line_segment_with: The features in the input layer will be selected if they share a line segment with a selecting feature. The input and selecting features must be line or polygon. crossed_by_the_outline_of: The features in the input layer will be selected if they are crossed by the outline of a selecting feature. The input and selecting features must be lines or polygons. If polygons are used for the input or selecting layer, the polygon’s boundary (line) will be used. Lines that cross at a point will be selected; lines that share a line segment will not be selected. have_their_center_in: The features in the input layer will be selected if their center falls within a selecting feature. The center of the feature is calculated as follows: for polygon and multipoint, the geometry’s centroid is used; for line input, the geometry’s midpoint is used. Note that many these relationships are specified in an elegant, generic approach known as “Spatial Predicates”. Read more about this in chapter 12.1 The operations are based on the following rule: x[y, ,operation], where: x and y are the spatial objects for which we want to investigate if there is a spatial relationship (x is the target feature, while y is the source one) the second argument [, ,] within the brackets denotes the column number we want to retrieve from the spatial subsetting. In our example this argument was empty, which means we wanted to retrieve all rows for every attribute column. the third argument [op = ] specifies the spatial operation we want to perform. In the example above, the goal was to find out how many subset features of the target object swimmSpots lie withing the source spatial object richterswil. For that reason we chose the function st_within(). For this chapter, we will use the following libraries: 4.2.1 Intersect 4.2.2 Intersect_3d 4.2.3 Within_a_distance 4.2.4 Within_a_distance_3d 4.2.5 Within_a_distance_geodesic 4.2.6 Contains 4.2.7 Completely_contains 4.2.8 Contains_clementini 4.2.9 Within An example of spatial subsetting could be the following. Let’s assume we have as a polygon dataset with all the municipalities (Gemeinden) of the Canton of Zurich. Furthermore, we are also using a shapefile in the form of a point dataframe, which represents all the “swimming spots” (Badenplätze) in the same spatial region (Canton of Zurich). So, ultimately, our goal is to find out the “swimming spots” that lie within a specific municipality of the Canton of Zurich. # Minicipalities (Gemeinde) in Canton Zurich gemeinde_ZH &lt;- st_read(&quot;sample_data/Kanton_Zuerich/Gemeinde_ZH.shp&quot;) ## Reading layer `Gemeinde_ZH&#39; from data source `/Users/runner/work/book/book/sample_data/Kanton_Zuerich/Gemeinde_ZH.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 166 features and 7 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 2669245 ymin: 1223896 xmax: 2716900 ymax: 1283343 ## projected CRS: CH1903+ / LV95 # &quot;Swimming&quot; spots in the Canton of Zurich swimmSpots &lt;- st_read(&quot;sample_data/Kanton_Zuerich/Badeplaetze_ZH.shp&quot;) ## Reading layer `Badeplaetze_ZH&#39; from data source `/Users/runner/work/book/book/sample_data/Kanton_Zuerich/Badeplaetze_ZH.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 71 features and 6 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2671636 ymin: 1226720 xmax: 2710101 ymax: 1282760 ## projected CRS: CH1903+ / LV95 swimmSpots_richt &lt;- swimmSpots[richterswil, ,op = st_within] 4.2.10 Completely_within 4.2.11 Within_clementini 4.2.12 Are_identical_to 4.2.13 Boundary_touches 4.2.14 Share_a_line_segment_with 4.2.15 Crossed_by_the_outline_of 4.2.16 Have_their_center_in "],["03_Part_Geoprocessing_Tools.html", "5 About this Section", " 5 About this Section As described in 1.2, ESRI’s approach to building ArcGIS is to build a tool for every situation you might encounter. This is a little different in R. Depending on the package, the idea is usually to provide a minimal set of functions with which the user can create their own tools. The creators of the package sf are very strict on this paradigm and are fairly vocal on it (see this, this and this thread). We haven’t found a complete overview of all the geprocessing tools in ArcGIS, but we’ve scraped ESRIS website and counted 38 Toolboxes, containing 244 Toolsets and 1132 individual tools2. See figure ?? for an interactive visualisation of all tools in ArcGIS. Figure 5.1: A ‘diagonal Network’ visualisation of all tools available in ArcGIS Pro. Hover over the blue circles to see the Name in a larger font. We cannot possibly cover all these tools in this book, and it wouldn’t make much sense either. Once you learn the fundamental building blocks, you will be able to replicate most, if not all tools from this list. Figure ?? shows a subset of the full toolset, which we would like to cover in this book. Figure 5.2: A subset of tools we would like to cover in this book. Note: these numbers are an approximation only, we may have made errors when scraping↩︎ "],["General.html", "5.1 General Toolset", " 5.1 General Toolset 5.1.1 Sort Sorting out features in ascending or descending order seems a quite primitive operation in any programming language or software package. Even though it is indeed primitive, it is also quite important for filtering and cleaning our datasets. In ArcGIS pro this operation is performed using the tool Sort, which is part of the General toolset of the Data Managenent Toolbox. Below we present how we can perform the aforementioned operation using R. For our example we use the Simple Feature object bezirke, which depicts the districts within the country of Switzerland Furthermore for performing the sorting operation, we use the record(column) that represents the area (in square km) of every of the districts. ## Simple feature collection with 6 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2574333 ymin: 1210642 xmax: 2744654 ymax: 1279605 ## z_range: zmin: -1.455192e-11 zmax: -1.455192e-11 ## CRS: NA ## NAME OBJEKTART OBJECTID area_km2 geom ## 68 St. Gallen Bezirk 153 0.1150075 MULTIPOLYGON Z (((2744592 1... ## 133 Höfe Bezirk 1 0.1312150 MULTIPOLYGON Z (((2701415 1... ## 186 Schaffhausen Kanton 176 0.2405185 MULTIPOLYGON Z (((2707903 1... ## 104 Seeland Bezirk 9 0.4128530 MULTIPOLYGON Z (((2575776 1... ## 119 Wil Bezirk 145 0.5292165 MULTIPOLYGON Z (((2732986 1... ## 131 Höfe Bezirk 43 0.5612065 MULTIPOLYGON Z (((2702572 1... ## Simple feature collection with 6 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2580900 ymin: 1128447 xmax: 2833842 ymax: 1219106 ## z_range: zmin: -1.455192e-11 zmax: -1.455192e-11 ## CRS: NA ## NAME OBJEKTART OBJECTID area_km2 ## 15 Surselva Bezirk 13 1373.7973 ## 9 Interlaken-Oberhasli Bezirk 15 1231.6744 ## 2 Engiadina Bassa/Val Müstair Bezirk 74 1197.5201 ## 171 Uri Kanton 159 1076.0927 ## 4 Maloja Bezirk 183 973.7269 ## 52 Bern-Mittelland Bezirk 89 939.6023 ## geom ## 15 MULTIPOLYGON Z (((2713720 1... ## 9 MULTIPOLYGON Z (((2629665 1... ## 2 MULTIPOLYGON Z (((2812980 1... ## 171 MULTIPOLYGON Z (((2684185 1... ## 4 MULTIPOLYGON Z (((2775675 1... ## 52 MULTIPOLYGON Z (((2587852 1... The beauty of R is that offers more than one option to perform a specific operation. In the example above, for performing the sorting operation, we used a simple subsetting method integrated within the so called base R. Nevertheless using the the function arrange() of the dpyr package we are able to produce the exact same result. ## Simple feature collection with 6 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2574333 ymin: 1210642 xmax: 2744654 ymax: 1279605 ## z_range: zmin: -1.455192e-11 zmax: -1.455192e-11 ## CRS: NA ## NAME OBJEKTART OBJECTID area_km2 geom ## 1 St. Gallen Bezirk 153 0.1150075 MULTIPOLYGON Z (((2744592 1... ## 2 Höfe Bezirk 1 0.1312150 MULTIPOLYGON Z (((2701415 1... ## 3 Schaffhausen Kanton 176 0.2405185 MULTIPOLYGON Z (((2707903 1... ## 4 Seeland Bezirk 9 0.4128530 MULTIPOLYGON Z (((2575776 1... ## 5 Wil Bezirk 145 0.5292165 MULTIPOLYGON Z (((2732986 1... ## 6 Höfe Bezirk 43 0.5612065 MULTIPOLYGON Z (((2702572 1... ## Simple feature collection with 6 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2580900 ymin: 1128447 xmax: 2833842 ymax: 1219106 ## z_range: zmin: -1.455192e-11 zmax: -1.455192e-11 ## CRS: NA ## NAME OBJEKTART OBJECTID area_km2 ## 1 Surselva Bezirk 13 1373.7973 ## 2 Interlaken-Oberhasli Bezirk 15 1231.6744 ## 3 Engiadina Bassa/Val Müstair Bezirk 74 1197.5201 ## 4 Uri Kanton 159 1076.0927 ## 5 Maloja Bezirk 183 973.7269 ## 6 Bern-Mittelland Bezirk 89 939.6023 ## geom ## 1 MULTIPOLYGON Z (((2713720 1... ## 2 MULTIPOLYGON Z (((2629665 1... ## 3 MULTIPOLYGON Z (((2812980 1... ## 4 MULTIPOLYGON Z (((2684185 1... ## 5 MULTIPOLYGON Z (((2775675 1... ## 6 MULTIPOLYGON Z (((2587852 1... 5.1.2 Rename 5.1.3 Merge Let’s assume in the example below that instead of having four individual areas of interest, we are interested in having one common, unified area on which we focus our analysis. In other words, we have to merge the existing four areas into one. In ArcGIS pro the respective tools for this action is either the Merge or the Dissolve tool. In R on the other hand, this can be easily performed using the st_union function in the sf package. Let’s assume in the example below that instead of having four individual areas of interest, we are interested in having one common, unified area on which we focus our analysis. In other words, we have to merge the existing four areas into one. In ArcGIS pro the respective tools for this action is either the Merge or the Dissolve tool. In R on the other hand, this can be easily performed using the st_union function in the sf package. The dataset has multiple features and columns. ## Simple feature collection with 56 features and 22 fields ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2485410 ymin: 1075268 xmax: 2833858 ymax: 1295934 ## z_range: zmin: 193.51 zmax: 4613.729 ## projected CRS: CH1903+ / LV95 ## First 10 features: ## uuid datum_aend datum_erst erstellung ## 1 {0B2364ED-49E0-4D53-A33C-C684DD530B57} 2018-11-22 2012-10-26 2012 ## 2 {DDD56CEF-0E61-4EED-85ED-F67A459C93ED} 2018-11-22 2012-10-26 2012 ## 3 {54B25E50-30A7-4995-ADE3-5FFF6E13A995} 2018-11-22 2012-10-26 2012 ## 4 {921DFEF2-6D91-4CB8-9CFC-2A831C412020} 2018-11-22 2012-10-26 2012 ## 5 {95F10F52-8B2F-4D6A-AF7E-D4F915E42F89} 2018-11-22 2012-10-26 2012 ## 6 {05D55405-466B-4ECC-83C7-A906DEB0D607} 2017-12-04 2012-10-26 2012 ## 7 {FB7105B8-6D7C-4787-846E-17B2BC145C6E} 2018-11-22 2012-10-26 2012 ## 8 {B01E1FB4-9A9B-48AC-BCA3-7D6D93BA23F3} 2015-12-09 2012-10-26 2012 ## 9 {A7C284E4-45C4-44E2-ABAF-D1A0EAB10397} 2016-12-09 2012-10-26 2012 ## 10 {E11CD2CA-2E2D-415C-8789-C10D7C26E441} 2016-12-09 2012-10-26 2012 ## erstellu_1 revision_j revision_m grund_aend herkunft herkunft_j herkunft_m ## 1 10 2019 1 400 500 2019 1 ## 2 10 2019 1 400 500 2019 1 ## 3 10 2019 1 400 500 2019 1 ## 4 10 2019 1 400 500 2019 1 ## 5 10 2019 1 400 500 2019 1 ## 6 10 2019 1 400 100 2018 1 ## 7 10 2019 1 400 500 2019 1 ## 8 10 2019 1 400 500 2015 12 ## 9 10 2019 1 400 100 2017 1 ## 10 10 2019 1 400 100 2017 1 ## objektart kantonsnum see_flaech revision_q kantonsfla kanton_tei name ## 1 0 18 0 2018_Aufbau 710530 0 Graubünden ## 2 0 2 11897 2018_Aufbau 595952 1 Bern ## 3 0 23 1060 2018_Aufbau 522463 0 Valais ## 4 0 22 39097 2018_Aufbau 321201 1 Vaud ## 5 0 21 7147 2018_Aufbau 281216 0 Ticino ## 6 0 17 7720 2018_Aufbau 202820 1 St. Gallen ## 7 0 1 6811 2018_Aufbau 172894 0 Zürich ## 8 0 10 7818 2018_Aufbau 167142 1 Fribourg ## 9 0 3 6438 2018_Aufbau 149352 0 Luzern ## 10 0 19 870 2018_Aufbau 140380 1 Aargau ## icc einwohnerz Shape_Leng Shape_Area geometry ## 1 CH 197888 758037.4 7105296340 MULTIPOLYGON Z (((2709777 1... ## 2 CH 1031126 746961.0 5950475482 MULTIPOLYGON Z (((2578310 1... ## 3 CH 341463 549348.2 5224634417 MULTIPOLYGON Z (((2679715 1... ## 4 CH 793129 565479.5 3118546162 MULTIPOLYGON Z (((2549756 1... ## 5 CH 353709 363207.1 2812159071 MULTIPOLYGON Z (((2679715 1... ## 6 CH 504686 494074.2 2028094302 MULTIPOLYGON Z (((2703763 1... ## 7 CH 1504346 312972.5 1728941806 MULTIPOLYGON Z (((2673542 1... ## 8 CH 315074 341626.4 1520692561 MULTIPOLYGON Z (((2569696 1... ## 9 CH 406506 287121.8 1493517881 MULTIPOLYGON Z (((2678306 1... ## 10 CH 670988 328943.4 1403783345 MULTIPOLYGON Z (((2673542 1... After doing the union, we have only one feature and no columns. ## Geometry set for 1 feature ## geometry type: POLYGON ## dimension: XYZ ## bbox: xmin: 2485410 ymin: 1075268 xmax: 2833858 ymax: 1295934 ## z_range: zmin: 193.51 zmax: 4613.729 ## projected CRS: CH1903+ / LV95 The operation above produces the same outcome as the one depicted in the figure below ??. Figure 5.3: Dissolve operation in ArcGIS pro 5.1.4 Dissolve 5.1.5 Find Identical 5.1.6 Append "],["Raster_Processing_toolset.html", "5.2 Raster Processing Toolset", " 5.2 Raster Processing Toolset Clip Raster Composite Bands Compute Pansharpen Weights Create Ortho Corrected Raster Dataset Create Pansharpened Raster Dataset Extract Subdataset Generate Table From Raster Function Raster To DTED Resample Split Raster 5.2.1 Clip Raster In GIS operations is quite common the necessity of “clipping” an area based on some specific region of interest. This is a quite useful and necessary procedure not only when we are dealing with vector datasets, but also when we have to work with raster ones. In ArcGIS pro the procedure of “cutting” a portion of a raster dataset, mosaic dataset, or an image service layer is performed using Clip Raster tool. In R, the respective operation can be performed using the mask() function. For the example below, we are using the following datasets: ARE_waedi: Vector dataset that depicts the public transport connection quality in the city of Wädenswil raster_recycling: Dataset derived from the spatial interpolation of all the available “recycling points”in the city of Wädenwil # Read raster dataset library(raster) library(stars) library(sf) library(dplyr) library(stars) # Insert a vector dataset that depicts the public transport connection quality in # the city of Wädenswil and plot it ARE_waedi &lt;- read_sf(&quot;sample_data/Entsorgung_Waedenswil/ARE_waedenswil.shp&quot;) # Read the raster dataset and plot it raster_recycling &lt;- raster(&quot;sample_data/Entsorgung_Waedenswil/abfall_raster.tif&quot;) Plot the two datasets one over the other. In our case, the vector dataset serves as the clipping extent for the clipping operation. recycle_Waedi_clip &lt;- mask(raster_recycling,ARE_waedi) Visualising the clipped output "],["Data_Management.html", "6 Data Management Toolbox", " 6 Data Management Toolbox Data Management toolbox in ArcGIS pro provides the users a variety of tools for managing, maintaining and developing datasets that come in all possible forms (feature classes / datasets, raster datasets). We will focus on covering the following tools from this toolbox: "],["Sampling_toolset.html", "6.1 Sampling Toolset", " 6.1 Sampling Toolset 6.1.1 Generate Tessellation 6.1.2 Create Fishnet 6.1.3 Create Random Points 6.1.4 Generate Points Along Lines 6.1.5 Generate Rectangles Along Lines 6.1.6 Generate Transects Along Lines "],["Join_toolset.html", "6.2 Joins and Realates Toolset", " 6.2 Joins and Realates Toolset //todo revise this chapter //body nothing about this chapter is spatial, the explanation is not based on ArcGIS Tools, the joins are not intuitive (what are df1 and df2?) In ArcGIS, joining two datasets on a common attribute is done with tools from the “Join” Toolset. Similar as described with the Selection tools in chapter 4, a join has a temporary / floating nature and does not automatically produce an output. In R, joining two datasets requires is only persistent if the output is assigned to a new variable3. In R we have two main functions for joining two datasets. On the one hand there is the base R function merge, on the other hand there is the *_join family that lie within the dplyr package. Since the latter family of functions are very close to how Joins are done in SQL, we will use the latter case for our examples below. Before we begin with our examples, we have to make clear the differences among the various forms of join operations. Inner Join only retains rows that are matched in both datasets. Outer Join retains all rows from both datasets. Left Join retains all rows from the “left” dataset, Right Join only those from the “right” dataset. Figure 6.1: Join operations 6.2.1 Inner join Inner Join in R is the most common type of join. It is an operation that returns the rows when the matching condition is fulfilled. Below we demonstrate it with an example. ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 4 los angeles lakers 17 ## 3 6 milwaukee bucks 1 ## 4 11 boston celtics 17 ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 2 philadelphia 76ers 3 ## 3 11 boston celtics 17 ## 4 8 los angeles clippers 0 ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 11 boston celtics 17 6.2.2 Outer join Outer join in R using simply returns all rows from both data frames. This is very well depicted in figure 6.1. ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 4 los angeles lakers 17 ## 3 6 milwaukee bucks 1 ## 4 11 boston celtics 17 ## 5 2 philadelphia 76ers 3 ## 6 8 los angeles clippers 0 6.2.3 Left / Right join The left join in R returns all records from the data frame on the left, as well as and the matched records from the one at the right. ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 4 los angeles lakers 17 ## 3 6 milwaukee bucks 1 ## 4 11 boston celtics 17 Similarly works also the right join. ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 11 boston celtics 17 ## 3 2 philadelphia 76ers 3 ## 4 8 los angeles clippers 0 or piped into a new function↩︎ "],["Projections_and_Transformations_toolset.html", "6.3 Projections and Transformations Toolset", " 6.3 Projections and Transformations Toolset If there is anything special about spatial, it’s the Coordinate Reference System. We will not get into the topic of CRS and Projections here, but it is advisable to get up to speed on this topic if you are dealing with geodata. From this toolset, we will cover the following tools: Define Projection Project Project Raster Rescale (Resizes a raster by the specified x and y scale factors) 6.3.1 Define Projection Overwrites the coordinate system information (map projection and datum) stored with a dataset. This tool is intended for datasets that have an unknown or incorrect coordinate system defined. If your dataset comes without an assigned CRS, things can get hairy. Usually, you can make an informed guess as to which CRS the dataset is associated with, but in the end only the data producer can tell you. Let’s take the dataset bezirke from the package arc2r. As you can see, the CRS field in the data’s header is NA. ## Simple feature collection with 192 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2485424 ymin: 1075268 xmax: 2833842 ymax: 1295937 ## z_range: zmin: -1.455192e-11 zmax: -1.455192e-11 ## CRS: NA ## First 10 features: ## NAME OBJEKTART OBJECTID area_km2 ## 1 Albula Bezirk 137 683.35044 ## 2 Engiadina Bassa/Val Müstair Bezirk 74 1197.52015 ## 3 Prättigau/Davos Bezirk 112 853.35653 ## 4 Maloja Bezirk 183 973.72688 ## 5 Entremont Bezirk 72 633.27334 ## 6 Visp Bezirk 182 29.27770 ## 7 Visp Bezirk 167 835.54866 ## 8 Sierre Bezirk 88 417.76967 ## 9 Interlaken-Oberhasli Bezirk 15 1231.67445 ## 10 Hérens Bezirk 143 55.10483 ## geom ## 1 MULTIPOLYGON Z (((2758433 1... ## 2 MULTIPOLYGON Z (((2812980 1... ## 3 MULTIPOLYGON Z (((2767328 1... ## 4 MULTIPOLYGON Z (((2775675 1... ## 5 MULTIPOLYGON Z (((2574263 1... ## 6 MULTIPOLYGON Z (((2633950 1... ## 7 MULTIPOLYGON Z (((2630650 1... ## 8 MULTIPOLYGON Z (((2598823 1... ## 9 MULTIPOLYGON Z (((2629665 1... ## 10 MULTIPOLYGON Z (((2593875 1... Calling the function st_crs() on bezirke confirms this. ## Coordinate Reference System: NA In ArcGIS, we would use the Tool “Define projection.” In R, we use the function st_crs(dataset) &lt;- value, where value is the CRS of our dataset. It can be either A string accepted by GDAL (type character) A valid EPSG value (type integer) or An object of class crs We find option two to be the simplest approach. Since we know the dataset bezirke is in the new swiss coordinate system (CH1903+ / LV95), we can find out the EPSG code (e.g. by consulting epsg.io). We will not get into options 1 and 3 and only If we look at our header again, we see that we have a new field projected CRS which is in fact displaying the correct name based on the EPSG code we provided. ## Simple feature collection with 192 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2485424 ymin: 1075268 xmax: 2833842 ymax: 1295937 ## z_range: zmin: -1.455192e-11 zmax: -1.455192e-11 ## projected CRS: CH1903+ / LV95 ## First 10 features: ## NAME OBJEKTART OBJECTID area_km2 ## 1 Albula Bezirk 137 683.35044 ## 2 Engiadina Bassa/Val Müstair Bezirk 74 1197.52015 ## 3 Prättigau/Davos Bezirk 112 853.35653 ## 4 Maloja Bezirk 183 973.72688 ## 5 Entremont Bezirk 72 633.27334 ## 6 Visp Bezirk 182 29.27770 ## 7 Visp Bezirk 167 835.54866 ## 8 Sierre Bezirk 88 417.76967 ## 9 Interlaken-Oberhasli Bezirk 15 1231.67445 ## 10 Hérens Bezirk 143 55.10483 ## geom ## 1 MULTIPOLYGON Z (((2758433 1... ## 2 MULTIPOLYGON Z (((2812980 1... ## 3 MULTIPOLYGON Z (((2767328 1... ## 4 MULTIPOLYGON Z (((2775675 1... ## 5 MULTIPOLYGON Z (((2574263 1... ## 6 MULTIPOLYGON Z (((2633950 1... ## 7 MULTIPOLYGON Z (((2630650 1... ## 8 MULTIPOLYGON Z (((2598823 1... ## 9 MULTIPOLYGON Z (((2629665 1... ## 10 MULTIPOLYGON Z (((2593875 1... 6.3.2 Project Projects spatial data from one coordinate system to another Now that bezirke has an assigned CRS (see 6.3.1, we can transform it into a new coordinate system. To emphasize this, will will visualize the dataset using base::plot() with the option axes = TRUE, to visualize the current coordinate system. plot(bezirke[&quot;area_km2&quot;], axes = TRUE) bezirke_wgs84 &lt;- st_transform(bezirke, 4326) plot(bezirke_wgs84[&quot;area_km2&quot;], axes = TRUE) st_crs(bezirke) ## Coordinate Reference System: ## User input: EPSG:2056 ## wkt: ## PROJCRS[&quot;CH1903+ / LV95&quot;, ## BASEGEOGCRS[&quot;CH1903+&quot;, ## DATUM[&quot;CH1903+&quot;, ## ELLIPSOID[&quot;Bessel 1841&quot;,6377397.155,299.1528128, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4150]], ## CONVERSION[&quot;Swiss Oblique Mercator 1995&quot;, ## METHOD[&quot;Hotine Oblique Mercator (variant B)&quot;, ## ID[&quot;EPSG&quot;,9815]], ## PARAMETER[&quot;Latitude of projection centre&quot;,46.9524055555556, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8811]], ## PARAMETER[&quot;Longitude of projection centre&quot;,7.43958333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8812]], ## PARAMETER[&quot;Azimuth of initial line&quot;,90, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8813]], ## PARAMETER[&quot;Angle from Rectified to Skew Grid&quot;,90, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8814]], ## PARAMETER[&quot;Scale factor on initial line&quot;,1, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8815]], ## PARAMETER[&quot;Easting at projection centre&quot;,2600000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8816]], ## PARAMETER[&quot;Northing at projection centre&quot;,1200000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8817]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;Europe - Liechtenstein and Switzerland&quot;], ## BBOX[45.82,5.96,47.81,10.49]], ## ID[&quot;EPSG&quot;,2056]] bezirke_swiss &lt;- st_transform(bezirke, 2056) # retrieve the coordinate system st_crs(bezirke_swiss) ## Coordinate Reference System: ## User input: EPSG:2056 ## wkt: ## PROJCRS[&quot;CH1903+ / LV95&quot;, ## BASEGEOGCRS[&quot;CH1903+&quot;, ## DATUM[&quot;CH1903+&quot;, ## ELLIPSOID[&quot;Bessel 1841&quot;,6377397.155,299.1528128, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4150]], ## CONVERSION[&quot;Swiss Oblique Mercator 1995&quot;, ## METHOD[&quot;Hotine Oblique Mercator (variant B)&quot;, ## ID[&quot;EPSG&quot;,9815]], ## PARAMETER[&quot;Latitude of projection centre&quot;,46.9524055555556, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8811]], ## PARAMETER[&quot;Longitude of projection centre&quot;,7.43958333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8812]], ## PARAMETER[&quot;Azimuth of initial line&quot;,90, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8813]], ## PARAMETER[&quot;Angle from Rectified to Skew Grid&quot;,90, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8814]], ## PARAMETER[&quot;Scale factor on initial line&quot;,1, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8815]], ## PARAMETER[&quot;Easting at projection centre&quot;,2600000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8816]], ## PARAMETER[&quot;Northing at projection centre&quot;,1200000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8817]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;Europe - Liechtenstein and Switzerland&quot;], ## BBOX[45.82,5.96,47.81,10.49]], ## ID[&quot;EPSG&quot;,2056]] 6.3.3 Project Raster Transforms a raster dataset from one coordinate system to another Working with Raster datasets in GIS of operations is of equal importance, as working with vector ones. One of the spatial properties of raster datasets is the the Coordinate Reference System (CRS). CRS is the specific system that “associates” the raster coordinates (which are just pairs of x/y values) to geographic locations. In ArcGIS pro the tool for projecting a raster dataset is called Project Raster (Data Management). Let’s see how we can perform the same operation with R. We can use the projectRaster() function to reproject a raster into a new CRS. The first argument of the aforementioned function is the raster dataset we want to reproject, while the second one is the dataset to whose projection we are targeting to. So, in our case, we are targeting to the coordinate system of the raster_recycling dataset. It is important to remember that raster reprojection only works when the raster object has already a defined CRS. 6.3.4 Rescale //todo write this chapter "],["Spatial_Analyst.html", "7 Spatial Analyst Toolbox 7.1 Conditional Toolset 7.2 Reclass Toolset 7.3 Surface Toolset", " 7 Spatial Analyst Toolbox 7.1 Conditional Toolset 7.1.1 Kernel Density There are several Function that can be tweaked to calculate KDE for sf-Point object: tmaptools::smooth_map(): Depricated (is there a successor?) spatstat::density.ppp(): Takes only objects of Class ppp MASS::kde2d(): Takes x/y coordinates as vectors and returns a matrix In this example, I take MASS:kde2d() and tweak it to take sf and return raster. First, let’s create some sample data: 7.2 Reclass Toolset 7.3 Surface Toolset 7.3.1 Slope and Aspect In mathematics, the slope or gradient of a line describes its steepness, incline, or grade. A higher slope value indicates a steeper incl. Source: “http://wiki.gis.com/wiki/index.php/Slope” In GIS and specifically in terrain analysis, calculating the terrain slope is of great importance, since it can play a significant role in various forms of technical analysis. The most common way of calculating the slope is from a Digital Elevation Model (DEM). In ArcGIS pro the tool used for computing the slope of a raster dataset with elevation data is called Slope (3D Analyst).It identifies the steepness at each cell of a raster surface. The lower the slope value, the flatter the terrain; the higher the slope value, the steeper the terrain. In R, raster package includes the function terrain(), which helps us compute slope, aspect and other terrain characteristics from a raster with elevation data. Let’s start by computing the slope of the swissAlti3d raster dataset. After importing and visualizing our raster dataset, we use the terrain function to calculate the slope. In the function above, we define the operation we want to perform as the second argument of the function (opt = “slope”). Furthermore, we also define the units of the final result. Similarly, we compute the aspect of a given dataset. Basically as aspect we can consider the compass direction that a slope leans towards. Let’s compute now, using again the same function terrain, the aspect of the same dataset swissALTI3D2019. So, R gives us the option to retrieve multiple terrain characteristics of a raster dataset, using only one function. The aforementioned spatial operation in ArcGIS pro could be performed using the tool Aspect (Spatial Analyst). 7.3.2 Reclassify In GIS quite often arises the necessity to reclassify a raster dataset. In other words, to create new classes with different range of values for the existing cell values of the dataset. This operation in ArcGIS Pro is performed using the Reclassify (Spatial Analyst) tool. In R the respective operation is quite straightforward and is based on the use of the reclassify function of the raster package. For our example we use the raster dataset we computed previously, which depicts the aspect of the swissALTI3D2019 dataset. As a first step, we can compute the histogram of our dataset. ## aspect ## Min. 0.0000 ## 1st Qu. 104.1014 ## Median 163.3606 ## 3rd Qu. 258.6777 ## Max. 359.9991 ## NA&#39;s 12652.0000 ## [1] 0 20 40 60 80 100 120 140 160 180 200 220 240 260 280 300 320 340 360 The number of breaks for our raster values are 19. The aim of ours is to create 4 different classes with the following values: 0°-90° -&gt; Class 1 90°-180° -&gt; Class 2 180°-270° -&gt; Class 3 270°-360° -&gt; Class 4 To do so, we create below a reclassification matrix with the respective values. ## [,1] [,2] [,3] ## [1,] 0 90 1 ## [2,] 90 180 2 ## [3,] 180 270 3 ## [4,] 270 360 4 After creating the respective matrix with the new classes, we are ready to call the reclassify function. The function takes as a first argument the dataset set to be reclassified and as second the matrix, on which the reclassification is based on. "],["3D_Analyst.html", "8 3D Analyst Toolbox 8.1 Raster Interpolation Toolset", " 8 3D Analyst Toolbox 8.1 Raster Interpolation Toolset 8.1.1 IDW ## [inverse distance weighted interpolation] 8.1.2 Kriging ## [inverse distance weighted interpolation] 8.1.3 Natural Neighbor Nearest Neighbor: "],["Image_Analysis.html", "9 Image Analysis Toolbox 9.1 Map Algebra Toolset", " 9 Image Analysis Toolbox 9.1 Map Algebra Toolset 9.1.1 Raster Calulator In GIS Softwares (ArcGIS pro, QGIS etc) Raster Calculator is one of the most commonly used tools for performing various operations with raster datasets. For the example below we will work with 2 datasets that depict India’s population at two different timestamps. Our goal is to produce an output raster that demonstrates the evolvement of country’s population in this 10 years timespan. Naturally in ArcGIS pro, the aforementioned operation would be performed with the use of Raster Calculator. Let’s explore our options with R. Let’s compute now the difference between the two rasters. To do so, there are various options. As first we can create a function that performs a simple subtraction of two rasters. Since, we created the function for subtracting one raster from another, we use now the function overlay of the raster package for producing the new raster output. 9.1.2 Focal Statistics 9.1.3 Zonal Statistics Focal statistics performs a neighbourhood operation that computes an output raster, where the value for each output cell is a function of the values of all the input cells that are in a specified neighborhood around that location. The function performed on the input is a statistic, such as the maximum, average, or sum of all values encountered in that neighborhood. Source: https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-analyst/how-focal-statistics-works.html In R in order to apply functions focally to rasters, important is to define the neighbouring cells. In other words to define the moving window for each of these functions. As an example below, we will create our own raster object. We will recompute now the raster based on the focal function of the raster package. In the function below, the neighbourhood for which we apply the statistic is represented by the argument w, while the statistic by the argument fun. The operation above can be also performed with the use of the focal function of the terra package. w represents the moving window of the function. The window can be defined as one (for a square) or two numbers (row, col); or with an odd-sized weights matrix. More details can be found here: https://rdrr.io/cran/terra/man/focal.html fun represents the specified statistic for the identified neighbourhood (e.g mean,sum etc) 9.1.4 Zonal Statistics Zonal Statistics tool in ArcGIS pro is used for calculating the statistics on values of a raster within the zones of another dataset. In R we are able to produce similar results with the use of zonal function of the raster package. ## zone sum ## [1,] 1 99.58052 ## [2,] 2 305.81367 ## [3,] 3 475.71375 ## [4,] 4 707.51735 ## [5,] 5 796.50114 ## zone mean ## [1,] 1 4.979026 ## [2,] 2 15.290684 ## [3,] 3 23.785688 ## [4,] 4 35.375867 ## [5,] 5 39.825057 ## zone min ## [1,] 1 0.1487266 ## [2,] 2 1.9187318 ## [3,] 3 3.1954170 ## [4,] 4 4.5574448 ## [5,] 5 2.8274044 "],["Analysis.html", "10 Analysis Toolbox", " 10 Analysis Toolbox "],["Extract_toolset.html", "10.1 Extract Toolset", " 10.1 Extract Toolset 10.1.1 Clip Quite often in spatial analysis, we come across with cases, where we do not want to use all the available data there is. In other words, we want to focus on a specific area of interest, which dictates the need for clipping the existing dataset based on it’s relationship to some other existing spatial feature. In R this operation can be easily performed using the st_intersection function in sf. Let’s assume in the example below that we want to clip the available dataset of all the train stations in Switzerland by focusing our analysis on four specific cantons. ## Reading layer `Haltestelle_Bahn_CH&#39; from data source `/Users/runner/work/book/book/sample_data/other/Haltestelle_Bahn_CH.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 3134 features and 16 fields ## geometry type: POINT ## dimension: XYZ ## bbox: xmin: 2488908 ymin: 1076850 xmax: 2817389 ymax: 1289090 ## z_range: zmin: 194.905 zmax: 3453.525 ## projected CRS: CH1903+ / LV95 ## Reading layer `Kantonsgebiet&#39; from data source `/Users/runner/work/book/book/sample_data/other/Kantonsgebiet.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 56 features and 22 fields ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2485410 ymin: 1075268 xmax: 2833858 ymax: 1295934 ## z_range: zmin: 193.51 zmax: 4613.729 ## projected CRS: CH1903+ / LV95 As it was mentioned above, the aim is to analyse the situation at a particular area. So we are going to create an index with the specific cantons we are interested in. Plotting the result from the clipping operation So, ultimately, as we can see above, the st_intersection function creates a result where the point dataset is precisely “clipped” based on the area of interest The operation above produces the same outcome as the one depicted in the figure below 10.1. Figure 10.1: Clip operation in ArcGIS pro "],["Overlay_toolset.html", "10.2 Overlay Toolset", " 10.2 Overlay Toolset 10.2.1 Spatial Join Say you have two datasets: In R, the function used to join two datastes is st_join(x,y). If you have to different data types (e.g. Points and Polygons) the first question you have to ask yourself is: what data type should the output be? The datatype of x determins what the output datatype is. So with the above data: Say for each point, we want to know the Name (NAME) of the “Geimeinde” in which it lies. This means the output is a point dataset. We therefore write: Note that points not located in a Gemeinde get the value NA. You have to specify the spatial relationship of your join method within the argument join =. This argument take a so called spatial predicate function. From the join_methods available in ArcGIS, here’s the equivalant spatial predicate function: ArcGIS Term R Spatial Predicate Intersect st_intersect Intersect 3D (1) Within a distance st_is_within_distance Within a distance geodesic ?? Within a distance 3D (1) Contains st_contains Completely contains st_contains_properly? Contains clementini ?? Within st_within Completely within Within clementini ?? Are identical to st_equals? boundry touches st_touches Share a line segment Have their center in Closest st_nearest_feature? Closest geodesic ?? All binary predicates only work on 2D Objects (see this issue) "],["Proximity_toolset.html", "10.3 Proximity Toolset", " 10.3 Proximity Toolset 10.3.1 Buffer One of the most commonly used operations in ArcGIS pro is the one called Buffer. This operation provides a very convenient way of identifying areas of interest lying in the neighborhood of an existing spatial feature. In R the same action can be performed using the st_buffer function in sf. Below we introduce a line spatial feature that depicts all the mountain bike routes in Switzerland. ## Reading layer `mountainBikes_routes&#39; from data source `/Users/runner/work/book/book/sample_data/other/mountainBikes_routes.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 286 features and 29 fields ## geometry type: LINESTRING ## dimension: XYZ ## bbox: xmin: 2497570 ymin: 1077136 xmax: 2836678 ymax: 1296227 ## z_range: zmin: 197.367 zmax: 2860.725 ## projected CRS: CH1903+ / LV95 We focus, as an area of interest, on the canton of Valais. Consequently, we might be interested in identifying all the areas in a radius of 1000 m around these bike routes. Selecting the canton of Valais Apply a buffer of 1000m on each of the mountain bike routes within the canton of Valais The operation above produces the same outcome as the one depicted in the figure below ??. Figure 10.2: Buffer operation in ArcGIS pro "],["Spatial_Statistics.html", "11 Spatial Statistics Toolbox 11.1 Mapping Clusters Toolset 11.2 Measuring Geographic Distributions Toolset 11.3 Modeling Spatial Relationships Toolset 11.4 Utilities Toolset 11.5 Analyzing Patterns Toolset", " 11 Spatial Statistics Toolbox 11.1 Mapping Clusters Toolset 11.2 Measuring Geographic Distributions Toolset 11.3 Modeling Spatial Relationships Toolset 11.4 Utilities Toolset 11.5 Analyzing Patterns Toolset 11.5.1 Average Nearest Neighbor 11.5.2 High / Low Clustering 11.5.3 Incremental Spatial Atuocorrelation 11.5.4 Multi-Distance Spatial Cluster Analysis Ripley’s k-function 11.5.5 Spatial Autocorrelation (Global Morans I) 11.5.5.1 TL;DR - here’s the funciton to calculate Morans I 11.5.5.2 Let’s take this apart step by step "],["04_Topology_Rules.html", "12 About this section 12.1 Spatial Predicates 12.2 Some examples", " 12 About this section In ArcGIS, you create a topology rule by first creating a Feature Dataset in a Geodatabase, and then adding one or more Topology Rules to that Feature Dataset. You are provided with 32 different named rules which you can apply to this feature dataset (see 12.1). In R, you will find only the most commonly used 9 named spatial relations. These are known as “Spatial predicates”. 12.1 Spatial Predicates In Opensource GIS Applications, there is a common standard to describe various relationships between features. They are referred to as “Spatial predicates” and are defined as follows. Take two geometries, a and b: Equals: a and b are equal if their interiors intersect and no part of the interior or boundary of one geometry intersects the exterior of the other Disjoint: a and b are disjoint if they have no point in common (they form a set of disconnected geometries) Touches: a and b touch if they have at least one point in common but their interiors do not intersect Contains: a contains b if no points of b lie in the exterior of a and at least one point of the interior of b lies in the interior of a Covers: a covers b if at least one point of b lies in a, and no point of b lies in the exterior of a Intersects: a and b intersect if the two geometries have at least one point in common Within (inside): a is within b if a lies in the interior of the b CoveredBy: a is covered by b if a lies in b Crosses: a crosses b if they have some but not all interior points in common. Overlaps: a overlaps b if they have some (but not all) points in common and they have the same dimension and the intersection of the interiors of the two geometries has the same dimension as the geometries themselves Figure 12.1: The 32 different topolgy rules that you can apply to one or more feature datasets in ArcGIS In R, you can check topology using the DE-9IM together with st_relate(). 12.2 Some examples Let’s have a look at some examples from the named predicates as defined above. 12.2.1 Equals 12.2.2 Disjoint 12.2.3 Touches 12.2.4 Contains 12.2.5 Covers 12.2.6 Intersects 12.2.7 Within 12.2.8 CoveredBy 12.2.9 Crosses 12.2.10 Overlaps 12.2.11 Touches Lets take the example of a chessboard: To find out which field touch field number 36, we can write the following line of code: ## Sparse geometry binary predicate list of length 1, where the predicate was `touches&#39; ## 1: 27, 28, 29, 35, 37, 43, 44, 45 Visually, these are the following fields: 12.2.12 Custom relationships These named spatial predicates are all based on the Dimensionally Extended 9-Intersection Model (DE-9IM). Regarding the chessboard example above, we can imagine a chess piece placed on field #36. If this figure was a Queen or a King, all of the fields resulting from st_touches are reachable. In terms of contiguity, this is what is typically called the Queen’s or the King’s Case. However, this is might not the relationship that we are looking for: Say we would want to exclude the diagonal fields from our selection, the way a Rook would move in chess. How can we implement this in R? None of the named topological relationships above (12.1) correctly describes this case (touches_but_not_at_edges or shares_boundary would be appropriate). In this case, we can use the Dimensionally Extended 9-Intersection Model (DE-9IM) to precisely formulate the relationship we are looking for: the Rooks Case. IN DE-9IM, the intersection of two objects is viewed at three levels for each object: The Interior, the Boundary and the Exterior (\\(3^2= 9\\), hence the name). These levels mean different things for Polygons, Lines or Points, but let’s just look at the simple case for now, polygons (which is the case for our chess fields). Take the following example The interior of a polygon is the area inside the polygon. If the two areas overlap (as is the case of blue and red), the result from an intersection would also be a polygon. More formally: The Dimesion of \\(I(blue) \\cap I(red)\\) is an area. Areas get a value of 2, Lines 1 and points 0. If there is no intersection (as is the case in blue and green), the result equals to FALSE. This was the first of 9 Intersections. Let’s look at the next one: Interior of blue with the boundry of green: The resulting object has a dimenion “line,” i.e. 1. Formally: \\(dim(I(blue) \\cap B(red)) = 1\\). Now just for the sake of looking at the third level (Exerior), let’s look at what this looks like: The resulting object is again an area, i.e. 2. Formally \\(dim(I(blue) \\cap E(red)) = 2\\). If we go through all intersections of Interior, boundry and Exterior of both geometries, we can denote for each comination what type of dimesion we “allow.” This can be either 0 (for points), 1 (for lines) or 3 (for areas) or TRUE (for either of these), or FALSE (for none of these) or * (for \"I dont care). 12.2.13 Rooks Case If we go throught the all nine combinations of the DE-9IM, this is what defines the rooks case: Interior Boundary Exterior Interior nothing don’t care don’t care Boundary don’t care Line don’t care Exterior don’t care don’t care don’t care We can now write this into a string, starting from the top left: F1* Now that we have this string, we case use st_relate()and specify the string as the pattern we are looking for: ## Sparse geometry binary predicate list of length 1, where the predicate was `relate_pattern&#39; ## 1: 28, 35, 37, 44 Which visually gives us this pattern: Because this was so much fun, let’s also have a look at the opposite, the Bishops Case. 12.2.14 Bishops Case Interior Boundary Exterior Interior nothing don’t care don’t care Boundary don’t care Point don’t care Exterior don’t care don’t care don’t care ## Sparse geometry binary predicate list of length 1, where the predicate was `relate_pattern&#39; ## 1: 27, 29, 43, 45 Visually: "],["Polygon.html", "13 Polygon 13.1 Must not overlap 13.2 Must not have gaps 13.3 Contains point 13.4 Contains one Point 13.5 Must be covered by feature class of 13.6 Boundary must be covered by 13.7 Must not overlap with 13.8 Must be covered by 13.9 Area boundary must be covered by boundary of 13.10 Must cover each other", " 13 Polygon 13.1 Must not overlap Figure 13.1: Source: Esri (2011) In context of DE-9IM, this is a simple case. The polygon interiors should not overlap at all, everything else does not matter. Interior-Interior is the first of the 9 intersections, so the the intersection matrix as a code string would be: 2********. In the case of the example below: set.seed(10) nrows &lt;- 10 circs &lt;- data.frame( id = 1:nrows, x = rnorm(nrows), y = rnorm(nrows) ) %&gt;% st_as_sf(coords = c(2,3)) %&gt;% st_buffer(0.25) circsplot &lt;- ggplot(circs) + geom_sf(fill = &quot;blue&quot;,alpha = 0.3) + geom_sf_text(aes(label = id)) + theme_void() circsplot This gives us a sparse matrix as an output, which is esentially a list with the same length as the x, where each position is a vector of integers with the indicies of the features in y (which may equal to x) where the pattern matches. st_relate(circs,pattern = &quot;2********&quot;) ## Sparse geometry binary predicate list of length 10, where the predicate was `relate_pattern&#39; ## 1: 1, 2, 5 ## 2: 1, 2, 4, 5, 10 ## 3: 3 ## 4: 2, 4 ## 5: 1, 2, 5 ## 6: 6 ## 7: 7 ## 8: 8 ## 9: 9 ## 10: 2, 10 Setting sparse = FALSE returns a crossmatrix of all combinations.W crossmatrix &lt;- st_relate(circs,pattern = &quot;2********&quot;,sparse = FALSE) crossmatrix[1:6,1:6] # only showing 6 since this prints nicely ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] TRUE TRUE FALSE FALSE TRUE FALSE ## [2,] TRUE TRUE FALSE TRUE TRUE FALSE ## [3,] FALSE FALSE TRUE FALSE FALSE FALSE ## [4,] FALSE TRUE FALSE TRUE FALSE FALSE ## [5,] TRUE TRUE FALSE FALSE TRUE FALSE ## [6,] FALSE FALSE FALSE FALSE FALSE TRUE # Remove the diagonals since it&#39;s simply each feature tested against itself diag(crossmatrix) &lt;- FALSE error &lt;- which(crossmatrix,arr.ind = TRUE) %&gt;% as.vector() %&gt;% unique() circsplot + geom_sf(data = circs[error,], fill = &quot;red&quot;, alpha = 0.3) 13.2 Must not have gaps Figure 13.2: Source: Esri (2011) Lets cosider the North Carolina Dataset for this question. nc = st_read(system.file(&quot;shape/nc.shp&quot;, package=&quot;sf&quot;), quiet = TRUE) ggplot(nc) + geom_sf() + theme_void() The first task is to dissolve all adjecent polygons together nc_union &lt;- st_union(nc) nc_union ## Geometry set for 1 feature ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 ## geographic CRS: NAD27 If the output is a multipolygon as it is the case here, it’s bad news, there are gaps. To check which parts are disconnected from each other, we can cast the multipolygon to a polygon (in ArcGIS Terms “Multipart to singlepart”), add a rowname for each part and colour it by rowname. nc_singlepart &lt;- nc_union %&gt;% st_cast(&quot;POLYGON&quot;)%&gt;% st_sf() %&gt;% mutate(id = 1:n()) ggplot(nc_singlepart) + geom_sf(aes(fill = factor(id))) + labs(fill = &quot;id&quot;) + theme_void() But maybe we can live with these Islands in the state of North Carolina, since this is in fact an accurate representation of reality (the gaps are a result of the Atlantic Ocean). We must now check whether the individual geometries have holes. Here we can make use of the way polygons are defined in sf: geometry with a positive area (two-dimensional); sequence of points form a closed, non-self intersecting ring; the first ring denotes the exterior ring, zero or more subsequent rings denote holes in this exterior ring This means that the length of each Polygon geometry must be 1. A length of 2 or more would mean that there are one (or more) holes in the geometry. We can do this with any of the functions from the apply family, I prefer purrr: map_lgl(nc_singlepart$geometry,~length(.x)== 1) ## [1] TRUE TRUE TRUE TRUE TRUE TRUE Let’s see what happens if we cut a hole into the polygons holes &lt;- nc_singlepart %&gt;% st_union() %&gt;% st_centroid() %&gt;% st_buffer(0.5) nc_holes &lt;- st_difference(nc_singlepart,holes) ggplot(nc_holes) + geom_sf() + theme_void() map_lgl(nc_holes$geometry,~length(.x)== 1) ## [1] FALSE TRUE TRUE TRUE TRUE TRUE 13.3 Contains point Figure 13.3: Source: Esri (2011) 13.4 Contains one Point Figure 13.4: Source: Esri (2011) 13.5 Must be covered by feature class of Figure 13.5: Source: Esri (2011) 13.6 Boundary must be covered by Figure 13.6: Source: Esri (2011) 13.7 Must not overlap with Figure 13.7: Source: Esri (2011) 13.8 Must be covered by Figure 13.8: Source: Esri (2011) 13.9 Area boundary must be covered by boundary of Figure 13.9: Source: Esri (2011) 13.10 Must cover each other Figure 13.10: Source: Esri (2011) "],["Line.html", "14 Line 14.1 Must not have pseudo nodes 14.2 Must not have dangles 14.3 Must not self overlap 14.4 Must not overlap 14.5 Must not self-intersect 14.6 Must not intersect 14.7 Must be single part 14.8 Must not intersect with 14.9 Must be covered by feature class of 14.10 Must not intersect or touch interior 14.11 Must be covered by boundary of 14.12 Must not intersect or touch interior with 14.13 Must be properly inside 14.14 Must not overlap with 14.15 Endpoint must be covered by", " 14 Line 14.1 Must not have pseudo nodes Figure 14.1: Source: Esri (2011) 14.2 Must not have dangles Figure 14.2: Source: Esri (2011) 14.3 Must not self overlap Figure 14.3: Source: Esri (2011) 14.4 Must not overlap Figure 14.4: Source: Esri (2011) 14.5 Must not self-intersect Figure 14.5: Source: Esri (2011) 14.6 Must not intersect Figure 14.6: Source: Esri (2011) 14.7 Must be single part Figure 14.7: Source: Esri (2011) 14.8 Must not intersect with Figure 14.8: Source: Esri (2011) 14.9 Must be covered by feature class of Figure 14.9: Source: Esri (2011) 14.10 Must not intersect or touch interior Figure 14.10: Source: Esri (2011) 14.11 Must be covered by boundary of Figure 14.11: Source: Esri (2011) 14.12 Must not intersect or touch interior with Figure 14.12: Source: Esri (2011) 14.13 Must be properly inside Figure 14.13: Source: Esri (2011) 14.14 Must not overlap with Figure 14.14: Source: Esri (2011) 14.15 Endpoint must be covered by Figure 14.15: Source: Esri (2011) "],["Point.html", "15 Point 15.1 Must coincide with 15.2 Must be disjoint 15.3 Must be covered by endpoint of 15.4 Point must be covered by line 15.5 Must be properly inside 15.6 Must be covered by boundary of", " 15 Point 15.1 Must coincide with Figure 15.1: Source: Esri (2011) 15.2 Must be disjoint Figure 15.2: Source: Esri (2011) 15.3 Must be covered by endpoint of Figure 15.3: Source: Esri (2011) 15.4 Point must be covered by line Figure 15.4: Source: Esri (2011) 15.5 Must be properly inside Figure 15.5: Source: Esri (2011) 15.6 Must be covered by boundary of Figure 15.6: Source: Esri (2011) "],["Line_or_Polygon.html", "16 Line or Polygon 16.1 Must be larger than cluster tolarance", " 16 Line or Polygon 16.1 Must be larger than cluster tolarance Figure 16.1: Source: Esri (2011) "],["bibliography.html", "References", " References Allaire, J. J., Christopher Gandrud, Kenton Russell, and CJ Yetman. 2017. networkD3: D3 JavaScript Network Graphs from r. https://CRAN.R-project.org/package=networkD3. Allaire, JJ, Yihui Xie, Jonathan McPherson, Javier Luraschi, Kevin Ushey, Aron Atkins, Hadley Wickham, Joe Cheng, Winston Chang, and Richard Iannone. 2020. Rmarkdown: Dynamic Documents for r. https://github.com/rstudio/rmarkdown. Appelhans, Tim, Florian Detsch, Christoph Reudenbach, and Stefan Woellauer. 2020. Mapview: Interactive Viewing of Spatial Data in r. https://github.com/r-spatial/mapview. Bivand, Roger, Tim Keitt, and Barry Rowlingson. 2021. Rgdal: Bindings for the Geospatial Data Abstraction Library. https://CRAN.R-project.org/package=rgdal. Esri. 2011. ArcGIS Geodatabase Topology Rules. https://pro.arcgis.com/en/pro-app/latest/help/editing/pdf/topology_rules_poster.pdf. Glur, Christoph. 2020. Data.tree: General Purpose Hierarchical Data Structure. http://github.com/gluc/data.tree. GrÃ¤ler, Benedikt, Edzer Pebesma, and Gerard Heuvelink. 2016. “Spatio-Temporal Interpolation Using Gstat.” The R Journal 8: 204–18. https://journal.r-project.org/archive/2016/RJ-2016-014/index.html. Hijmans, Robert J. 2020. Raster: Geographic Data Analysis and Modeling. https://rspatial.org/raster. ———. 2021. Terra: Spatial Data Analysis. https://rspatial.org/terra. Lovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2021. Geocomputation with r. CRC Press. https://geocompr.robinlovelace.net. Ooms, Jeroen, and Jim Hester. 2020. Spelling: Tools for Spell Checking in r. https://CRAN.R-project.org/package=spelling. Pebesma, Edzer. 2018. “Simple Features for R: Standardized Support for Spatial Vector Data.” The R Journal 10 (1): 439–46. https://doi.org/10.32614/RJ-2018-009. ———. 2021a. Sf: Simple Features for r. https://CRAN.R-project.org/package=sf. ———. 2021b. Stars: Spatiotemporal Arrays, Raster and Vector Data Cubes. https://CRAN.R-project.org/package=stars. Pebesma, Edzer J. 2004. “Multivariable Geostatistics in S: The Gstat Package.” Computers &amp; Geosciences 30: 683–91. Pebesma, Edzer, and Benedikt Graeler. 2020. Gstat: Spatial and Spatio-Temporal Geostatistical Modelling, Prediction and Simulation. https://github.com/r-spatial/gstat/. Tennekes, Martijn. 2018. “tmap: Thematic Maps in R.” Journal of Statistical Software 84 (6): 1–39. https://doi.org/10.18637/jss.v084.i06. ———. 2021. Tmap: Thematic Maps. https://github.com/mtennekes/tmap. Urbanek, Simon. 2020. Tiff: Read and Write TIFF Images. http://www.rforge.net/tiff/. Wickham, Hadley. 2019. Tidyverse: Easily Install and Load the Tidyverse. https://CRAN.R-project.org/package=tidyverse. Wickham, Hadley, Mara Averick, Jennifer Bryan, Winston Chang, Lucy D’Agostino McGowan, Romain FranÃ§ois, Garrett Grolemund, et al. 2019. “Welcome to the tidyverse.” Journal of Open Source Software 4 (43): 1686. https://doi.org/10.21105/joss.01686. Xie, Yihui. 2016. Bookdown: Authoring Books and Technical Documents with R Markdown. Boca Raton, Florida: Chapman; Hall/CRC. https://github.com/rstudio/bookdown. ———. 2020. Bookdown: Authoring Books and Technical Documents with r Markdown. https://github.com/rstudio/bookdown. Xie, Yihui, J. J. Allaire, and Garrett Grolemund. 2018. R Markdown: The Definitive Guide. Boca Raton, Florida: Chapman; Hall/CRC. https://bookdown.org/yihui/rmarkdown. Xie, Yihui, Christophe Dervieux, and Emily Riederer. 2020. R Markdown Cookbook. Boca Raton, Florida: Chapman; Hall/CRC. https://bookdown.org/yihui/rmarkdown-cookbook. "]]
