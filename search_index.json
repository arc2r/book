[["index.html", "All things R Spatial arc2r: An introduction to spatial-R for recovering ArcGIS users 1 Welcome! 1.1 What this book is about 1.2 How it started", " All things R Spatial arc2r: An introduction to spatial-R for recovering ArcGIS users Nils Ratnaweera and Nikolaos Bakogiannis 24 February, 2021 1 Welcome! 1.1 What this book is about This is a resource for people wanting to learn spatial-R (Analysis, Visualization) in R and are coming with a background in ArcGIS. This resource should provide some help on this journey. To make use of this ressource, we assume two things: (1) that you have some prior experience with R and (2) that you have experience with Geodata and GIS-Concepts. This book leans heavily on how the Toolboxes and Toolsets are organized in ArcGIS Pro. The idea is that you can look up specific things of which you only know the ArcGIS terminology for. This book is a work in progress, and we highly appreciate contributions to this book: If you have anything to add, please file an issue or make a pull request. We are big fans of using magrittr’s pipe function %&gt;% and heavily use it throughout this book. In addition for vector data, we use packages from the tidyverse (especially from the dplyr package: filter(), mutate() and summarise()). 1.2 How it started We had long since thought about the necessity of a resource which helps ArcGIS users transition to R or Python. Nils had tweeted about this (see below) without getting much reception, and one point just decided to start his own resource. Since our research group teaches an introduction to GIS and an advanced GIS course mostly based on ArcGIS, we decided to pick up where Nils had started and develop the resource with internal funding of our University. Figure 1.1: Nils’ Tweet might not have received much attention, but it did spark a conversation within our group "],["setting_up.html", "2 How to use this book Step 1: Installing R and RStudio Step 2: Install the accompanying package arc2r Step 3: Create a new project (RStudio only)", " 2 How to use this book The tutorials in this book are designed in a way for you to follow along easily. Just follow the following steps Step 1: Installing R and RStudio To follow along, you will need a fairly new version of R an IDE to work with. We recommend (and use) RStudio ourselves, but you are free to use your preferred software. You can install R and Rstudio locally (which we recommend) or you can get going quickly with an online version of RStudio: If you are a Student or Teacher at ZHAW, you can request access to our RStudio Server located at rstudio-ide.zhaw.ch (just write a mail to Nils, rata@zhaw.ch). Alternatively, you can create a RStudio Cloud account and start working there: rstudio.cloud. Step 2: Install the accompanying package arc2r This book has an accompanying package that will provide you with all the necessary datasets. Plus, installing this package in the right way (dependencies = TRUE) will also provide you with all the necessary packages, so you don’t have to install them manually. Since the package is hosted on github and is not available on CRAN, you cannot install it the usual way (install.packages(\"arc2r\")). Instead, you will have to install it using the remotes packages, which is on CRAN. This package will provide you with a function named install_github(), which allows installing packages from github. Note: Since the package contains all the datasets, this might take a while. You might get promted to upgrade your R packages: We recommend you do so. If you are afraid of messing up dependencies in other projects, cosider working with renv. install.packages(&quot;remotes&quot;) remotes::install_github(&quot;arc2r/arc2r&quot;,dependencies = TRUE) Step 3: Create a new project (RStudio only) If you are working with RStudio, you can make use of the RMarkdown Template that we provide you with the data package you installed in step 2. To use these, restart RStudio and create a new project (File &gt; New Project). Choose “New Directory” and in the next window, click on the the template we created for following along (see figure 2.1). Figure 2.1: To use the templates, click on ‘Create project’ and then on ‘arc2r: all things R Spatial’ "],["10_Getting_Started.html", "About this section", " About this section This section will cover some general concepts to be aware of when switching from ArcGIS to R. This is a (non exhaustive) list of the main differences we see between the two approaches: The fundamental building block of ArcGIS is a visual representation of your data (i.e. the map). The fundamental building block in R is your R-Script. The visual aspect makes ArcGIS more approachable, but also less scalable. When you acquire ArcGIS, you are served from a single source. In R, there are a plethora of developers creating packages for you to use, which can be quite overwhelming While there are always multiple ways to solve a problem in ArcGIS, there are usually many more ways to solve it in R. Finding the right way is not always easy. When you transition from a proprietary Software like ArcGIS to FOSS, you have to relearn many of the concepts because the proprietary software usually do not adhere to common standards. ArcGIS follows the concept of creating a tool for every situation you might encounter. With this approach, they provide a selection of &gt; 1’000 geoprocessing tools to your disposal. Generally speaking, the authors of Packages will try to keep the number of functions as small as possible, since this reduces maintenance. And just to get this out of the way: When is ArcGIS (or QGIS for that matter) preferable to using R? We will just cite Sébastien Rochette’s tweet I would use QGIS for georeferencering and digitizing. - Georeferencing is when you get an aerial photo or an old paper map that you want to add in GIS - Digitizing is when you want to manually draw areas that you see on a digitized map Also, the reason I use to keep a QGIS installed, is to get the list of all projections and being able to search through the list to find the appropriate projection in case of problems with yours. Also, with {raster}, where you need to use the PROJ4 string, QGIS gives it to you. "],["Data.html", "3 Data Handling (I/O)", " 3 Data Handling (I/O) As an ArcGIS user, you are probably very familiar with the two major geodata formats, raster data and vector data. shapefiles and geodatabases with feature classes are most commonly used for vector data in the ESRI World. For raster data, geotiffs and ESRI GRID files inside geodatabases are used very frequently. As you work with OpenSource GIS Tools and Data, you will come across a much richer ecosystem of data formats (which can be a blessing and a curse!). In ArcGIS, you add a new dataset to your project using the “Add Data” button in the “Map” Pane. ArcGIS then “helps” you in various ways that R will not. For example, ArcGIS: … only displays files with extensions that are typically associated with geodata (e.g. .tif, .shp etc) … automatically bundles multifile-datasets (files that are composed of different with a common prefix, e.g. shapefiles1) and displays it as a single dataset … let’s you interactively browse the content of File-Geodatabases (*.gdb-Files) … displays the datatype / geometrytype of a dataset as a little icon … automatically uses the correct mechanisms to import a dataset2 R provides less help when importing a dataset which can be seen as a disadvantage, but in many cases is more preferable. R interferes less and assumes an informed user who has good knowledge of the data. Just like when importing datasets using read.csv, read.delim and so on, you need to prior knowledge of your data to import it correctly: You need to know the delimiter used to separate columns, and the encoding used to store the information. The same holds true when importing geodata in R: depending on the type of geodata, we need different packages to handle the data and different functions to import it. For handling vector data, the package sf now has replaced its predecessor sp. sf is so powerful and simple, that it has helped bring GIS workflows to non-GIS R users. For handling raster data, the package raster is still in heavy use but is in the process of being replaced by it’s successor, terra. shapefiles consist of at least 3 files (*.shp, *.dbf and *.shx)↩︎ so you don’t have to care whether it is raster, vector, multiband or singleband format↩︎ "],["import_vector.html", "3.1 Importing vector data with sf", " 3.1 Importing vector data with sf Most vector data that you use in everyday GIS work are so called “simple features.” Simple features are an open standard developed by the Open Geospatial Consortium (OGC). The most common feature types are displayed in figure 3.1. Figure 3.1: The 7 (of 17) most important simple feature types. Image from Lovelace, Nowosad, and Muenchow (2021) To handle these simple features in R, we need the library sf, and to import a vector dataset into R, we can use the function read_sf as in the example below. library(sf) ## Linking to GEOS 3.8.1, GDAL 3.1.4, PROJ 6.3.1 ARE_waedenswil &lt;- read_sf(&quot;sample_data/ARE_waedenswil.shp&quot;) ARE_waedenswil ## Simple feature collection with 13 features and 5 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 2689594 ymin: 1228563 xmax: 2694829 ymax: 1234095 ## projected CRS: CH1903+ / LV95 ## # A tibble: 13 x 6 ## ID KLASSE KLASSE_DE KLASSE_FR KLASSE_NUM geometry ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;MULTIPOLYGON [m]&gt; ## 1 69 D D - gering… D - faible… 4 (((2692378 1233048, 2692373 … ## 2 1371 D D - gering… D - faible… 4 (((2689720 1232195, 2689767 … ## 3 3578 D D - gering… D - faible… 4 (((2692766 1232135, 2692690 … ## 4 3591 D D - gering… D - faible… 4 (((2691861 1232707, 2691907 … ## 5 3696 A A - sehr g… A - très b… 1 (((2693943 1231286, 2693834 … ## 6 3901 B B - gute E… B - bonne … 2 (((2693183 1231097, 2693113 … ## 7 4137 B B - gute E… B - bonne … 2 (((2690970 1232339, 2690947 … ## 8 4161 B B - gute E… B - bonne … 2 (((2691724 1232478, 2691701 … ## 9 4225 B B - gute E… B - bonne … 2 (((2692266 1232198, 2692243 … ## 10 4401 C C - mittel… C - desser… 3 (((2694681 1230763, 2694659 … ## 11 5208 C C - mittel… C - desser… 3 (((2693064 1229206, 2693041 … ## 12 5319 C C - mittel… C - desser… 3 (((2690879 1233702, 2690856 … ## 13 5514 C C - mittel… C - desser… 3 (((2693168 1229907, 2693145 … And you are done! The shapefile is now imported into your R Session and you can start working with it. Much of the beauty in sf comes from it’s simplicity: As you see from importing the shapefile, it is very much like a data.frame, a structure that you probably know very well. In fact, it is a data.frame, as you can see here: is.data.frame(ARE_waedenswil) ## [1] TRUE sf provides methods for various generics, e.g. you can use plot() on the object for a simple visualisation. By default, using plot() on an sf object visualizes the geometry in small multiples, where each “facet” is colour coded based on a column in the dataset (see below). If you find this annoying (like I do), see chapter 4.1. plot(ARE_waedenswil) "],["import_raster_raster.html", "3.2 Importing raster data with raster", " 3.2 Importing raster data with raster For this chapter, you will need the following R Packages: library(raster) ## Loading required package: sp To import raster data, we need a package that can specifically handle raster datasets. The package raster has for a long time been the go-to package for this. However, this package is currently in the process of being replaced with a successor, terra. Since raster is still in heavy use, we will show you how you handle raster data with this package. 3.2.1 Single band raster Download the sample dataset here and unzip it into your project folder. This dataset is a freely available sample for the swissALTI3D data. The full sample, including files at different resolutions, can be downloaded from here. Now load the library raster the function raster to import the tif-file included in the zip file. Make sure you have set the path to your tif-file correctly. library(raster) swissAlti3D &lt;- raster(&quot;sample_data/SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196.tif&quot;) ## Warning in showSRID(uprojargs, format = &quot;PROJ&quot;, multiline = &quot;NO&quot;, prefer_proj ## = prefer_proj): Discarded datum Unknown based on Bessel 1841 ellipsoid in Proj4 ## definition The dataset is now imported into your project and ready to be viewed, analysed and processed. If we call the object in our console, we can see that the dataset was imported as a RasterLayer and can see some important statistics which you would typically find via Layer Properties -&gt; Source in ArcGIS. swissAlti3D ## class : RasterLayer ## dimensions : 100, 100, 10000 (nrow, ncol, ncell) ## resolution : 10, 10 (x, y) ## extent : 2600000, 2601000, 1196000, 1197000 (xmin, xmax, ymin, ymax) ## crs : +proj=somerc +lat_0=46.9524055555556 +lon_0=7.43958333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +units=m +no_defs ## source : /Users/runner/work/book/book/sample_data/SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196.tif ## names : SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196 ## values : 623.3814, 858.2705 (min, max) To visualize the dataset, we can simply call plot on our new object. plot(swissAlti3D) 3.2.2 Multiband Raster //todo explain how to import multiband raster "],["import_raster_terra.html", "3.3 Importing raster data with terra", " 3.3 Importing raster data with terra For this chapter, you will need the following R Packages: ## terra version 1.0.10 ## ## Attaching package: &#39;arc2r&#39; ## The following object is masked _by_ &#39;.GlobalEnv&#39;: ## ## swissAlti3D With the terra package, data is imported using the function rast. library(terra) swissalti3d &lt;- terra::rast(&quot;sample_data/SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196.tif&quot;) Just like before, calling the object in our console will give us the class name and some meta information on the dataset. swissalti3d ## class : SpatRaster ## dimensions : 100, 100, 1 (nrow, ncol, nlyr) ## resolution : 10, 10 (x, y) ## extent : 2600000, 2601000, 1196000, 1197000 (xmin, xmax, ymin, ymax) ## coord. ref. : +proj=somerc +lat_0=46.9524055555556 +lon_0=7.43958333333333 +k_0=1 +x_0=2600000 +y_0=1200000 +ellps=bessel +towgs84=674.374,15.056,405.346,0,0,0,0 +units=m +no_defs ## source : SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196.tif ## name : SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196 ## min value : 623.3814 ## max value : 858.2705 And calling plot on our object visualizes it spatially. plot(swissalti3d) //todo add method for rasters with multiple layers "],["Making_Maps.html", "4 Making Maps", " 4 Making Maps In ArcGIS, the fundamental approach to working with data is through a visual interface. The first thing that happens when you import a dataset into an ArcGIS project is that you get an interactive map visualizing that data. In R on the other hand, when you import a dataset into your project you have only created a connection to that dataset, and may it will be read into your computer’s memory. To visualize your data (which you should do frequently), you need an extra step. This difference between R and ArcGIS is probably what makes ArcGIS so approachable and R so intimidating for beginners. But making a quick visualisation of your geodata is very easy in R, it sometimes just takes a simple line of code. In R, we have to differentiate two different types of outputs: Static maps which can be printed on paper and dynamic maps which you can interact with. Static maps are usually stored in JPG, Tiff of PDF Format which dynamic maps are rendered using html, and javascript. In the beginning, you don’t have to worry about these formats because RStudio automatically displays the maps in the correct pane (“Plot” for static maps and “Viewer” for dynamic maps). A dynamic map is what you get “for free” in ArcGIS within your “Map Window,” a Static map is what you would get when you export a “Layout” to jpg or pdf to use in a report. Prerequisite: Before you start making maps, you will have to familiarize yourself with importing raster or vector data into R. Read chapter 3 to get up to speed. "],["Static_Maps.html", "4.1 Static Maps", " 4.1 Static Maps For this chapter, you will need the following packages and datasets: library(arc2r) library(sf) library(raster) library(ggplot2) data(&quot;gemeindegrenzen_zh&quot;) data(&quot;swissAlti3D&quot;) As we saw in chapter 3.1, we can quickly visualize an sf object by simply calling plot. This will return a small multiple of your geodata, where each facet is colour coded based on a column. plot(gemeindegrenzen_zh) You will get one facet for each column, where the maximum number of facets is set to 9 by default. I find this behaviour pretty annoying, since I usually just want get a quick look at the data in space, and these small multiples take ages to render. There are several workarounds to prevent small multiples: Extract the geometry from the sf object and just plot that Specify the column which should colourcode your data Specify max.plot = 1 to just plot 1 facet (using the first column in your dataset for colour coding) Set the option sf_max.plot to 1 with Option(sf_max.plot = 1) (this will persist throughout your R Session) plot(st_geometry(gemeindegrenzen_zh)) # 1 plot(gemeindegrenzen_zh[&quot;BEZIRKSNAME&quot;]) # 2 plot(gemeindegrenzen_zh, max.plot = 1) # 3 options(sf_max.plot = 1) # 4 plot(gemeindegrenzen_zh) We dont have the “problem” of facets with raster data, so we can simply call plot() on a raster object to visualize it. plot(swissAlti3D) The plot() method is fine for quick view of the data, but as you want to add more layers, legend etc. plot() becomes complicated. There are many alternative methods to visualizing spatial data, we will showcase our favourite methods here. 4.1.1 Package ggplot2 If you are familiar with ggplot2 you can rejoice: Plotting sf objects has become very easy with this package. If you do not know this package yet, we recommend you familiarize yourself with it first before diving into this chapter. We will continue to work with the datasets used above 4.1.1.1 sf objects ggplot(gemeindegrenzen_zh) + geom_sf() In its most basic form, we can visualize the geometry of our sf object. As always in ggplot2, if you want to use a column from your dataset as an input for, say, colour, you need to specify this with aes(): ggplot(gemeindegrenzen_zh) + geom_sf(aes(fill = BEZIRKSNAME)) To change the default graticules from WGS84 to a custom Coordinate System, we can use the argument datum in coord_sf and call the EPSG Code of our desired coordinate system. ggplot(gemeindegrenzen_zh) + geom_sf(aes(fill = BEZIRKSNAME)) + coord_sf(datum = 2056) How we can use our standard ggplot2 methods to polish this plot: ggplot(gemeindegrenzen_zh) + geom_sf(aes(fill = BEZIRKSNAME), colour = &quot;white&quot;) + labs(title = &quot;Gemeinden des Kantons Zürich nach Bezirk&quot;,fill = &quot;&quot;) + theme_void() + theme(legend.position = &quot;bottom&quot;) 4.1.1.2 raster objects While sf objects are very easily integrated in ggplot2, raster data is a little harder. There are various ways to plot a raster object with ggplot2. A simple, adhoc approach is converting the RasterLayer object into a data.frame and then plotting it with geom_raster. swissAlti3D_df &lt;- as.data.frame(swissAlti3D,xy = TRUE) # xy = TRUE adds the x and y coordinates to our dataframe as columns ggplot(swissAlti3D_df, aes(x, y, fill = SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196)) + geom_raster() Note that this approach, ggplot is not aware of the coordinate system assigned to our dataset. The x and y coordinates from our dataframe are assumed to be in a cartesian coordinate system. This implies two things: This approach only works with datasets in a projected coordinate system (where the raster is assumed to be on a plane) We have to specify that the coordinate system in the two direction are equal with cord_equal() (coord_sf() will not work if we don’t have any sf objects) //todo add example of WGS84 raster ggplot(swissAlti3D_df, aes(x, y, fill = SWISSALTI3D_10_TIFF_CHLV95_LN02_2600_1196)) + geom_raster() + scale_fill_viridis_c() + theme_void() + coord_equal() + theme(legend.position = &quot;bottom&quot;) 4.1.2 Package tmap While ggplot2 was extended to work with spatial data, the package tmap was specifically designed to create maps. The developer created this package leaning on the “grammar of graphics” approach which is also implemented in ggplot2, so many of the concepts are the same (e.g. the concept of “layers” and using the +-sign). One main difference is that tmap does not use NSE, so column names always need to be quoted. library(tmap) tmap_mode(&quot;plot&quot;) # &lt;- to create static plots ## tmap mode set to plotting tm_shape(gemeindegrenzen_zh) + tm_polygons(col = &quot;BEZIRKSNAME&quot;)+ tm_layout(legend.position = c(&quot;right&quot;,&quot;top&quot;)) The fact that tmap is designed for maps makes it much easier to add map elements, such as a North Arrow. tm_shape(gemeindegrenzen_zh) + tm_polygons(col = &quot;BEZIRKSNAME&quot;)+ tm_layout(legend.position = c(&quot;right&quot;,&quot;bottom&quot;)) + tm_compass() It also means that visualizing a RasterLayer is built in to the package: tm_shape(swissAlti3D) + tm_raster() The most amazing thing about tmap probably is tmap_mode(\"view\"). Run this code and then the two chunks above, you will be amazed. Learn more about this in chapter Interactive Maps. "],["Dynamic_Maps.html", "4.2 Interactive Maps", " 4.2 Interactive Maps As introduced in chapter Making Maps, an interactive Map is the fundamental building block of ArcGIS. In R, we need to do some extra work to create such an interactive map, but this extra work sometimes means just one line of code. There are multiple packages that simplify creating maps: leaflet mapview tmap plotly mapview and tmap both build on the package leaflet, which in turn builds on leaflet, an open source JavaScript Library for interactive maps. There really is not much need to learn leaflet, since using mapview or tmap is much simpler. The package plotly builds on plotly, a very versatile graphics library that provides an API for R, Python and Julia. It is an amazing tool, but we will focus more on mapview and tmap. 4.2.1 Package mapview The package mapview is highly automated and you get a very decent map when calling the function mapview::mapview on your geodata, without any additional arguments. The aim of the package is to be quick and easy, as emphasized in the documentation: It’s main goal is to fill the gap of quick […] interactive plotting to examine and visually investigate both aspects of spatial data, the geometries and their attributes. library(arc2r) library(sf) library(raster) library(mapview) ## GDAL version &gt;= 3.1.0 | setting mapviewOptions(fgb = TRUE) This next line of code generates a representation of your data (in this case, gemeindegrenzen_zh), much like the default map in ArcGIS. mapview(gemeindegrenzen_zh) If the emphasis lies on creating a highly customized map, then tmap may be more appropriate. 4.2.2 Package tmap Like mentioned in the previous chapter, the package tmap facilitates creating highly customized maps. But the greatest strength in tmap comes from it’s versatility: All you need to do is specify how you want your data to be displayed, and tmap can render this into an interactive map of a static one that you can print. All you need to do is change the mode within the function tmap_mode() to view. library(tmap) tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing As shown in chapter ??, the tmap syntax very similar to ggplot2s, in the sense that connect “layers” using a + sign. tm_shape(gemeindegrenzen_zh) + tm_polygons() This interactive map is very similar to the one generated by mapview, which is not surprising since they are both built on top of leaflet. 4.2.3 Further ressources For more information on tmap, check out the package’s gihub site: https://github.com/mtennekes/tmap For more information on interactive maps in general, head over to the great book “Geocomputation with R”: https://geocompr.robinlovelace.net/adv-map.html#interactive-maps "],["Select.html", "5 Selection", " 5 Selection A very commonly used tool in ArcGIS is the concept of “Selection.” The idea is, that you select features from your vector dataset in one of the following three ways: Select: Interactively by clicking in your map Select By Attributes: By specifying (non-spatial) criteria based on the attribute table Select By Location: By specifying spatial criteria based on the relationship to another dataset. Figure 5.1: A very commonly used tool: The selection tools from the ArcGIS Pro Map Pane Using the tools via these buttons 5.1 have two effects. The selected features are highlighted visually Any operation performed with a dataset that has an active selection respects this selection. In other words, the operation is only performed on the selected features. This second effect is cause for many confusing errors, either because the user forgot that a selection was active or the there were zero elements matching the specified criteria and so the operation was performed on an empty dataset. For this reason, this type of “floating selection” is not very useful and was never implemented in R. However, two of the three described methods to select data are supported in R, but with a different approach. The selected data leaves the original data unchanged, but must assigned to a new R object3. Interactive selection (button “Select” in 5.1 is a priori not reproducible and therefore not supported in R. By the way: In the world of SQL this type of operation is not called “selection” but “filtering.” Consequently, that is also the name used in R. In R as well as SQL, a select is done on columns in a dataset, not on rows (i.e. if you want to retain only a subset of the columns in a dataset). or, if you are familiar with pipes, piped into a new operation↩︎ "],["Select_by_Attribute.html", "5.1 Select by Attribute", " 5.1 Select by Attribute One of the popular approaches in ArcGIS pro for selecting features in a layer is by using an attribute query. The action is performed using the Select By Attributes tool. Select By Attributes tool allows us to provide an SQL query expression to select features that match the selection criteria. R on the other hand offers quite easy and straightforward options to perform similar operations. Let’s examine one of them. As a first step, we might want to import a shapefile. To do so, we can use sf package to work with vector data in R. Important to know is that the rgdal package automatically loads when sf is loaded. In the code snippet below, we read the shapefile, which represents the parking spots for bicycles within the canton of Zurich. The dataset is publicly available for download in the following link: (https://opendata.swiss/en/dataset/veloparkierungsanlagen). library(sf) library(ggplot2) data(&quot;veloparkierungsanlagen_zh&quot;) After importing the dataset, let’s say we want to filter it by selecting only the parking spots that lie within a specific municipality (Gemeinde) in the canton of Zurich. More specifically, we will select only the parking spots within the municipality of Winterthur. For the aforementioned operation, R offers the function filter(), which lies within the dplyr package. This functions works as follows: filter(dataset, condition) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:terra&#39;: ## ## collapse, desc, intersect, near, select, union ## The following objects are masked from &#39;package:raster&#39;: ## ## intersect, select, union ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union parkBikes_winti &lt;- filter(veloparkierungsanlagen_zh,GEMEINDE == &quot;Winterthur&quot;) The operation above produces the same outcome as the one depicted in the figure below 5.2. Figure 5.2: Select by Attributes in ArcGIS pro "],["Select_by_Location.html", "5.2 Select by Location", " 5.2 Select by Location A very common operations when dealing with geodata is the process of selecting features based on a spatial relationship to another object (layer). In ArcGIS pro this process is usually performed using the Select by Location tool. This tool offers selecting features based on the following relationships: intersect: The features in the input layer will be selected if they intersect a selecting feature. This is the default. intersect_3d: The features in the input layer will be selected if they intersect a selecting feature in three-dimensional space (x, y, and z). within_a_distance: The features in the input layer will be selected if they are within the specified distance (using Euclidean distance) of a selecting feature. Use the search_distance parameter to specify the distance. within_a_distance_3d: The features in the input layer will be selected if they are within a specified distance of a selecting feature in three-dimensional space. Use the search_distance parameter to specify the distance. within_a_distance_geodesic: The features in the input layer will be selected if they are within a specified distance of a selecting feature. Distance between features will be calculated using a geodesic formula that takes into account the curvature of the spheroid and correctly handles data near and across the dateline and poles. Use the search_distance parameter to specify the distance. contains: The features in the input layer will be selected if they contain a selecting feature. completely_contains: The features in the input layer will be selected if they completely contain a selecting feature. contains_clementini: This spatial relationship yields the same results as COMPLETELY_CONTAINS with the exception that if the selecting feature is entirely on the boundary of the input feature (no part is properly inside or outside), the feature will not be selected. CLEMENTINI defines the boundary polygon as the line separating inside and outside, the boundary of a line is defined as its end points, and the boundary of a point is always empty. within: The features in the input layer will be selected if they are within a selecting feature. completely_within: The features in the input layer will be selected if they are completely within or contained by a selecting feature. within_clementini: The result will be identical to WITHIN with the exception that if the entirety of the feature in the input layer is on the boundary of the feature in the selecting layer, the feature will not be selected. CLEMENTINI defines the boundary polygon as the line separating inside and outside, the boundary of a line is defined as its end points, and the boundary of a point is always empty. are_identical_to: The features in the input layer will be selected if they are identical (in geometry) to a selecting feature. boundary_touches: The features in the input layer will be selected if they have a boundary that touches a selecting feature. When the input features are lines or polygons, the boundary of the input feature can only touch the boundary of the selecting feature, and no part of the input feature can cross the boundary of the selecting feature. share_a_line_segment_with: The features in the input layer will be selected if they share a line segment with a selecting feature. The input and selecting features must be line or polygon. crossed_by_the_outline_of: The features in the input layer will be selected if they are crossed by the outline of a selecting feature. The input and selecting features must be lines or polygons. If polygons are used for the input or selecting layer, the polygon’s boundary (line) will be used. Lines that cross at a point will be selected; lines that share a line segment will not be selected. have_their_center_in: The features in the input layer will be selected if their center falls within a selecting feature. The center of the feature is calculated as follows: for polygon and multipoint, the geometry’s centroid is used; for line input, the geometry’s midpoint is used. Note that many these relationships are specified in an elegant, generic approach known as “Spatial Predicates”. Read more about this in chapter 12 The operations are based on the following rule: x[y, ,operation], where: x and y are the spatial objects for which we want to investigate if there is a spatial relationship (x is the target feature, while y is the source one) the second argument [, ,] within the brackets denotes the column number we want to retrieve from the spatial subsetting. In our example this argument was empty, which means we wanted to retrieve all rows for every attribute column. the third argument [op = ] specifies the spatial operation we want to perform. In the example above, the goal was to find out how many subset features of the target object swimmSpots lie withing the source spatial object richterswil. For that reason we chose the function st_within(). For this chapter, we will use the following libraries: 5.2.1 Intersect 5.2.2 Intersect_3d 5.2.3 Within_a_distance 5.2.4 Within_a_distance_3d 5.2.5 Within_a_distance_geodesic 5.2.6 Contains 5.2.7 Completely_contains 5.2.8 Contains_clementini 5.2.9 Within An example of spatial subsetting could be the following. Let’s assume we have a polygon dataset with all the municipalities (Gemeinden) of the Canton of Zurich. Furthermore, we are also using a shapefile in the form of a point dataframe, which represents all the “swimming spots” (Badenplätze) in the same spatial region (Canton of Zurich). So, ultimately, our goal is to find out the “swimming spots” that lie within a specific municipality of the Canton of Zurich. # Minicipalities (Gemeinde) in Canton Zurich data(&quot;gemeindegrenzen_zh&quot;) # &#39;Swimming&#39; spots in the Canton of Zurich data(&quot;badeplaetze_zh&quot;) swimmSpots_richt &lt;- badeplaetze_zh[richterswil, , op = st_within] 5.2.10 Completely_within 5.2.11 Within_clementini 5.2.12 Are_identical_to 5.2.13 Boundary_touches 5.2.14 Share_a_line_segment_with 5.2.15 Crossed_by_the_outline_of 5.2.16 Have_their_center_in "],["20_Geoprocessing_Tools.html", "About this Section", " About this Section Generally speaking ESRI’s approach to building ArcGIS is to create a tool for every situation you might encounter. This is a little different in R. Depending on the package, the idea is usually to provide a minimal set of functions with which the user can create their own tools. The creators of the package sf are very strict on this paradigm.4 As Roger Bivand once put it: Users should learn to catch fish, not be given tidied fish. knitr::opts_chunk$set(echo = FALSE, message = FALSE) library(dplyr) library(readr) library(stringr) library(data.tree) library(networkD3) library(yaml) tools &lt;- read_csv(&quot;ESRI_Tool_names.csv&quot;) %&gt;% mutate(toolb = str_remove(toolb, &quot; toolbox&quot;)) %&gt;% distinct(toolb, toolset, Tool) toolsets &lt;- read_csv(&quot;ESRI_Toolsets.csv&quot;) %&gt;% distinct(toolb, tool) toolboxes &lt;- read_csv(&quot;ESRI_Toolboxes.csv&quot;) %&gt;% distinct(name) We haven’t found a complete overview of all the “Geprocessing Tools” in ArcGIS, but we’ve scraped ESRI’S website and counted 38 Toolboxes, containing 244 Toolsets and 1132 individual tools5. We cannot possibly cover the R way for every tool in this list. It probably wouldn’t make much sense either: Once you learn the fundamental building blocks, you will be able to replicate most, if not all tools from this list. The aim of this book is to cover these fundamental building block. See figure 5.3 for an interactive visualisation of all tools in ArcGIS. Figure 5.3: A ‘diagonal Network’ visualisation of many6 of the tools available in ArcGIS Pro. This and this github nicely illustrate this.↩︎ Note: these numbers are an approximation only, we may have made errors when scraping↩︎ Note: these numbers are an approximation only, we may have made errors when scraping↩︎ "],["Analysis.html", "6 Analysis Toolbox", " 6 Analysis Toolbox The Analysis toolbox contains 5 toolsets to “perform the most fundamental GIS Operations” (Esri 2020). It covers the tools you will encounter in every 101 course to GIS: Clip, Buffer, Spatial Join. We wont cover all tools in this toolbox, but focus on three toolsets that contain the most commonly used tools. All these tools are vector based, so we will work mostly with the package sf (see chapter 3.1). Table of content 6.1 Extract Toolset 6.1.1 Clip 6.1.2 Select 6.1.3 Split 6.1.4 Split by Attributes 6.2 Overlay Toolset 6.2.1 Spatial Join 6.3 Proximity Toolset 6.3.1 Buffer "],["Extract.html", "6.1 Extract Toolset", " 6.1 Extract Toolset From the docs (Esri 2020): GIS datasets often contain more data than you need. The Extract tools let you select features and attributes in a feature class or table based on a query (SQL expression) or spatial and attribute extraction. The output features and attributes are stored in a feature class or table. For this chapter, you will need the following R Packages: library(arc2r) library(sf) library(tmap) 6.1.1 Clip Quite often in spatial analysis, we come across cases where we do not want to use all the available data there is. In other words, we want to focus on a specific area of interest, which dictates the need for clipping the existing dataset based on it’s relationship to some other existing spatial feature. In R this operation can be easily performed using the st_intersection function in sf. Let’s assume in the example below that we want to clip the available dataset of all the train stations in Switzerland by focusing our analysis on the cantons Zurich, St. Gallen, Thurgau and Aargau. In the following chunk we prerpare and visualize this situation. # Point dataset depicting the train stations locations across Switzerland data(&quot;haltestelle_bahn&quot;) # Dataset depicting Switzerland on canton level data(&quot;kantonsgebiet&quot;) kanton_filter &lt;- filter(kantonsgebiet, NAME %in% c(&quot;Zürich&quot;, &quot;St. Gallen&quot;, &quot;Thurgau&quot;, &quot;Aargau&quot;)) plot(st_geometry(haltestelle_bahn)) plot(st_geometry(kanton_filter), col = &quot;grey&quot;, add = TRUE, alpha = 1) To clip the dataset haltestellen_bahn to the extent of _kanton_filter, we can simply use the st_intersection function as shown below: haltestelle_bahn_clipped &lt;- st_intersection(kanton_filter, haltestelle_bahn) We can now visualize the result from our operation: So, ultimately, as we can see above, the st_intersection function creates a result where the point dataset is precisely “clipped” based on the area of interest. The operation above produces the same outcome as the one depicted in the figure below 6.1. Figure 6.1: Clip operation in ArcGIS pro 6.1.2 Select This chapter is covered in 5.1. 6.1.3 Split The split tool is used in ArcGIS to split a dataset into multiple outputs. When clipping the haltestellen dataset in 6.1.1 with a polygon containing multiple features (kanton_filter). Each point in haltestelle_bahn_clipped now has the attributes originating from kanton_filter, which we can use to split the dataset into different parts. The function split() (from base-R) helps us with this. It returns a list of sf objects, that we can each save in it’s own dataset if need be. haltestellen_split &lt;- split(haltestelle_bahn_clipped, haltestelle_bahn_clipped$name) str(haltestellen_split[1:2]) ## List of 2 ## $ Aadorf:Classes &#39;sf&#39; and &#39;data.frame&#39;: 1 obs. of 3 variables: ## ..$ NAME : chr &quot;Thurgau&quot; ## ..$ name : chr &quot;Aadorf&quot; ## ..$ geometry:sfc_POINT of length 1; first list element: &#39;XY&#39; num [1:2] 2710374 1260730 ## ..- attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## ..- attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA ## .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;NAME&quot; &quot;name&quot; ## $ Aarau :Classes &#39;sf&#39; and &#39;data.frame&#39;: 2 obs. of 3 variables: ## ..$ NAME : chr [1:2] &quot;Aargau&quot; &quot;Aargau&quot; ## ..$ name : chr [1:2] &quot;Aarau&quot; &quot;Aarau&quot; ## ..$ geometry:sfc_POINT of length 2; first list element: &#39;XY&#39; num [1:2] 2646322 1249126 ## ..- attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; ## ..- attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA ## .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;NAME&quot; &quot;name&quot; 6.1.4 Split by Attributes See 6.1.3. "],["Overlay.html", "6.2 Overlay Toolset", " 6.2 Overlay Toolset From the docs (Esri 2020): The Overlay toolset contains tools to overlay multiple feature classes to combine, erase, modify, or update spatial features, resulting in a new feature class. New information is created when overlaying one set of features with another. All of the overlay operations involve joining two sets of features into a single set of features to identify spatial relationships between the input features. For this chapter, you will need the following R Packages: library(arc2r) library(sf) library(dplyr) library(ggplot2) 6.2.1 Spatial Join Esri (2020) describes Spatial Join as follows: Joins attributes from one feature to another based on the spatial relationship. The target features and the joined attributes from the join features are written to the output feature class. Say you have two datasets, haltestelle_bahn and kantonsgebiet as shown below. data(&quot;haltestelle_bahn&quot;) data(&quot;kantonsgebiet&quot;) head(haltestelle_bahn) ## Simple feature collection with 6 features and 1 field ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2694932 ymin: 1263039 xmax: 2713408 ymax: 1289090 ## projected CRS: CH1903+ / LV95 ## name geometry ## 1 Thayngen POINT (2694932 1289090) ## 2 Ramsen POINT (2703768 1285024) ## 3 Hemishofen POINT (2704726 1281756) ## 4 Weberei Matzingen POINT (2711701 1265116) ## 5 Matzingen POINT (2712529 1264372) ## 6 Jakobstal POINT (2713408 1263039) head(kantonsgebiet) ## Simple feature collection with 6 features and 1 field ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 2494306 ymin: 1075268 xmax: 2833858 ymax: 1268609 ## projected CRS: CH1903+ / LV95 ## NAME geometry ## 1 Graubünden POLYGON ((2735216 1194955, ... ## 2 Bern POLYGON ((2595242 1169313, ... ## 3 Valais POLYGON ((2601808 1136117, ... ## 4 Vaud POLYGON ((2555093 1138713, ... ## 5 Ticino POLYGON ((2727359 1119219, ... ## 6 St. Gallen POLYGON ((2716175 1240719, ... plot(st_geometry(kantonsgebiet)) plot(haltestelle_bahn, add = TRUE, col = &quot;blue&quot;, pch = 20) For each point in haltestelln_bahn, we would like to know the name of the canton in which it is located. In R, the function used to join two datastes is st_join(x,y). If you have to different data types (e.g. Points and Polygons) the first question you have to ask yourself is: what data type should the output be? The datatype of x determines what the output datatype is. So with the above data: Say for each point, we want to know the Name (name) of the “Canton” in which it lies. This means the output is a point dataset. We therefore write: haltestelle_bahn_join &lt;- st_join(haltestelle_bahn, kantonsgebiet) haltestelle_bahn_join ## Simple feature collection with 3134 features and 2 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2488908 ymin: 1076850 xmax: 2817389 ymax: 1289090 ## projected CRS: CH1903+ / LV95 ## First 10 features: ## name NAME geometry ## 1 Thayngen Schaffhausen POINT (2694932 1289090) ## 2 Ramsen Schaffhausen POINT (2703768 1285024) ## 3 Hemishofen Schaffhausen POINT (2704726 1281756) ## 4 Weberei Matzingen Thurgau POINT (2711701 1265116) ## 5 Matzingen Thurgau POINT (2712529 1264372) ## 6 Jakobstal Thurgau POINT (2713408 1263039) ## 7 Wiesengrund Thurgau POINT (2713771 1262367) ## 8 Wängi Thurgau POINT (2714128 1261715) ## 9 Rosental Thurgau POINT (2715765 1261315) ## 10 Münchwilen Pflegeheim Thurgau POINT (2717089 1260114) The following visualisation shows that each point has inherited the Name of the according Canton. ggplot() + geom_sf(data = kantonsgebiet) + geom_sf(data = haltestelle_bahn_join, aes(colour = NAME)) By default, the spatial relationship between haltestellen_bahn and kantonsgebiet was that of an “intersection” (this is also de default in ArcGIS). However, we can do spatial joins with other relationships as well: These relationships are commonly known as “spatial predicates.” ArcGIS Term R Spatial Predicate Intersect st_intersect Intersect 3D \\(^1\\) Within a distance st_is_within_distance Within a distance geodesic \\(^2\\) Within a distance 3D \\(^1\\) Contains st_contains Completely contains st_contains_properly Contains clementini \\(^2\\) Within st_within Completely within \\(^2\\) Within clementini \\(^2\\) Are identical to st_equals boundry touches st_touches Share a line segment \\(^2\\) Have their center in \\(^2\\) Closest st_nearest_feature Closest geodesic \\(^2\\) \\(^1\\) All binary predicates only work on 2D Objects (see this issue) \\(^2\\) We haven’t figured out which Spatial Predicate matches this ArcGIS term. "],["Proximity.html", "6.3 Proximity Toolset", " 6.3 Proximity Toolset From the docs (Esri 2020): The Proximity toolset contains tools that are used to determine the proximity of features within one or more feature classes or between two feature classes. These tools can identify features that are closest to one another or calculate the distances between or around them. For this chapter, you will need the following R Packages: library(arc2r) library(sf) library(ggplot2) 6.3.1 Buffer One of the most commonly used operations in ArcGIS pro is the one called Buffer. This operation provides a very convenient way of identifying areas of interest lying in the neighborhood of an existing spatial feature. In R the same action can be performed using the st_buffer function in sf. Below we introduce a line spatial feature that depicts all the mountain bike routes in Switzerland. data(&quot;mountainBikes_routes&quot;) # Dataset depicting the mountain bike routes in Switzerland data(&quot;kantonsgebiet&quot;) plot(st_geometry(kantonsgebiet)) plot(st_geometry(mountainBikes_routes), add = TRUE, col = &quot;red&quot;) We might be interested in identifying all the areas in a radius of 1000 m around these bike routes. routes_buffer &lt;- st_buffer(mountainBikes_routes, 1000) plot(st_geometry(routes_buffer)) plot(st_geometry(mountainBikes_routes), add = TRUE) The operation above produces the same outcome as the one depicted in the figure below ??. Figure 6.2: Buffer operation in ArcGIS pro "],["Data_Management.html", "7 Data Management Toolbox", " 7 Data Management Toolbox Data Management toolbox in ArcGIS pro provides the users a variety of tools for managing, maintaining and developing datasets that come in all possible forms (feature classes / datasets, raster datasets). Table of content 7.1 General Toolset 7.1.1 Sort 7.1.2 Rename 7.1.3 Merge 7.1.4 Dissolve 7.1.5 Find Identical 7.2 Joins and Relates Toolset 7.2.1 Inner join 7.2.2 Outer join 7.2.3 Left / Right join 7.3 Projections and Transformations Toolset 7.3.1 Define Projection 7.3.2 Project 7.3.3 Project Raster 7.4 Raster Processing Toolset 7.4.1 Clip Raster 7.5 Sampling Toolset 7.5.1 Generate Tessellation 7.5.2 Create Random Points 7.5.3 Generate Points Along Lines "],["General.html", "7.1 General Toolset", " 7.1 General Toolset For this chapter, you will need the following R Packages: library(arc2r) library(sf) library(ggplot2) library(dplyr) 7.1.1 Sort Sorting out features in ascending or descending order seems a quite primitive operation in any programming language or software package. Even though it is indeed primitive, it is also quite important for filtering and cleaning our datasets. In ArcGIS pro this operation is performed using the tool Sort, which is part of the General toolset of the Data Managenent Toolbox. Below we present how we can perform the aforementioned operation using R. For our example we use the Simple Feature object bezirke, which depicts the districts within the country of Switzerland. Furthermore for performing the sorting operation, we use the record(column) that represents the area (in square km) of every of the districts. # Read the dataset depicting the districts (Bezirke) in the country of # Switzerland data(&quot;bezirke&quot;) # sort the dataset based on the Area in ascending order bezirke_asc &lt;- bezirke[order(bezirke$area_km2), ] head(bezirke_asc) ## Simple feature collection with 6 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2574333 ymin: 1210642 xmax: 2744654 ymax: 1279605 ## z_range: zmin: -1.455192e-11 zmax: -1.455192e-11 ## CRS: NA ## NAME OBJEKTART OBJECTID area_km2 geom ## 68 St. Gallen Bezirk 153 0.1150075 MULTIPOLYGON Z (((2744592 1... ## 133 Höfe Bezirk 1 0.1312150 MULTIPOLYGON Z (((2701415 1... ## 186 Schaffhausen Kanton 176 0.2405185 MULTIPOLYGON Z (((2707903 1... ## 104 Seeland Bezirk 9 0.4128530 MULTIPOLYGON Z (((2575776 1... ## 119 Wil Bezirk 145 0.5292165 MULTIPOLYGON Z (((2732986 1... ## 131 Höfe Bezirk 43 0.5612065 MULTIPOLYGON Z (((2702572 1... # sort the dataset based on the Area in descending order bezirke_desc &lt;- bezirke[order(-bezirke$area_km2), ] head(bezirke_desc) ## Simple feature collection with 6 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2580900 ymin: 1128447 xmax: 2833842 ymax: 1219106 ## z_range: zmin: -1.455192e-11 zmax: -1.455192e-11 ## CRS: NA ## NAME OBJEKTART OBJECTID area_km2 ## 15 Surselva Bezirk 13 1373.7973 ## 9 Interlaken-Oberhasli Bezirk 15 1231.6744 ## 2 Engiadina Bassa/Val Müstair Bezirk 74 1197.5201 ## 171 Uri Kanton 159 1076.0927 ## 4 Maloja Bezirk 183 973.7269 ## 52 Bern-Mittelland Bezirk 89 939.6023 ## geom ## 15 MULTIPOLYGON Z (((2713720 1... ## 9 MULTIPOLYGON Z (((2629665 1... ## 2 MULTIPOLYGON Z (((2812980 1... ## 171 MULTIPOLYGON Z (((2684185 1... ## 4 MULTIPOLYGON Z (((2775675 1... ## 52 MULTIPOLYGON Z (((2587852 1... The beauty of R is that offers more than one option to perform a specific operation. In the example above, for performing the sorting operation, we used a simple subsetting method integrated within the so called base R. Nevertheless using the the function arrange() of the dpyr package we will be able to produce the exact same result. # sort the dataset based on the Area in ascending order bezirke_arrange_asc &lt;- arrange(bezirke, area_km2) # by default the function sorts in ascendind order head(bezirke_arrange_asc) ## Simple feature collection with 6 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2574333 ymin: 1210642 xmax: 2744654 ymax: 1279605 ## z_range: zmin: -1.455192e-11 zmax: -1.455192e-11 ## CRS: NA ## NAME OBJEKTART OBJECTID area_km2 geom ## 1 St. Gallen Bezirk 153 0.1150075 MULTIPOLYGON Z (((2744592 1... ## 2 Höfe Bezirk 1 0.1312150 MULTIPOLYGON Z (((2701415 1... ## 3 Schaffhausen Kanton 176 0.2405185 MULTIPOLYGON Z (((2707903 1... ## 4 Seeland Bezirk 9 0.4128530 MULTIPOLYGON Z (((2575776 1... ## 5 Wil Bezirk 145 0.5292165 MULTIPOLYGON Z (((2732986 1... ## 6 Höfe Bezirk 43 0.5612065 MULTIPOLYGON Z (((2702572 1... # sort the dataset based on the Area in descending order bezirke_arrange_desc &lt;- arrange(bezirke, -area_km2) head(bezirke_arrange_desc) ## Simple feature collection with 6 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2580900 ymin: 1128447 xmax: 2833842 ymax: 1219106 ## z_range: zmin: -1.455192e-11 zmax: -1.455192e-11 ## CRS: NA ## NAME OBJEKTART OBJECTID area_km2 ## 1 Surselva Bezirk 13 1373.7973 ## 2 Interlaken-Oberhasli Bezirk 15 1231.6744 ## 3 Engiadina Bassa/Val Müstair Bezirk 74 1197.5201 ## 4 Uri Kanton 159 1076.0927 ## 5 Maloja Bezirk 183 973.7269 ## 6 Bern-Mittelland Bezirk 89 939.6023 ## geom ## 1 MULTIPOLYGON Z (((2713720 1... ## 2 MULTIPOLYGON Z (((2629665 1... ## 3 MULTIPOLYGON Z (((2812980 1... ## 4 MULTIPOLYGON Z (((2684185 1... ## 5 MULTIPOLYGON Z (((2775675 1... ## 6 MULTIPOLYGON Z (((2587852 1... 7.1.2 Rename Rename tool in ArcGIS pro serves as a very simple way of changing the name of a dataset. This applies to any of the available data types, such as feature dataset, raster, table, and shapefile. Let’s see below how we can perform a similar operation in R. The easiest way to do it is by reassigning the dataset to a new variable. R is smart enough not to make a copy if the variable is exactly the same. # Reading the dataset that depicts all the swimming spots in the canton of Zurich data(&quot;badeplaetze_zh&quot;) # Renaming the dataset above to &#39;swimming_spots_zh&#39; swimming_spots_zh &lt;- badeplaetze_zh # Retrieving the address in memory for the two datasets tracemem(badeplaetze_zh) # --&gt; &lt;000001F24AB616E8&gt; ## [1] &quot;&lt;0x7faf9e2dc7f8&gt;&quot; tracemem(swimming_spots_zh) # --&gt; &lt;000001F24AB616E8&gt; ## [1] &quot;&lt;0x7faf9e2dc7f8&gt;&quot; As we can see both objects point to the same address. R makes a new copy in the memory only if one of them is modified. 7.1.3 Merge Merge tool in ArcGIS pro is mainly used for combining datasets from different sources into a new, single output dataset. The main prerequisite for this operation is that the merging datasets have to be of the same geometry class. In R the aforementioned operation could be performed as follows: # Using the dataset that depicts all the 26 Cantons of Switzerland data(&quot;kantonsgebiet&quot;) # Selecting the Canton of Zug zug &lt;- filter(kantonsgebiet, NAME == &quot;Zug&quot;) # depicting the Canton of Zug ggplot(zug) + geom_sf() # depicting the Canton of Zug # Selecting the Canton of Zürich zurich &lt;- filter(kantonsgebiet, NAME == &quot;Zürich&quot;) ggplot(zurich) + geom_sf() # depicting the Canton of Zurich # merging the two sf objects merged &lt;- rbind(zug, zurich) ggplot(merged) + geom_sf() # depicting the product of the merge operation 7.1.4 Dissolve Dissolve in ArcGIS pro serves as a basic tool for aggregating features based on specified attributes. In R the respective operation could be easily performed using some basic functionalities of the sf package. In the example below we use again the dataset that depicts all the 26 Cantons of Switzerland. Our aim is to transform the given dataset to one unified spatial polygon. # The study area from the previous example head(kantonsgebiet) ## Simple feature collection with 6 features and 1 field ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 2494306 ymin: 1075268 xmax: 2833858 ymax: 1268609 ## projected CRS: CH1903+ / LV95 ## NAME geometry ## 1 Graubünden POLYGON ((2735216 1194955, ... ## 2 Bern POLYGON ((2595242 1169313, ... ## 3 Valais POLYGON ((2601808 1136117, ... ## 4 Vaud POLYGON ((2555093 1138713, ... ## 5 Ticino POLYGON ((2727359 1119219, ... ## 6 St. Gallen POLYGON ((2716175 1240719, ... ggplot(kantonsgebiet) + geom_sf() # depicting all the 26 Cantons of Switzerland # Dissolving all the cantons into one unified area kantonsgebiet_dissolved &lt;- st_union(kantonsgebiet) # use of the sf__st_union() function head(kantonsgebiet_dissolved) ## Geometry set for 1 feature ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 2485410 ymin: 1075268 xmax: 2833858 ymax: 1295934 ## projected CRS: CH1903+ / LV95 # Plot the dissolved output ggplot(kantonsgebiet_dissolved) + geom_sf() 7.1.5 Find Identical In ArcGIS pro Find Identical tool identifies records in a feature class or table that have identical values in a list of fields. As an outcome it produces a table listing those identical findings. In R we obtain a similar result for spatial features using the st_equals function of the sf package. # create the duplicates addDupli &lt;- kantonsgebiet[1:3, ] # Combine it with the original dataset (kantonsgebiet) kantonDuplic &lt;- rbind(kantonsgebiet, addDupli) # Examine if there are any identical values ident_results &lt;- st_equals(kantonDuplic) "],["Join.html", "7.2 Joins and Relates Toolset", " 7.2 Joins and Relates Toolset For this chapter, you will need the following R Packages: library(dplyr) In ArcGIS, joining two datasets on a common attribute is done with tools from the “Join” Toolset. Similar as described with the Selection tools in chapter 5, a join has a temporary / floating nature and does not automatically produce an output. In R, joining two datasets is only persistent if the output is assigned to a new variable7. In R we have two main functions for joining two datasets. On the one hand there is the base R function merge, on the other hand there is the *_join family that lie within the dplyr package. Since the latter family of functions are very close to how Joins are done in SQL, we will use the latter case for our examples below. Before we begin with our examples, we have to make clear the differences among the various forms of join operations. Inner Join only retains rows that are matched in both datasets. Outer Join retains all rows from both datasets. Left Join retains all rows from the “left” dataset, Right Join only those from the “right” dataset. knitr::include_graphics(&quot;images/joins.png&quot;) Figure 7.1: Join operations 7.2.1 Inner join Inner Join in R is the most common type of join. It is an operation that returns the rows when the matching condition is fulfilled. Below we demonstrate it with an example. df1 &lt;- data.frame(TeamID = c(1, 4, 6, 11), TeamName = c(&quot;new york knicks&quot;, &quot;los angeles lakers&quot;, &quot;milwaukee bucks&quot;, &quot;boston celtics&quot;), Championships = c(2, 17, 1, 17)) df2 &lt;- data.frame(TeamID = c(1, 2, 11, 8), TeamName = c(&quot;new york knicks&quot;, &quot;philadelphia 76ers&quot;, &quot;boston celtics&quot;, &quot;los angeles clippers&quot;), Championships = c(2, 3, 17, 0)) df1 ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 4 los angeles lakers 17 ## 3 6 milwaukee bucks 1 ## 4 11 boston celtics 17 df2 ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 2 philadelphia 76ers 3 ## 3 11 boston celtics 17 ## 4 8 los angeles clippers 0 df1 %&gt;% inner_join(df2) ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 11 boston celtics 17 7.2.2 Outer join Outer join in R using simply returns all rows from both data frames. This is very well depicted in figure 7.1. full_join(df1, df2) ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 4 los angeles lakers 17 ## 3 6 milwaukee bucks 1 ## 4 11 boston celtics 17 ## 5 2 philadelphia 76ers 3 ## 6 8 los angeles clippers 0 7.2.3 Left / Right join The left join in R returns all records from the data frame on the left, as well as and the matched records from the one at the right. left_join(df1, df2) ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 4 los angeles lakers 17 ## 3 6 milwaukee bucks 1 ## 4 11 boston celtics 17 Similarly works also the right join. right_join(df1, df2) ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 11 boston celtics 17 ## 3 2 philadelphia 76ers 3 ## 4 8 los angeles clippers 0 or piped into a new function↩︎ "],["Projections_and_Transformations.html", "7.3 Projections and Transformations Toolset", " 7.3 Projections and Transformations Toolset For this chapter, you will need the following R Packages: library(arc2r) library(sf) library(raster) If there is anything special about spatial, it’s the Coordinate Reference System. We will not get into the topic of CRS and Projections here, but it is advisable to get up to speed on this topic if you are dealing with geodata. From this toolset, we will cover the following tools: Define Projection Project Project Raster Rescale (Resizes a raster by the specified x and y scale factors) 7.3.1 Define Projection Overwrites the coordinate system information (map projection and datum) stored with a dataset. This tool is intended for datasets that have an unknown or incorrect coordinate system defined. If your dataset comes without an assigned CRS, things can get hairy. Usually, you can make an informed guess as to which CRS the dataset is associated with, but in the end only the data producer can tell you. Let’s take the dataset bezirke from the package arc2r. As you can see, the CRS field in the data’s header is NA. data(&quot;bezirke&quot;) Calling the function st_crs() on bezirke confirms this. st_crs(bezirke) ## Coordinate Reference System: NA In ArcGIS, we would use the Tool “Define projection.” In R, we use the function st_crs(dataset) &lt;- value, where value is the CRS of our dataset. It can be either A string accepted by GDAL (type character) A valid EPSG value (type integer) or An object of class crs We find option two to be the simplest approach. Since we know the dataset bezirke is in the new swiss coordinate system (CH1903+ / LV95), we can find out the EPSG code (e.g. by consulting epsg.io). We will not get into options 1 and 3 and only st_crs(bezirke) &lt;- 2056 If we look at our header again, we see that we have a new field projected CRS which is in fact displaying the correct name based on the EPSG code we provided. bezirke ## Simple feature collection with 192 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2485424 ymin: 1075268 xmax: 2833842 ymax: 1295937 ## z_range: zmin: -1.455192e-11 zmax: -1.455192e-11 ## projected CRS: CH1903+ / LV95 ## First 10 features: ## NAME OBJEKTART OBJECTID area_km2 ## 1 Albula Bezirk 137 683.35044 ## 2 Engiadina Bassa/Val Müstair Bezirk 74 1197.52015 ## 3 Prättigau/Davos Bezirk 112 853.35653 ## 4 Maloja Bezirk 183 973.72688 ## 5 Entremont Bezirk 72 633.27334 ## 6 Visp Bezirk 182 29.27770 ## 7 Visp Bezirk 167 835.54866 ## 8 Sierre Bezirk 88 417.76967 ## 9 Interlaken-Oberhasli Bezirk 15 1231.67445 ## 10 Hérens Bezirk 143 55.10483 ## geom ## 1 MULTIPOLYGON Z (((2758433 1... ## 2 MULTIPOLYGON Z (((2812980 1... ## 3 MULTIPOLYGON Z (((2767328 1... ## 4 MULTIPOLYGON Z (((2775675 1... ## 5 MULTIPOLYGON Z (((2574263 1... ## 6 MULTIPOLYGON Z (((2633950 1... ## 7 MULTIPOLYGON Z (((2630650 1... ## 8 MULTIPOLYGON Z (((2598823 1... ## 9 MULTIPOLYGON Z (((2629665 1... ## 10 MULTIPOLYGON Z (((2593875 1... st_set_crs function does not reproject the coordinates of the given dataset. In other words, it does not affect the actual geometry column of the sf object. st_tranform on the other hand indeed does indeed reproject the dataset to another coordinate 7.3.2 Project Projects spatial data from one coordinate system to another Now that bezirke has an assigned CRS (see 7.3.1, we can transform it into a new coordinate system. To emphasize this, will will visualize the dataset using base::plot() with the option axes = TRUE, to visualize the current coordinate system. plot(bezirke[&quot;area_km2&quot;], axes = TRUE) bezirke_wgs84 &lt;- st_transform(bezirke, 4326) plot(bezirke_wgs84[&quot;area_km2&quot;], axes = TRUE) st_crs(bezirke) ## Coordinate Reference System: ## User input: EPSG:2056 ## wkt: ## PROJCRS[&quot;CH1903+ / LV95&quot;, ## BASEGEOGCRS[&quot;CH1903+&quot;, ## DATUM[&quot;CH1903+&quot;, ## ELLIPSOID[&quot;Bessel 1841&quot;,6377397.155,299.1528128, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4150]], ## CONVERSION[&quot;Swiss Oblique Mercator 1995&quot;, ## METHOD[&quot;Hotine Oblique Mercator (variant B)&quot;, ## ID[&quot;EPSG&quot;,9815]], ## PARAMETER[&quot;Latitude of projection centre&quot;,46.9524055555556, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8811]], ## PARAMETER[&quot;Longitude of projection centre&quot;,7.43958333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8812]], ## PARAMETER[&quot;Azimuth of initial line&quot;,90, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8813]], ## PARAMETER[&quot;Angle from Rectified to Skew Grid&quot;,90, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8814]], ## PARAMETER[&quot;Scale factor on initial line&quot;,1, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8815]], ## PARAMETER[&quot;Easting at projection centre&quot;,2600000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8816]], ## PARAMETER[&quot;Northing at projection centre&quot;,1200000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8817]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;Europe - Liechtenstein and Switzerland&quot;], ## BBOX[45.82,5.96,47.81,10.49]], ## ID[&quot;EPSG&quot;,2056]] bezirke_swiss &lt;- st_transform(bezirke, 2056) # retrieve the coordinate system st_crs(bezirke_swiss) ## Coordinate Reference System: ## User input: EPSG:2056 ## wkt: ## PROJCRS[&quot;CH1903+ / LV95&quot;, ## BASEGEOGCRS[&quot;CH1903+&quot;, ## DATUM[&quot;CH1903+&quot;, ## ELLIPSOID[&quot;Bessel 1841&quot;,6377397.155,299.1528128, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4150]], ## CONVERSION[&quot;Swiss Oblique Mercator 1995&quot;, ## METHOD[&quot;Hotine Oblique Mercator (variant B)&quot;, ## ID[&quot;EPSG&quot;,9815]], ## PARAMETER[&quot;Latitude of projection centre&quot;,46.9524055555556, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8811]], ## PARAMETER[&quot;Longitude of projection centre&quot;,7.43958333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8812]], ## PARAMETER[&quot;Azimuth of initial line&quot;,90, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8813]], ## PARAMETER[&quot;Angle from Rectified to Skew Grid&quot;,90, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8814]], ## PARAMETER[&quot;Scale factor on initial line&quot;,1, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8815]], ## PARAMETER[&quot;Easting at projection centre&quot;,2600000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8816]], ## PARAMETER[&quot;Northing at projection centre&quot;,1200000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8817]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;Europe - Liechtenstein and Switzerland&quot;], ## BBOX[45.82,5.96,47.81,10.49]], ## ID[&quot;EPSG&quot;,2056]] 7.3.3 Project Raster Transforms a raster dataset from one coordinate system to another Working with Raster datasets in GIS of operations is of equal importance, as working with vector ones. One of the spatial properties of raster datasets is the the Coordinate Reference System (CRS). CRS is the specific system that “associates” the raster coordinates (which are just pairs of x/y values) to geographic locations. In ArcGIS pro the tool for projecting a raster dataset is called Project Raster (Data Management). Let’s see how we can perform the same operation with R. # Dataset derived from the spatial interpolation of all the available &#39;recycling # points&#39; in the city of Wädenwil data(&quot;recycling_raster&quot;) # Dataset representing the public transport quality in the city of Wädenswil data(&quot;public_transport_waedi&quot;) # CRS -&gt; WGS84 # Plot the raster dataset - World Geodetic System 1984 plot(public_transport_waedi, las = 1, main = &quot;Quality of public transport in the city of Wädenwil - CRS: WGS84&quot;, cex.main = 1, font.main = 4) We can use the projectRaster() function to reproject a raster into a new CRS. The first argument of the aforementioned function is the raster dataset we want to reproject, while the second one is the dataset to whose projection we are targeting to. So, in our case, we are targeting to the coordinate system of the raster_recycling dataset. It is important to remember that raster reprojection only works when the raster object has already a defined CRS. # Transform the coordinate system of the raster dataset publicTransport_CH into # the Swiss Coordinate system - CH1903+LV95 publicTransport_CH = projectRaster(public_transport_waedi, recycling_raster) # Plot the raster dataset - Swiss Coordinate System CH1903+LV95 plot(publicTransport_CH, las = 1, main = &quot;Quality of public transport in the city of Wädenwil - CRS: CH1903+LV95&quot;, cex.main = 1, font.main = 4) "],["Raster_Processing.html", "7.4 Raster Processing Toolset", " 7.4 Raster Processing Toolset For this chapter, you will need the following R Packages: library(arc2r) library(raster) library(sf) library(dplyr) library(stars) 7.4.1 Clip Raster In GIS operations is quite common the necessity of “clipping” an area based on some specific region of interest. This is a quite useful and necessary procedure not only when we are dealing with vector datasets, but also when we have to work with raster ones. In ArcGIS pro the procedure of “cutting” a portion of a raster dataset, mosaic dataset, or an image service layer is performed using Clip Raster tool. In R, the respective operation can be performed using the mask() function. For the example below, we are using the following datasets: ARE_waedi: Vector dataset that depicts the public transport connection quality in the city of Wädenswil raster_recycling: Dataset derived from the spatial interpolation of all the available “recycling points”in the city of Wädenwil # Insert a vector dataset that depicts the public transport connection quality in # the city of Wädenswil and plot it data(&quot;are_waedenswil&quot;) # Read the raster dataset and plot it data(&quot;recycling_raster&quot;) Plot the two datasets one over the other. plot(recycling_raster) plot(are_waedenswil, alpha = 0.5, add = TRUE) In our case, the vector dataset serves as the clipping extent for the clipping operation. recycle_Waedi_clip &lt;- mask(recycling_raster, are_waedenswil) Visualising the clipped output plot(recycle_Waedi_clip) "],["Sampling.html", "7.5 Sampling Toolset", " 7.5 Sampling Toolset For this chapter, you will need the following R Packages: library(sf) library(arc2r) library(ggplot2) library(dplyr) 7.5.1 Generate Tessellation Generate Tessellation tool in ArcGIS pro is used for generating a tessellated grid of regular polygon features. The generated output is covering a certain extent that usually represents the respective extent of another spatial feature. The aforementioned operation in R is possible using the function st_make_grid of the sf package. Below we present an example of how we can create a tesselated grid covering the spatial extent of the canton of Zurich in Switzerland. # Reading the simple feature object that depicts all the cantons of the country # of Switzerland data(&quot;kantonsgebiet&quot;) # Selecting only the geometric extent of the canton of Zurich zh &lt;- filter(kantonsgebiet, NAME == &quot;Zürich&quot;) # Plotting the selected area ggplot(zh) + geom_sf() + coord_sf(datum = 2056) # Creating a tessellated grid of hexagons using the st_make_grid() function. g &lt;- st_make_grid(zh, square = FALSE) # square = TRUE creates as expected a tesselation of squares # Plotting the generated output over the spatial representation of the canton of # Zurich ggplot() + geom_sf(data = zh, fill = &quot;red&quot;) + geom_sf(data = g, alpha = 0.3, color = &quot;black&quot;) + coord_sf(datum = 2056) + ggtitle(&quot;Tesselated grid within the Canton of Zürich&quot;) + theme(plot.title = element_text(hjust = 0.5), text = element_text(size = 9)) 7.5.2 Create Random Points Create Random Points tool in ArcGIS pro serves as a very straightforward way of generating randomly distributed points within an extent window, inside polygon features, on point features, or along line features. In R the respective operation can be again achieved using one of the functions provided by the sf package. Below we present how we can perform this operation with the function st_sample(). # Create random points (1000) within the spatial extent of the Canton of Zurich sample &lt;- st_sample(zh, size = 1000) # Plotting the randomly generated points over the spatial feature that represents # the canton of Zurich ggplot() + geom_sf(data = zh) + geom_sf(data = sample) + coord_sf(datum = 2056) + ggtitle(&quot;1000 random points witihn the Canton of Zurich&quot;) 7.5.3 Generate Points Along Lines data(&quot;mountainBikes_routes&quot;) line1 &lt;- mountainBikes_routes[1, ] pointsOnLine1 &lt;- st_line_sample(line1, 50, type = &quot;random&quot;) plot(st_geometry(line1)) plot(pointsOnLine1, add = TRUE, pch = 20, col = &quot;red&quot;) "],["Spatial_Analyst.html", "8 Spatial Analyst Toolbox", " 8 Spatial Analyst Toolbox Table of content Neighborhood toolset Focal Statistics Zonal toolset Zonal Statistics Reclass Toolset Reclassify Density Toolset Kernel Density Surface Toolset Slope and Aspect "],["Neighborhood.html", "8.1 Neighborhood toolset", " 8.1 Neighborhood toolset 8.1.1 Focal Statistics From the docs (Esri 2020): Focal statistics performs a neighbourhood operation that computes an output raster, where the value for each output cell is a function of the values of all the input cells that are in a specified neighborhood around that location. The function performed on the input is a statistic, such as the maximum, average, or sum of all values encountered in that neighborhood. In R in order to apply functions focally to rasters, important is to define the neighbouring cells. In other words to define the moving window for each of these functions. As an example below, we will create our own raster object. r &lt;- raster(ncol = 10, nrow = 10) values(r) &lt;- 1:ncell(r) plot(r, main = &quot;Raster with 100 cells&quot;, cex.main = 1) We will recompute now the raster based on the focal function of the raster package. In the function below, the neighbourhood for which we apply the statistic is represented by the argument w, while the statistic by the argument fun. f1 &lt;- focal(r, w = matrix(1, nrow = 3, ncol = 3), fun = sum) plot(f1, main = &quot;Raster after applying the focal function - raster package&quot;, cex.main = 1) The operation above can be also performed with the use of the focal function of the terra package. w represents the moving window of the function. The window can be defined as one (for a square) or two numbers (row, col); or with an odd-sized weights matrix. More details can be found here: https://rdrr.io/cran/terra/man/focal.html fun represents the specified statistic for the identified neighbourhood (e.g mean,sum etc) r_spat &lt;- as(r, &quot;SpatRaster&quot;) f2 &lt;- terra::focal(r_spat, w = 3, fun = &quot;sum&quot;) plot(f2, main = &quot;Raster after applying the focal function - terra package&quot;, cex.main = 1) "],["Zonal.html", "8.2 Zonal toolset", " 8.2 Zonal toolset 8.2.1 Zonal Statistics Zonal Statistics tool in ArcGIS pro is used for calculating the statistics on values of a raster within the zones of another dataset. In R we are able to produce similar results with the use of zonal function of the raster package. r &lt;- raster(ncols = 10, nrows = 10) # generating random numbers that will used as values in our raster layer (r) - # input values raster values(r) &lt;- runif(ncell(r)) * 1:ncell(r) z &lt;- r # generating integer values for the raster layer z, which will be used as the # zone raster values(z) &lt;- rep(1:5, each = 20) # Zonal statistics - Summarize zonal(r, z, &quot;sum&quot;) ## zone sum ## [1,] 1 127.3689 ## [2,] 2 272.3147 ## [3,] 3 417.1055 ## [4,] 4 669.2890 ## [5,] 5 657.2109 # Zonal statistics - Mean zonal(r, z, &quot;mean&quot;) ## zone mean ## [1,] 1 6.368443 ## [2,] 2 13.615737 ## [3,] 3 20.855276 ## [4,] 4 33.464449 ## [5,] 5 32.860544 # Zonal statistics - Minimum zonal(r, z, &quot;min&quot;) ## zone min ## [1,] 1 0.37560257 ## [2,] 2 0.06511613 ## [3,] 3 3.85035474 ## [4,] 4 4.64920185 ## [5,] 5 0.07475884 "],["Reclass.html", "8.3 Reclass Toolset", " 8.3 Reclass Toolset library(raster) library(arc2r) library(dplyr) 8.3.1 Reclassify In GIS quite often arises the necessity to reclassify a raster dataset. In other words, to create new classes with different range of values for the existing cell values of the dataset. This operation in ArcGIS Pro is performed using the Reclassify (Spatial Analyst) tool. In R the respective operation is quite straightforward and is based on the use of the reclassify function of the raster package. For our example we use the raster dataset swissAlti3D. data(&quot;swissAlti3D&quot;) plot(swissAlti3D) Let’s have a look at the histogram of the raster values to see their distribution. histinfo &lt;- hist(swissAlti3D) The histogram above automatically created 13 breaks (620,640,…,840,860). We can use these breaks to reclassify our values. To do so, we create below a reclassification matrix with the respective values. ## [,1] [,2] [,3] ## [1,] 0 620 1 ## [2,] 620 640 2 ## [3,] 640 660 3 ## [4,] 660 680 4 ## [5,] 680 700 5 ## [6,] 700 720 6 ## [7,] 720 740 7 ## [8,] 740 760 8 ## [9,] 760 780 9 ## [10,] 780 800 10 ## [11,] 800 820 11 ## [12,] 820 840 12 ## [13,] 840 860 13 After creating the respective matrix with the new classes, we are ready to call the reclassify function. The function takes as a first argument the dataset set to be reclassified and as second the matrix, on which the reclassification is based on. swissAlti3D_reclass &lt;- reclassify(swissAlti3D, reclass_m) plot(swissAlti3D_reclass) Figure 8.1: Aspect of swissALTI3D2019 in 4 classes "],["Density.html", "8.4 Density Toolset", " 8.4 Density Toolset 8.4.1 Kernel Density There are several Function that can be tweaked to calculate KDE for sf-Point object: tmaptools::smooth_map(): Depricated (is there a successor?) spatstat::density.ppp(): Takes only objects of Class ppp MASS::kde2d(): Takes x/y coordinates as vectors and returns a matrix In this example, I take MASS:kde2d() and tweak it to take sf and return raster. First, let’s create some sample data: set.seed(10) mypoints &lt;- data.frame(x = rnorm(1000), y = rnorm(1000)) %&gt;% st_as_sf(coords = c(1, 2)) plot(mypoints) my_kde &lt;- function(points, cellsize, bandwith, extent = NULL) { require(MASS) require(raster) require(sf) if (is.null(extent)) { extent_vec &lt;- st_bbox(points)[c(1, 3, 2, 4)] } else { extent_vec &lt;- st_bbox(extent)[c(1, 3, 2, 4)] } n_y &lt;- ceiling((extent_vec[4] - extent_vec[3])/cellsize) n_x &lt;- ceiling((extent_vec[2] - extent_vec[1])/cellsize) extent_vec[2] &lt;- extent_vec[1] + (n_x * cellsize) - cellsize extent_vec[4] &lt;- extent_vec[3] + (n_y * cellsize) - cellsize coords &lt;- st_coordinates(points) matrix &lt;- kde2d(coords[, 1], coords[, 2], h = bandwith, n = c(n_x, n_y), lims = extent_vec) raster(matrix) } mypoints_kde &lt;- my_kde(mypoints, 0.01, 1) library(stars) ggplot() + geom_stars(data = st_as_stars(mypoints_kde)) + geom_sf(data = mypoints, alpha = 0.2, fill = &quot;black&quot;) + scale_fill_viridis_c() + labs(fill = &quot;KDE&quot;) + theme_void() "],["Surface.html", "8.5 Surface Toolset", " 8.5 Surface Toolset 8.5.1 Slope and Aspect In mathematics, the slope or gradient of a line describes its steepness, incline, or grade. A higher slope value indicates a steeper incl. Source: “http://wiki.gis.com/wiki/index.php/Slope” In GIS and specifically in terrain analysis, calculating the terrain slope is of great importance, since it can play a significant role in various forms of technical analysis. The most common way of calculating the slope is from a Digital Elevation Model (DEM). In ArcGIS pro the tool used for computing the slope of a raster dataset with elevation data is called Slope (3D Analyst).It identifies the steepness at each cell of a raster surface. The lower the slope value, the flatter the terrain; the higher the slope value, the steeper the terrain. In R, raster package includes the function terrain(), which helps us compute slope, aspect and other terrain characteristics from a raster with elevation data. Let’s start by computing the slope of the swissAlti3d raster dataset. data(&quot;swissAlti3D&quot;) plot(swissAlti3D) Figure 8.2: swissALTI3D2019 - CRS: CH1903+LV95 After importing and visualizing our raster dataset, we use the terrain function to calculate the slope. Figure 8.3: swissALTI3D2019 - CRS: CH1903+LV95 In the function above, we define the operation we want to perform as the second argument of the function (opt = “slope”). Furthermore, we also define the units of the final result. Similarly, we compute the aspect of a given dataset. Basically as aspect we can consider the compass direction that a slope leans towards. Let’s compute now, using again the same function terrain, the aspect of the same dataset swissALTI3D2019. Figure 8.4: Aspect of swissALTI3D2019 in degrees (°) So, R gives us the option to retrieve multiple terrain characteristics of a raster dataset, using only one function. The aforementioned spatial operation in ArcGIS pro could be performed using the tool Aspect (Spatial Analyst). "],["Spatial_Statistics.html", "9 Spatial Statistics Toolbox", " 9 Spatial Statistics Toolbox Table of content Analysing Patterns Toolset Spatial Autocorrelation (Global Morans I) "],["Analysing_Patterns.html", "9.1 Analysing Patterns Toolset", " 9.1 Analysing Patterns Toolset For this chapter, you will need the following R Packages: library(arc2r) library(sf) library(ggplot2) 9.1.1 Spatial Autocorrelation (Global Morans I) Here’s the function to calculate Morans I morans_i &lt;- function(sf_object, col) { require(sf) n &lt;- nrow(sf_object) y &lt;- unlist(st_set_geometry(sf_object, NULL)[, col], use.names = FALSE) ybar &lt;- mean(y, na.rm = TRUE) dy &lt;- y - ybar dy_sum &lt;- sum(dy^2, na.rm = TRUE) vr &lt;- n/dy_sum w &lt;- st_touches(sf_object, sparse = FALSE) pm &lt;- tcrossprod(dy) pmw &lt;- pm * w spmw &lt;- sum(pmw, na.rm = TRUE) smw &lt;- sum(w, na.rm = TRUE) sw &lt;- spmw/smw MI &lt;- vr * sw MI } data(&quot;zweitwohnung_gemeinden&quot;) zweitwohung &lt;- st_set_crs(zweitwohnung_gemeinden, 2056) zweit_plot &lt;- ggplot(zweitwohung) + geom_sf(aes(fill = ja_in_percent), colour = NA) + scale_fill_gradient2(low = &quot;#2c7bb6&quot;, mid = &quot;#ffffbf&quot;, high = &quot;#d7191c&quot;, midpoint = 50, breaks = c(0, 25, 50, 75, 100), limits = c(0, 100)) + labs(title = &quot;Results from the &#39;Zweitwohungsinitiative&#39;&quot;, subtitle = &quot;Percent in Approval&quot;, fill = &quot;&quot;) + theme_void() + theme(legend.position = &quot;bottom&quot;) zweit_plot morans_i(zweitwohung, &quot;ja_in_percent&quot;) ## [1] 0.6304227 "],["Image_Analyst.html", "10 Image Analyst Toolbox", " 10 Image Analyst Toolbox From the docs (Esri 2020): The ArcGIS Image Analyst extension provides tools with which to analyze imagery data. The capabilities of Image Analyst are grouped into categories of related functionality. Knowing the categories will help you identify the tool to use. The table below lists the Image Analyst toolsets with a description of the capabilities offered by the tools in each. Table of content Map Algebra Toolset Raster Calulator "],["Map_Algebra.html", "10.1 Map Algebra Toolset", " 10.1 Map Algebra Toolset For this chapter, you will need the following R Packages: library(arc2r) library(raster) library(terra) 10.1.1 Raster Calulator In GIS Softwares (ArcGIS pro, QGIS etc) Raster Calculator is one of the most commonly used tools for performing various operations with raster datasets. For the example below we will work with 2 datasets that depict India’s population at two different timestamps. Our goal is to produce an output raster that demonstrates the evolvement of country’s population in this 10 years timespan. Naturally in ArcGIS pro, the aforementioned operation would be performed with the use of Raster Calculator. Let’s explore our options with R. # India&#39;s population in 2000 data(&quot;pop_india2000&quot;) # India&#39;s population in 2010 data(&quot;pop_india2010&quot;) par(mfrow = c(1, 2)) plot(pop_india2000) plot(pop_india2010) Let’s compute now the difference between the two rasters. To do so, there are various options. As first we can create a function that performs a simple subtraction of two rasters. diff_rasters &lt;- function(b1, b2) { # this function calculates the difference between two rasters of the same CRS and # extent input: 2 raster layers of the same extent, crs that can be subtracted # output: a single different raster of the same extent, crs of the input rasters diff &lt;- b2 - b1 return(diff) } Since, we created the function for subtracting one raster from another, we use now the function overlay of the raster package for producing the new raster output. # Compute the raster that depicts the difference in population in these 10 years pop2010_2000 &lt;- overlay(pop_india2000, pop_india2010, fun = diff_rasters) plot(pop2010_2000, main = &quot;India&#39;s population difference in the timespan of 10 years&quot;, cex.main = 1) "],["3D_Analyst.html", "11 3D Analyst Toolbox", " 11 3D Analyst Toolbox From the docs (Esri 2020): The 3D Analyst toolbox provides a collection of geoprocessing tools that enable a wide variety of analytical, data management, and data conversion operations on surface models and three-dimensional vector data. 3D Analyst tools provide the ability to create and analyze surface data represented in raster, terrain, triangulated irregular network (TIN), and LAS dataset formats. 3D data can be converted from a rich variety of formats, including COLLADA, lidar, SketchUp, OpenFlight, and many other data types. Analysis of geometric relationships and feature properties, interpolation of raster and various triangulated irregular network (TIN) models, and analysis of surface properties are only some of the numerous functions provided by the 3D Analyst tools. Table of content Raster Interpolation Toolset IDW Kriging Natural Neighbor "],["Raster_Interpolation.html", "11.1 Raster Interpolation Toolset", " 11.1 Raster Interpolation Toolset library(sp) library(sf) library(dplyr) library(stars) data(meuse) meuse_sf &lt;- meuse %&gt;% st_as_sf(coords = c(&quot;x&quot;, &quot;y&quot;)) 11.1.1 IDW my_idw &lt;- function(groundtruth, column, cellsize, nmax = Inf, maxdist = Inf, idp = 2, extent = NULL) { require(gstat) require(sf) require(raster) if (is.null(extent)) { extent &lt;- groundtruth } samples &lt;- st_make_grid(extent, cellsize, what = &quot;centers&quot;) %&gt;% st_as_sf() my_formula &lt;- formula(paste(column, &quot;~1&quot;)) idw_sf &lt;- gstat::idw(formula = my_formula, groundtruth, newdata = samples, nmin = 1, maxdist = maxdist, idp = idp) idw_matrix &lt;- cbind(st_coordinates(idw_sf), idw_sf$var1.pred) ras &lt;- raster::rasterFromXYZ(idw_matrix) if (all(grepl(&quot;polygon&quot;, st_geometry_type(extent), ignore.case = TRUE))) { ras &lt;- raster::mask(ras, st_as_sf(st_zm(extent))) } ras } meuse_idw &lt;- my_idw(meuse_sf, &quot;copper&quot;, cellsize = 10, idp = 3) ## [inverse distance weighted interpolation] ggplot() + geom_stars(data = st_as_stars(meuse_idw)) + scale_fill_viridis_c() + theme_void() + labs(fill = &quot;copper&quot;) + coord_equal() 11.1.2 Kriging my_krige &lt;- function(groundtruth, column, cellsize, nmax = Inf, maxdist = Inf, extent = NULL) { require(gstat) require(sf) require(raster) if (is.null(extent)) { extent &lt;- groundtruth } samples &lt;- st_make_grid(extent, cellsize, what = &quot;centers&quot;) %&gt;% st_as_sf() my_formula &lt;- formula(paste(column, &quot;~1&quot;)) idw_sf &lt;- gstat::krige(formula = my_formula, groundtruth, newdata = samples, nmin = 1, maxdist = maxdist) idw_matrix &lt;- cbind(st_coordinates(idw_sf), idw_sf$var1.pred) ras &lt;- raster::rasterFromXYZ(idw_matrix) if (all(grepl(&quot;polygon&quot;, st_geometry_type(extent), ignore.case = TRUE))) { ras &lt;- raster::mask(ras, st_as_sf(st_zm(extent))) } ras } meuse_krige &lt;- my_krige(meuse_sf, &quot;copper&quot;, cellsize = 10, nmax = 30, maxdist = 500) ## [inverse distance weighted interpolation] ggplot() + geom_stars(data = st_as_stars(meuse_krige)) + scale_fill_viridis_c(na.value = NA) + theme_void() + labs(fill = &quot;copper&quot;) + coord_equal() 11.1.3 Natural Neighbor Nearest Neighbor: meuse_thiessen &lt;- st_voronoi(st_union(meuse_sf)) meuse_thiessen &lt;- st_cast(meuse_thiessen) meuse_bbox &lt;- meuse_sf %&gt;% st_bbox() %&gt;% st_as_sfc() meuse_thiessen &lt;- st_intersection(meuse_thiessen, meuse_bbox) meuse_thiessen &lt;- st_as_sf(meuse_thiessen) meuse_thiessen &lt;- st_join(meuse_thiessen, meuse_sf) ggplot() + geom_sf(data = meuse_thiessen, aes(fill = copper)) + geom_sf(data = meuse_sf) + scale_fill_viridis_c() + theme_void() "],["30_Topology.html", "About this section", " About this section In ArcGIS, you create a topology rule by first creating a Feature Dataset in a Geodatabase, and then adding one or more Topology Rules to that Feature Dataset. You are provided with 32 different named rules which you can apply to this feature dataset (see 14.1). In R, you will find only the most commonly used 9 named spatial relations. These are known as “Spatial predicates”. "],["Spatial_Predicates.html", "12 Spatial Predicates 12.1 Named predicates", " 12 Spatial Predicates In Opensource GIS Applications, there is a common standard to describe various relationships between features. They are referred to as “Spatial predicates” and are defined as follows. Take two geometries, a and b: Equals: a and b are equal if their interiors intersect and no part of the interior or boundary of one geometry intersects the exterior of the other Disjoint: a and b are disjoint if they have no point in common (they form a set of disconnected geometries) Touches: a and b touch if they have at least one point in common but their interiors do not intersect Contains: a contains b if no points of b lie in the exterior of a and at least one point of the interior of b lies in the interior of a Covers: a covers b if at least one point of b lies in a, and no point of b lies in the exterior of a Intersects: a and b intersect if the two geometries have at least one point in common Within (inside): a is within b if a lies in the interior of the b CoveredBy: a is covered by b if a lies in b Crosses: a crosses b if they have some but not all interior points in common. Overlaps: a overlaps b if they have some (but not all) points in common and they have the same dimension and the intersection of the interiors of the two geometries has the same dimension as the geometries themselves 12.1 Named predicates 12.1.1 Touches Lets take the example of a chessboard: library(sf) library(dplyr) library(arc2r) data(&quot;chessboard&quot;) chessplot &lt;- ggplot(chessboard) + geom_sf(aes(fill = colour)) + geom_sf_label(aes(label = i)) + scale_x_continuous(breaks = 1:8 - 0.5, labels = letters[1:8]) + scale_y_continuous(breaks = 1:8 - 0.5, labels = 1:8) + scale_fill_manual(values = c(black = &quot;black&quot;, white = &quot;white&quot;)) + theme_void() + theme(legend.position = &quot;none&quot;) chessplot To find out which field touch field number 36, we can write the following line of code: st_touches(chessboard[36, ], chessboard) ## Sparse geometry binary predicate list of length 1, where the predicate was `touches&#39; ## 1: 27, 28, 29, 35, 37, 43, 44, 45 Visually, these are the following fields: sel36 &lt;- st_touches(chessboard[36, ], chessboard)[[1]] chessplot + geom_sf(data = chessboard[36, ], fill = &quot;blue&quot;, alpha = 0.4) + geom_sf(data = chessboard[sel36, ], fill = &quot;red&quot;, alpha = 0.4) "],["DE-9IM.html", "13 DE-9IM", " 13 DE-9IM Thes named spatial predicates covered in chapter 12 are all based on the Dimensionally Extended 9-Intersection Model (DE-9IM). Regarding the chessboard example, we can imagine a chess piece placed on field #36. If this figure was a Queen or a King, all of the fields resulting from st_touches are reachable. In terms of contiguity, this is what is typically called the Queen’s or the King’s Case. However, this is might not the relationship that we are looking for: Say we would want to exclude the diagonal fields from our selection, the way a Rook would move in chess. How can we implement this in R? None of the named topological relationships above (12) correctly describes this case (touches_but_not_at_edges or shares_boundary would be appropriate). In this case, we can use the Dimensionally Extended 9-Intersection Model (DE-9IM) to precisely formulate the relationship we are looking for: the Rooks Case. IN DE-9IM, the intersection of two objects is viewed at three levels for each object: The Interior, the Boundary and the Exterior (\\(3^2= 9\\), hence the name). These levels mean different things for Polygons, Lines or Points, but let’s just look at the simple case for now, polygons (which is the case for our chess fields). Take the example of two partially overlapping squares as shown below: The interior of a polygon is the area inside the polygon. If the two areas overlap (as is the case of blue and red), the result from an intersection would also be a polygon. More formally: The dimesion of \\(I(blue) \\cap I(red)\\) is an area. Areas get a value of 2, Lines 1 and points 0. If there is no intersection, the result equals to FALSE. This was the first of 9 Intersections. Let’s look at the next one: Interior of blue with the boundary of red: The resulting object has a dimenion “line,” i.e. 1. Formally: \\(dim(I(blue) \\cap B(red)) = 1\\). Now just for the sake of looking at the third level (Exerior), let’s look at what this looks like: The resulting object is again an area, i.e. 2. Formally \\(dim(I(blue) \\cap E(red)) = 2\\). If we go through all intersections of Interior, boundry and Exterior of both geometries, we can denote for each comination what type of dimesion we “allow.” This can be either 0 (for points), 1 (for lines) or 3 (for areas) or TRUE (for either of these), or FALSE (for none of these) or * (for \"I dont care). 13.0.0.1 Rooks Case If we go throught the all nine combinations of the DE-9IM, this is what defines the rooks case: Interior Boundary Exterior Interior nothing don’t care don’t care Boundary don’t care Line don’t care Exterior don’t care don’t care don’t care We can now write this into a string, starting from the top left: F***1**** Now that we have this string, we case use st_relate()and specify the string as the pattern we are looking for: ## Sparse geometry binary predicate list of length 1, where the predicate was `relate_pattern&#39; ## 1: 28, 35, 37, 44 Which visually gives us this pattern: Because this was so much fun, let’s also have a look at the opposite, the Bishops Case. 13.0.0.2 Bishops Case Interior Boundary Exterior Interior nothing don’t care don’t care Boundary don’t care Point don’t care Exterior don’t care don’t care don’t care ## Sparse geometry binary predicate list of length 1, where the predicate was `relate_pattern&#39; ## 1: 27, 29, 43, 45 Visually: "],["Topology_Rules.html", "14 Topology Rules", " 14 Topology Rules About this Figure 14.1: The 32 different topolgy rules that you can apply to one or more feature datasets in ArcGIS "],["Polygon.html", "14.1 Polygon", " 14.1 Polygon 14.1.1 Must not overlap Figure 14.2: Source: Esri (2011) In context of DE-9IM, this is a simple case. The polygon interiors should not overlap at all, everything else does not matter. Interior-Interior is the first of the 9 intersections, so the the intersection matrix as a code string would be: 2********. In the case of the example below: set.seed(10) nrows &lt;- 10 circs &lt;- data.frame(id = 1:nrows, x = rnorm(nrows), y = rnorm(nrows)) %&gt;% st_as_sf(coords = c(2, 3)) %&gt;% st_buffer(0.25) circsplot &lt;- ggplot(circs) + geom_sf(fill = &quot;blue&quot;, alpha = 0.3) + geom_sf_text(aes(label = id)) + theme_void() circsplot This gives us a sparse matrix as an output, which is esentially a list with the same length as the x, where each position is a vector of integers with the indicies of the features in y (which may equal to x) where the pattern matches. st_relate(circs, pattern = &quot;2********&quot;) ## Sparse geometry binary predicate list of length 10, where the predicate was `relate_pattern&#39; ## 1: 1, 2, 5 ## 2: 1, 2, 4, 5, 10 ## 3: 3 ## 4: 2, 4 ## 5: 1, 2, 5 ## 6: 6 ## 7: 7 ## 8: 8 ## 9: 9 ## 10: 2, 10 Setting sparse = FALSE returns a crossmatrix of all combinations.W crossmatrix &lt;- st_relate(circs, pattern = &quot;2********&quot;, sparse = FALSE) crossmatrix[1:6, 1:6] # only showing 6 since this prints nicely ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] TRUE TRUE FALSE FALSE TRUE FALSE ## [2,] TRUE TRUE FALSE TRUE TRUE FALSE ## [3,] FALSE FALSE TRUE FALSE FALSE FALSE ## [4,] FALSE TRUE FALSE TRUE FALSE FALSE ## [5,] TRUE TRUE FALSE FALSE TRUE FALSE ## [6,] FALSE FALSE FALSE FALSE FALSE TRUE # Remove the diagonals since it&#39;s simply each feature tested against itself diag(crossmatrix) &lt;- FALSE error &lt;- which(crossmatrix, arr.ind = TRUE) %&gt;% as.vector() %&gt;% unique() circsplot + geom_sf(data = circs[error, ], fill = &quot;red&quot;, alpha = 0.3) 14.1.2 Must not have gaps Figure 14.3: Source: Esri (2011) Lets cosider the North Carolina Dataset for this question. nc = st_read(system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;), quiet = TRUE) ggplot(nc) + geom_sf() + theme_void() The first task is to dissolve all adjecent polygons together nc_union &lt;- st_union(nc) nc_union ## Geometry set for 1 feature ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 ## geographic CRS: NAD27 If the output is a multipolygon as it is the case here, it’s bad news, there are gaps. To check which parts are disconnected from each other, we can cast the multipolygon to a polygon (in ArcGIS Terms “Multipart to singlepart”), add a rowname for each part and colour it by rowname. nc_singlepart &lt;- nc_union %&gt;% st_cast(&quot;POLYGON&quot;) %&gt;% st_sf() %&gt;% mutate(id = 1:n()) ggplot(nc_singlepart) + geom_sf(aes(fill = factor(id))) + labs(fill = &quot;id&quot;) + theme_void() But maybe we can live with these Islands in the state of North Carolina, since this is in fact an accurate representation of reality (the gaps are a result of the Atlantic Ocean). We must now check whether the individual geometries have holes. Here we can make use of the way polygons are defined in sf: geometry with a positive area (two-dimensional); sequence of points form a closed, non-self intersecting ring; the first ring denotes the exterior ring, zero or more subsequent rings denote holes in this exterior ring This means that the length of each Polygon geometry must be 1. A length of 2 or more would mean that there are one (or more) holes in the geometry. We can do this with any of the functions from the apply family, I prefer purrr: map_lgl(nc_singlepart$geometry, ~length(.x) == 1) ## [1] TRUE TRUE TRUE TRUE TRUE TRUE Let’s see what happens if we cut a hole into the polygons holes &lt;- nc_singlepart %&gt;% st_union() %&gt;% st_centroid() %&gt;% st_buffer(0.5) nc_holes &lt;- st_difference(nc_singlepart, holes) ggplot(nc_holes) + geom_sf() + theme_void() map_lgl(nc_holes$geometry, ~length(.x) == 1) ## [1] FALSE TRUE TRUE TRUE TRUE TRUE 14.1.3 Contains point Figure 14.4: Source: Esri (2011) 14.1.4 Contains one Point Figure 14.5: Source: Esri (2011) 14.1.5 Must be covered by feature class of Figure 14.6: Source: Esri (2011) 14.1.6 Boundary must be covered by Figure 14.7: Source: Esri (2011) 14.1.7 Must not overlap with Figure 14.8: Source: Esri (2011) 14.1.8 Must be covered by Figure 14.9: Source: Esri (2011) 14.1.9 Area boundary must be covered by boundary of Figure 14.10: Source: Esri (2011) 14.1.10 Must cover each other Figure 14.11: Source: Esri (2011) "],["Line.html", "14.2 Line", " 14.2 Line 14.2.1 Must not have pseudo nodes Figure 14.12: Source: Esri (2011) 14.2.2 Must not have dangles Figure 14.13: Source: Esri (2011) 14.2.3 Must not self overlap Figure 14.14: Source: Esri (2011) 14.2.4 Must not overlap Figure 14.15: Source: Esri (2011) 14.2.5 Must not self-intersect Figure 14.16: Source: Esri (2011) 14.2.6 Must not intersect Figure 14.17: Source: Esri (2011) 14.2.7 Must be single part Figure 14.18: Source: Esri (2011) 14.2.8 Must not intersect with Figure 14.19: Source: Esri (2011) 14.2.9 Must be covered by feature class of Figure 14.20: Source: Esri (2011) 14.2.10 Must not intersect or touch interior Figure 14.21: Source: Esri (2011) 14.2.11 Must be covered by boundary of Figure 14.22: Source: Esri (2011) 14.2.12 Must not intersect or touch interior with Figure 14.23: Source: Esri (2011) 14.2.13 Must be properly inside Figure 14.24: Source: Esri (2011) 14.2.14 Must not overlap with Figure 14.25: Source: Esri (2011) 14.2.15 Endpoint must be covered by Figure 14.26: Source: Esri (2011) "],["Point.html", "14.3 Point", " 14.3 Point 14.3.1 Must coincide with Figure 14.27: Source: Esri (2011) 14.3.2 Must be disjoint Figure 14.28: Source: Esri (2011) 14.3.3 Must be covered by endpoint of Figure 14.29: Source: Esri (2011) 14.3.4 Point must be covered by line Figure 14.30: Source: Esri (2011) 14.3.5 Must be properly inside Figure 14.31: Source: Esri (2011) 14.3.6 Must be covered by boundary of Figure 14.32: Source: Esri (2011) "],["Line_or_Polygon.html", "14.4 Line or Polygon", " 14.4 Line or Polygon 14.4.1 Must be larger than cluster tolarance Figure 14.33: Source: Esri (2011) "],["Progress.html", "A Progress", " A Progress We document the state of our project by providing an estimation per Tool. Tool Progress Image Analyst Map Algebra Raster Calculator 100 Spatial Analyst Density Kernel Density 100 Line Density 0 Point Density 0 Map Algebra Raster Calculator 100 Neighborhood Focal Statistics 100 Reclass Reclassify 100 Surface Aspect 100 Slope 100 Viewshed 0 Zonal Zonal Statistics 100 Tabulate Area 0 Zonal Fill 0 Zonal Geometry 0 Zonal Histogram 0 Zonal Statistics as Table 0 Conditional Con 0 Pick 0 Set Null 0 Distance Corridor 0 Distance Accumulation 0 Extraction Extract by Attributes 0 Extract by Circle 0 Extract by Mask 0 Extract by Points 0 Extract by Polygon 0 Extract by Rectangle 0 Extract Multi Values to Points 0 Extract Values to Points 0 Sample 0 Generalization Aggregate 0 Boundary Clean 0 Expand 0 Majority Filter 0 Nibble 0 Region Group 0 Shrink 0 Thin 0 Interpolation IDW 0 Kriging 0 Natural Neighbor 0 Spline 0 Math (general) Abs 0 Divide 0 Exp 0 Exp10 0 Exp2 0 Float 0 Int 0 Ln 0 Log10 0 Log2 0 Minus 0 Mod 0 Negate 0 Plus 0 Power 0 Round Down 0 Round Up 0 Square 0 Square Root 0 Times 0 Overlay Weighted Sum 0 Analysis Proximity Buffer 100 Create Thiessen Polygons 0 Generate Near Table 0 Multiple Ring Buffer 0 Near 0 Extract Clip 90 Select 0 Split 0 Split By Attributes 0 Table Select 0 Overlay Erase 0 Symmetrical Difference 0 Intersect 0 Update 0 Identity 0 Remove Overlap 0 Weighted Sum 0 Union 0 Count Overlapping Features 0 Fuzzy Membership 0 Fuzzy Overlay 0 Weighted Overlay 0 Spatial Join 0 Data Management General Merge 100 Dissolve 100 Sort 90 Rename 0 Find Identical 0 Append 0 Projections and Transformations Project 100 Project Raster 100 Define Projection 90 Layers and Table Views toolset Select by Attribute 100 Select by Location 70 Apply Symbology From Layer 0 Make Feature Layer 0 Make Image Server Layer 0 Make Mosaic Layer 0 Make Query Table 0 Make Query Layer 0 Make Raster Layer 0 Make Raster Catalog Layer 0 Make Table View 0 Make WCS Layer 0 Make XY Event Layer 0 Save To Layer File 0 Joins and Relates Add Join 50 Add Relate 50 Join Field 50 Remove Join 50 Remove Relate 50 Sampling Generate Tessellation 100 Create Random Points 100 Generate Points Along Lines 50 Create Fishnet 10 Generate Rectangles Along Lines 0 Generate Transects Along Lines 0 Raster Copy Raster 0 Create Random Raster 0 Create Raster Dataset 0 Generate Raster From Raster Function 0 Spatial Statistics Mapping Clusters Cluster and Outlier Analysis (Anselin Local Moran’s I) 0 "],["bibliography.html", "References", " References Allaire, J. J., Christopher Gandrud, Kenton Russell, and CJ Yetman. 2017. networkD3: D3 JavaScript Network Graphs from r. https://CRAN.R-project.org/package=networkD3. Allaire, JJ, Yihui Xie, Jonathan McPherson, Javier Luraschi, Kevin Ushey, Aron Atkins, Hadley Wickham, Joe Cheng, Winston Chang, and Richard Iannone. 2020. Rmarkdown: Dynamic Documents for r. https://github.com/rstudio/rmarkdown. Appelhans, Tim, Florian Detsch, Christoph Reudenbach, and Stefan Woellauer. 2020. Mapview: Interactive Viewing of Spatial Data in r. https://github.com/r-spatial/mapview. Bivand, Roger, Tim Keitt, and Barry Rowlingson. 2021. Rgdal: Bindings for the Geospatial Data Abstraction Library. https://CRAN.R-project.org/package=rgdal. Esri. 2011. ArcGIS Geodatabase Topology Rules. https://pro.arcgis.com/en/pro-app/latest/help/editing/pdf/topology_rules_poster.pdf. ———. 2020. ArcGIS Pro Geoprocessing Tool Reference. https://pro.arcgis.com/en/pro-app/latest/tool-reference/main/arcgis-pro-tool-reference.htm. Glur, Christoph. 2020. Data.tree: General Purpose Hierarchical Data Structure. http://github.com/gluc/data.tree. GrÃ¤ler, Benedikt, Edzer Pebesma, and Gerard Heuvelink. 2016. “Spatio-Temporal Interpolation Using Gstat.” The R Journal 8: 204–18. https://journal.r-project.org/archive/2016/RJ-2016-014/index.html. Hijmans, Robert J. 2020. Raster: Geographic Data Analysis and Modeling. https://rspatial.org/raster. ———. 2021. Terra: Spatial Data Analysis. https://rspatial.org/terra. Lovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2021. Geocomputation with r. CRC Press. https://geocompr.robinlovelace.net. Ooms, Jeroen, and Jim Hester. 2020. Spelling: Tools for Spell Checking in r. https://CRAN.R-project.org/package=spelling. Pebesma, Edzer. 2018. “Simple Features for R: Standardized Support for Spatial Vector Data.” The R Journal 10 (1): 439–46. https://doi.org/10.32614/RJ-2018-009. ———. 2021a. Sf: Simple Features for r. https://CRAN.R-project.org/package=sf. ———. 2021b. Stars: Spatiotemporal Arrays, Raster and Vector Data Cubes. https://CRAN.R-project.org/package=stars. Pebesma, Edzer J. 2004. “Multivariable Geostatistics in S: The Gstat Package.” Computers &amp; Geosciences 30: 683–91. Pebesma, Edzer, and Benedikt Graeler. 2020. Gstat: Spatial and Spatio-Temporal Geostatistical Modelling, Prediction and Simulation. https://github.com/r-spatial/gstat/. Tennekes, Martijn. 2018. “tmap: Thematic Maps in R.” Journal of Statistical Software 84 (6): 1–39. https://doi.org/10.18637/jss.v084.i06. ———. 2021. Tmap: Thematic Maps. https://github.com/mtennekes/tmap. Urbanek, Simon. 2020. Tiff: Read and Write TIFF Images. http://www.rforge.net/tiff/. Wickham, Hadley. 2019. Tidyverse: Easily Install and Load the Tidyverse. https://CRAN.R-project.org/package=tidyverse. Wickham, Hadley, Mara Averick, Jennifer Bryan, Winston Chang, Lucy D’Agostino McGowan, Romain FranÃ§ois, Garrett Grolemund, et al. 2019. “Welcome to the tidyverse.” Journal of Open Source Software 4 (43): 1686. https://doi.org/10.21105/joss.01686. Xie, Yihui. 2016. Bookdown: Authoring Books and Technical Documents with R Markdown. Boca Raton, Florida: Chapman; Hall/CRC. https://github.com/rstudio/bookdown. ———. 2020. Bookdown: Authoring Books and Technical Documents with r Markdown. https://github.com/rstudio/bookdown. Xie, Yihui, J. J. Allaire, and Garrett Grolemund. 2018. R Markdown: The Definitive Guide. Boca Raton, Florida: Chapman; Hall/CRC. https://bookdown.org/yihui/rmarkdown. Xie, Yihui, Christophe Dervieux, and Emily Riederer. 2020. R Markdown Cookbook. Boca Raton, Florida: Chapman; Hall/CRC. https://bookdown.org/yihui/rmarkdown-cookbook. "]]
