[
["index.html", "Burning Bridges An intro to spatial-R for ArcGIS users 1 Abstract", " Burning Bridges An intro to spatial-R for ArcGIS users Nils Ratnaweera 1 Abstract This is a ressource for people coming from ArcGIS who want to do spatial stuff (Analysis, Visualization) in R. This ressource should provide some help on this journey. Who this book is for: you’ve worked primarily with ArcGIS and would like to transition to R you have some experience with R you don’t mind working with the tidyverse "],
["foreword.html", "2 Foreword", " 2 Foreword I had long since thought about the necessity of a resource which helps ArcGIS users transition to R or Python. I had tweeted this without getting much reception, and and one point just decided to start my own resource. I, like many, learned GIS in University using ArcGIS. It took me a considerable amount of time to learn that there are alternatives to ArcGIS, but not much longer to realize that I’m more attracted to these alternatives than to ArcGIS. When you transition from a proprietary Software like ArcGIS to FOSS, you have to relearn many of the concepts because the proprietary software usually does not adhere to common standards. There are already a great many spatial-R Resources out there, and I’m not planning to rewrite everything that has been written. My aim is just to provide a resource for people looking to do spatial stuff in R, but only know the ArcGIS-Term for it. This might mean that for some topics, I will simply provide a link to an existing resource. "],
["making-interactive-maps.html", "3 Making Interactive Maps", " 3 Making Interactive Maps Probably one of the first things you want to do when working with a dataset is visualizing it spatially. This is basically always the first thing you do in ArcGIS. So how do you this in R? If your aim is to explore the data, to just get a feel for it, your map needs to: allow pan and zoom display attribute information in popups provide a background map be easy to make Before you start making maps however, you will have to familiarize yourself with importing raster or vector data into R in the first place. For Vector data, you can read chapter 2.2 Vector data from the book “Geocomputation with R”. The next chapter 2.3 Raster data provides a very good overview on rasterdata in R There are many packages that provide these features. leaflet mapview tmap In terms of simplicity, versatility and scalability tmap is one of the best in my option. "],
["introduction-to-tmap.html", "3.1 Introduction to tmap", " 3.1 Introduction to tmap To see how it works, import the usual libraries and the North Carolina Sample data. library(sf) ## Warning: package &#39;sf&#39; was built under R version 3.6.3 ## Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1 library(tidyverse) ## Warning: package &#39;tidyverse&#39; was built under R version 3.6.2 ## -- Attaching packages ----------------------------------------------------------- tidyverse 1.3.0 -- ## v ggplot2 3.2.1 v purrr 0.3.3 ## v tibble 2.1.3 v dplyr 0.8.5 ## v tidyr 1.0.0 v stringr 1.4.0 ## v readr 1.3.1 v forcats 0.4.0 ## Warning: package &#39;ggplot2&#39; was built under R version 3.6.2 ## Warning: package &#39;tidyr&#39; was built under R version 3.6.2 ## Warning: package &#39;readr&#39; was built under R version 3.6.2 ## Warning: package &#39;purrr&#39; was built under R version 3.6.2 ## Warning: package &#39;dplyr&#39; was built under R version 3.6.3 ## -- Conflicts -------------------------------------------------------------- tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(tmap) ## Warning: replacing previous import &#39;sf::st_make_valid&#39; by ## &#39;lwgeom::st_make_valid&#39; when loading &#39;tmap&#39; nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;),quiet = TRUE) Here’s how the data looks in base plot: tmap has two modes: a static mode for printable maps (called plot) and a dynamic mode for exploratory, interactive maps (called view). We want the latter for now, so we switch to the dynamic mode with: tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing tmap has based it’s syntax loosely on ggplot2: Mainly, layer are added with + and aesthetics are specified within each layer. tm_shape(nc) + tm_polygons() ## Warning in `$.crs`(gm$shape.master_crs, &quot;proj4string&quot;): CRS uses proj4string, ## which is deprecated. ## Warning in `$.crs`(crs, &quot;proj4string&quot;): CRS uses proj4string, which is ## deprecated. You can have a look at the attributes of each feature by clicking on it. To view the entire attribute table, you can print nc to the console, or have a look at it with View(nc) if you are using Rstudio. Check the following resources for more information: https://github.com/mtennekes/tmap https://geocompr.robinlovelace.net/adv-map.html#interactive-maps "],
["making-statics-maps.html", "4 Making Statics Maps", " 4 Making Statics Maps Probably the quickest way to visualize spatial data is with base::plot(). It can handle raster as well as vector data and usually needs not more than this one command, plot(). This can be great to get a first, quick look at the data but in my opinion, base plot will not get you very far. To make nice static maps, you are better served with ggplot2 or with tmap. There are arguments for both packages, and you might just end up using both. Before you start making maps however, you will have to familiarize yourself with importing raster or vector data into R in the first place. For Vector data, you can read chapter 2.2 Vector data from the book “Geocomputation with R”. The next chapter 2.3 Raster data provides a very good overview on rasterdata in R "],
["static-maps-with-ggplot2.html", "4.1 Static maps with ggplot2", " 4.1 Static maps with ggplot2 4.1.1 Basics library(sf) library(tidyverse) eire &lt;- read_sf(&quot;sample_data/spData/eire.shp&quot;) The most basic plot consists of a ggplot() initiation and a single layer. In case of sf data, you can add a layer with geom_sf(). If the coordinate system is unknown, the axes will be labelled with the numerical values of the coorindates. st_crs(eire) ## Coordinate Reference System: NA ggplot(eire) + geom_sf() However, if the coordinate system is known, the WGS84 Coordinates are labelled and used as the major and minor grid lines. eire &lt;- st_set_crs(eire, &quot;+proj=utm +zone=30 +ellps=airy +units=km&quot;) ggplot(eire) + geom_sf() As always in ggplot, if you want to use a column from your dataset as an input for, say, colour, you need to specify this with aes(): ggplot(eire) + geom_sf(aes(fill = INCOME)) There are various ways to beautify this simple plot: ggplot(eire) + geom_sf(aes(fill = log(INCOME)), colour = &quot;grey&quot;) + labs(title = &quot;Counties of the Irish Republic&quot;, subtitle = expression(&quot;Distribution of Income (log&quot;[10]*&quot;)&quot;), fill = &quot;&quot;) + scale_fill_viridis_c() + theme_void() + theme(legend.position = &quot;bottom&quot;) 4.1.2 Adding Raster Maps Files (geotiffs) While vector data is very easily implemented in ggplot2, rasterdata is a little harder. Its complicated enough with standard Raster Data, and even more so with raster maps. There are two packages that facilitate the combination of rastermaps and ggplot: rasterVis RStoolbox However, we will do without these packages to learn more on how rasters work and be as flexible as possible. If you don’t have the time or patience to read through the explanation, the following function takes a path to a raster and returns a dataframe with x/y coordinates as well as a column with the hex colours for the according cell. rastermap_to_dataframe &lt;- function(path) { require(tiff) require(raster) raster_file &lt;- raster::brick(path) bands_n &lt;- nbands(raster_file) if(bands_n == 1){ raster_indexed &lt;- readTIFF(path,indexed = TRUE) raster_colormap &lt;- attr(raster_indexed,&quot;color.map&quot;) raster_colormap_hex &lt;- rgb(raster_colormap[1,],raster_colormap[2,],raster_colormap[3,]) raster_df &lt;- data.frame(coordinates(raster_file), values = raster_colormap_hex[getValues(raster_file)+1]) } else if(bands_n == 3){ raster_df &lt;- data.frame( coordinates(raster_file), values = rgb(values(raster_file[[1]]),values(raster_file[[2]]),values(raster_file[[3]]),maxColorValue = 255) ) } return(raster_df) } 4.1.2.1 With Colours Tif files with colours can either be single band or include multiple bands in a single tif file. These need to be treated differently. Let’s take two variants of the swiss raster map 1:50k map. One is a single band dataset, the other a 3-band dataset. library(raster) ## Warning: package &#39;raster&#39; was built under R version 3.6.3 ## Loading required package: sp ## Warning: package &#39;sp&#39; was built under R version 3.6.3 ## ## Attaching package: &#39;raster&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## select ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract path_1b &lt;- &quot;sample_data/SMR_Musterdaten/SMR50_LV95_KOMB_Mosaic.tif&quot; path_3b &lt;- &quot;sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif&quot; raster(path_1b) ## class : RasterLayer ## dimensions : 800, 800, 640000 (nrow, ncol, ncell) ## resolution : 2.5, 2.5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/bako/Desktop/Projekte/All_thing_R_Spatial/github/spatialR_for_ArcGIS_Users/sample_data/SMR_Musterdaten/SMR50_LV95_KOMB_Mosaic.tif ## names : SMR50_LV95_KOMB_Mosaic ## values : 0, 255 (min, max) raster(path_3b) ## class : RasterLayer ## band : 1 (of 3 bands) ## dimensions : 400, 400, 160000 (nrow, ncol, ncell) ## resolution : 5, 5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/bako/Desktop/Projekte/All_thing_R_Spatial/github/spatialR_for_ArcGIS_Users/sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif ## names : SMR50_LV95_KREL_10L_Mosaic ## values : 0, 255 (min, max) As you can see in the output of raster(path_3b), only one of the 3 bands was imported with raster::raster. In the case of multiband rasters, it’s better to use raster::brick: map_1b &lt;- raster(path_1b) map_3b &lt;- brick(path_3b) 4.1.2.1.1 Singleband A singleband RasterLayer can be regarded as vector of numeric values arranged in a matrix with some additional metadata. The metadata can be view with str(), the values can be obtained with getValues(). str(map_1b) ## Formal class &#39;RasterLayer&#39; [package &quot;raster&quot;] with 12 slots ## ..@ file :Formal class &#39;.RasterFile&#39; [package &quot;raster&quot;] with 13 slots ## .. .. ..@ name : chr &quot;C:\\\\Users\\\\bako\\\\Desktop\\\\Projekte\\\\All_thing_R_Spatial\\\\github\\\\spatialR_for_ArcGIS_Users\\\\sample_data\\\\SMR_Mu&quot;| __truncated__ ## .. .. ..@ datanotation: chr &quot;INT1U&quot; ## .. .. ..@ byteorder : chr &quot;little&quot; ## .. .. ..@ nodatavalue : num -Inf ## .. .. ..@ NAchanged : logi FALSE ## .. .. ..@ nbands : int 1 ## .. .. ..@ bandorder : chr &quot;BIL&quot; ## .. .. ..@ offset : int 0 ## .. .. ..@ toptobottom : logi TRUE ## .. .. ..@ blockrows : int 1 ## .. .. ..@ blockcols : int 800 ## .. .. ..@ driver : chr &quot;gdal&quot; ## .. .. ..@ open : logi FALSE ## ..@ data :Formal class &#39;.SingleLayerData&#39; [package &quot;raster&quot;] with 13 slots ## .. .. ..@ values : logi(0) ## .. .. ..@ offset : num 0 ## .. .. ..@ gain : num 1 ## .. .. ..@ inmemory : logi FALSE ## .. .. ..@ fromdisk : logi TRUE ## .. .. ..@ isfactor : logi FALSE ## .. .. ..@ attributes: list() ## .. .. ..@ haveminmax: logi TRUE ## .. .. ..@ min : num 0 ## .. .. ..@ max : num 255 ## .. .. ..@ band : int 1 ## .. .. ..@ unit : chr &quot;&quot; ## .. .. ..@ names : chr &quot;SMR50_LV95_KOMB_Mosaic&quot; ## ..@ legend :Formal class &#39;.RasterLegend&#39; [package &quot;raster&quot;] with 5 slots ## .. .. ..@ type : chr(0) ## .. .. ..@ values : logi(0) ## .. .. ..@ color : logi(0) ## .. .. ..@ names : logi(0) ## .. .. ..@ colortable: chr [1:256] &quot;#000000&quot; &quot;#FFFFFF&quot; &quot;#D6EBD8&quot; &quot;#BDDFB5&quot; ... ## ..@ title : chr(0) ## ..@ extent :Formal class &#39;Extent&#39; [package &quot;raster&quot;] with 4 slots ## .. .. ..@ xmin: num 2599000 ## .. .. ..@ xmax: num 2601000 ## .. .. ..@ ymin: num 1196000 ## .. .. ..@ ymax: num 1198000 ## ..@ rotated : logi FALSE ## ..@ rotation:Formal class &#39;.Rotation&#39; [package &quot;raster&quot;] with 2 slots ## .. .. ..@ geotrans: num(0) ## .. .. ..@ transfun:function () ## ..@ ncols : int 800 ## ..@ nrows : int 800 ## ..@ crs :Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot ## .. .. ..@ projargs: chr NA ## ..@ history : list() ## ..@ z : list() head(getValues(map_1b),50) ## [1] 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 ## [26] 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 extent(map_1b) ## class : Extent ## xmin : 2599000 ## xmax : 2601000 ## ymin : 1196000 ## ymax : 1198000 The first 50 cells of this RasterLayer contain the value 37. This value 37 is associated with a specific colour, which can be viewd in the colortable of the RasterLayer. coltab &lt;- colortable(map_1b) head(coltab) ## [1] &quot;#000000&quot; &quot;#FFFFFF&quot; &quot;#D6EBD8&quot; &quot;#BDDFB5&quot; &quot;#A5CF91&quot; &quot;#53A935&quot; scales::show_col(coltab,labels = FALSE) In order to plot this RasterLayer in ggplot, we need to convert it into a dataframe. You can imagine that this is converting the wide matrix into a very long table with three columns: x and y coordinates of the lower left corner of each cell and a value specifying what the cell holds. map_1b_df &lt;- data.frame(coordinates(map_1b),values = getValues(map_1b)) head(map_1b_df) ## x y values ## 1 2599001 1197999 37 ## 2 2599004 1197999 37 ## 3 2599006 1197999 37 ## 4 2599009 1197999 37 ## 5 2599011 1197999 37 ## 6 2599014 1197999 37 We can now use the values column in ggplot2 to specify the fill aesthetic. If we then pass the colortable as our fill values, the colours will be matched correctly. However we need two additional tricks: name the colourtable to make sure the correct colours are correct to the according values wrap the values column in factor() so that the ggplot2 does not mistake the numeric values as a continuous scale: names(coltab) &lt;- 0:255 # 1:256 would be wrong by 1 ggplot() + geom_raster(data = map_1b_df, aes(x,y, fill = factor(values))) + scale_fill_manual(values = coltab) + theme(legend.position = &quot;none&quot;) + coord_equal() Note that there are thee ways to plot this type of data in ggplot2: geom_rect, geom_tile and geom_raster. The latter is “a high performance special case for when all the tiles are the same size” (see the docs. Alternatively, you can add the hex colourcode to the dataframe and use scale_fill_identitiy(). map_1b_df &lt;- mutate(map_1b_df, colorvalue = coltab[values+1]) ggplot() + geom_raster(data = map_1b_df, aes(x,y, fill = colorvalue)) + scale_fill_identity() + theme(legend.position = &quot;none&quot;) + coord_equal() The big drawback of using ggplot2 in this way: you cannot add a second layer with a fill aesthetic, since ggplot2 only allows one per plot. 4.1.2.1.2 Multiple bands In case of a 3-Band Raster Brick, each layer holds a value of 0 to 255 representing colours in the RGB colour model. Usually, the first layer represents Red, the second Green and the third Blue. We can subset the RasterBrick into the individual RasterLayers using double brackets ([[1]] for the first layer). map_3b ## class : RasterBrick ## dimensions : 400, 400, 160000, 3 (nrow, ncol, ncell, nlayers) ## resolution : 5, 5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/bako/Desktop/Projekte/All_thing_R_Spatial/github/spatialR_for_ArcGIS_Users/sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif ## names : SMR50_LV95_KREL_10L_Mosaic.1, SMR50_LV95_KREL_10L_Mosaic.2, SMR50_LV95_KREL_10L_Mosaic.3 ## min values : 0, 0, 0 ## max values : 255, 255, 255 map_3b[[1]] ## class : RasterLayer ## band : 1 (of 3 bands) ## dimensions : 400, 400, 160000 (nrow, ncol, ncell) ## resolution : 5, 5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/bako/Desktop/Projekte/All_thing_R_Spatial/github/spatialR_for_ArcGIS_Users/sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif ## names : SMR50_LV95_KREL_10L_Mosaic.1 ## values : 0, 255 (min, max) As with the singleband raster, we can extract the Values (this time RGB-Values) of each layer with getValues(). head(values(map_3b[[1]]),50) ## [1] 27 27 31 27 67 124 124 124 124 123 123 123 122 123 122 66 27 57 97 ## [20] 113 123 123 124 100 68 68 68 68 68 68 68 36 27 27 27 27 38 117 ## [39] 105 97 97 100 111 119 54 27 27 27 27 66 Again like with the single band raster, we now transform the Raster into a dataframe, this time storing the rgb values in columns (instead of the hex values as before). map_3b_df &lt;- data.frame( coordinates(map_3b), r = values(map_3b[[1]]), g = values(map_3b[[2]]), b = values(map_3b[[3]])) head(map_3b_df) ## x y r g b ## 1 2599003 1197998 27 26 35 ## 2 2599008 1197998 27 26 35 ## 3 2599013 1197998 31 28 36 ## 4 2599018 1197998 27 26 35 ## 5 2599023 1197998 67 59 58 ## 6 2599028 1197998 124 114 110 With the function rbg() we can transform values into hex-codes. rgb(10,10,10,maxColorValue = 255) ## [1] &quot;#0A0A0A&quot; ggplot() + geom_raster(data = map_3b_df, aes(x,y,fill = rgb(r,g,b,maxColorValue = 255))) + scale_fill_identity() + coord_equal() Tipp: if your file is to large and ggplot has trouble plotting it fast, you can use aggregate to reduce the resolution map_3b_lowres &lt;- raster::aggregate(map_3b, fact = 5) 4.1.2.2 Greyscale In greyscale maps, raster cannot find a associated colortable to match the values to rgb or hex colours. map_grey_path &lt;- &quot;sample_data/SMR_Musterdaten/SMR50_LV95_KGRS_Mosaic.tif&quot; map_grey &lt;- raster(map_grey_path) head(getValues(map_grey)) ## [1] 31 31 31 31 31 31 head(colortable(map_grey)) ## [1] &quot;#000000&quot; &quot;#FFFFFF&quot; &quot;#F4F4F4&quot; &quot;#E7E7E7&quot; &quot;#D3D2D3&quot; &quot;#CAC9CA&quot; However, the package tiff can find the rgb values of a tiff, we just need to set indexed = TRUE and get the color.map attribute of the output: library(tiff) index &lt;- readTIFF(map_grey_path,indexed = TRUE) colormap &lt;- attr(index,&quot;color.map&quot;) colormap[,1:8] # only showing the first 8 columns (of 256) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 0 1 0.9568627 0.9058824 0.8274510 0.7921569 0.7843137 0.7725490 ## [2,] 0 1 0.9568627 0.9058824 0.8235294 0.7882353 0.7803922 0.7686275 ## [3,] 0 1 0.9568627 0.9058824 0.8274510 0.7921569 0.7843137 0.7725490 This is an index with three rows (Red, Green and Blue) and 265 columns (with are the Values from getValues()). We can now use rgb() to turn this matrix into a vector of 265 hex colours: coltab &lt;- rgb(colormap[1,],colormap[2,],colormap[3,]) scales::show_col(coltab,labels = FALSE) Like before, we now turn the RasterLayer into a dataframe and use the Values and the newly created colortable to assign the correct values: map_grey_df &lt;- data.frame(coordinates(map_grey),values = getValues(map_grey)) names(coltab) &lt;- 0:255 ggplot() + geom_raster(data = map_grey_df, aes(x,y, fill = factor(values))) + scale_fill_manual(values = coltab) + theme(legend.position = &quot;none&quot;) + coord_equal() "],
["chapter-overview.html", "5 Chapter overview", " 5 Chapter overview "],
["select-by-attribute.html", "5.1 Select by Attribute", " 5.1 Select by Attribute One of the popular approaches in ArcGIS pro for selecting features in a layer is by using an attribute query. The action is performed using the Select By Attributes tool. Select By Attributes tool allows us to provide a SQL query expression to select features that match the selection criteria. R on the other hand offers quite easy and straightforward options to perform similar operations. Let’s examine one of them. As a first step, we might want to import a shapefile. To do so, we can use sf package to work with vector data in R. Important to know is that the rgdal package automatically loads when sf is loaded. In the code snippet below, we read the shapefile, which represents the parking spots for bicycles within the canton of Zurich. The dataset is publicly available for download in the following link: (https://opendata.swiss/en/dataset/veloparkierungsanlagen). library(sf) library(ggplot2) parkBikes &lt;- st_read(&quot;sample_data/Kanton_Zuerich/Veloparkierungsanlagen/OGD_VELOPARKIERANLAGEN_P.shp&quot;) ## Reading layer `OGD_VELOPARKIERANLAGEN_P&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\Kanton_Zuerich\\Veloparkierungsanlagen\\OGD_VELOPARKIERANLAGEN_P.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 511 features and 28 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2669965 ymin: 1229454 xmax: 2707390 ymax: 1280235 ## projected CRS: CH1903+ / LV95 After importing the dataset, let’s say we want to filter it by selecting only the parking spots that lie within a specific municipality (Gemeinde) in the canton of Zurich. More specifically, we will select only the parking spots within the municipality of Winterthur. For the aforementioned operation, R offers the function filter(), which lies within the dplyr package. This functions works as follows: filter(dataset, condition) library(dplyr) parkBikes_winti &lt;- filter(parkBikes,GEMEINDE == &quot;Winterthur&quot;) The operation above produces the same outcome as the one depicted in the figure below 5.1. Figure 5.1: Select by Attributes in ArcGIS pro "],
["select-by-location.html", "5.2 Select by Location", " 5.2 Select by Location One of the most commonly used operations in ArcGIS pro is the process of selecting features of a spatial object (layer) based on whether or not these relate spatially to another object (layer). This process is also referred as spatial subsetting. In ArcGIS pro this can be preformed in various ways using the Select by Location tool. In R the same operation is, on a first level, performed using the square bracket ([]) operator from the base R package. An example of spatial subsetting could be the following. Let’s assume we have as a shapefile (polygon dataframe) with all the municipalities (Gemeinde) of the Canton of Zurich. Furthermore, we are also using a shapefile in the form of a point dataframe, which represents all the “swimming spots” (Badenplätze) in the same spatial region (Canton of Zurich). So, ultimately, our goal is to find out the “swimming spots” that lie within a specific municipality of the Canton of Zurich. # Minicipalities (Gemeinde) in Canton Zurich gemeinde_ZH &lt;- st_read(&quot;sample_data/Kanton_Zuerich/Gemeinde_ZH.shp&quot;) ## Reading layer `Gemeinde_ZH&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\Kanton_Zuerich\\Gemeinde_ZH.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 166 features and 7 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 2669245 ymin: 1223896 xmax: 2716900 ymax: 1283343 ## projected CRS: CH1903+ / LV95 # &quot;Swimming&quot; spots in the Canton of Zurich swimmSpots &lt;- st_read(&quot;sample_data/Kanton_Zuerich/Badeplaetze_ZH.shp&quot;) ## Reading layer `Badeplaetze_ZH&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\Kanton_Zuerich\\Badeplaetze_ZH.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 71 features and 6 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2671636 ymin: 1226720 xmax: 2710101 ymax: 1282760 ## projected CRS: CH1903+ / LV95 After importing and depicting the “swimming spots” throughout the canton of Zurich, let’s assume we want to check if and how many of them lie within the Municipality of Richterswil. To do so, we will perform an operation, which belongs to the category of Spatial subsetting. swimmSpots_richt &lt;- swimmSpots[richterswil, ,op = st_within] The operation above is based on the following rule: x[y, ,operation], where: div.note { background-color:#f0f0f0; border-radius: 5px; padding: 20px;} x and y are the spatial objects for which we want to investigate if there is a spatial relationship (x is the target feature, while y is the source one) the second argument [, ,] within the brackets denotes the column number we want to retrieve from the spatial subsetting. In our example this argument was empty, which means we wanted to retrieve all rows for every attribute column. the third argument [op = ] specifies the spatial operation we want to perform. In the example above, the goal was to find out how many subset features of the target object swimmSpots lie withing the source spatial object richterswil. For that reason we chose the function st_within(). Depending on what we want to examine, we choose the respective function. "],
["spatial-intersections.html", "5.3 Spatial Intersections", " 5.3 Spatial Intersections 5.3.1 Clip operation bahn_haltestelle_ch &lt;- st_read(&quot;sample_data/other/Haltestelle_Bahn_CH.shp&quot;) ## Reading layer `Haltestelle_Bahn_CH&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\other\\Haltestelle_Bahn_CH.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 3134 features and 16 fields ## geometry type: POINT ## dimension: XYZ ## bbox: xmin: 2488908 ymin: 1076850 xmax: 2817389 ymax: 1289090 ## z_range: zmin: 194.905 zmax: 3453.525 ## projected CRS: CH1903+ / LV95 kantonsgebiet &lt;- st_read(&quot;sample_data/other/Kantonsgebiet.shp&quot;) ## Reading layer `Kantonsgebiet&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\other\\Kantonsgebiet.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 51 features and 22 fields ## geometry type: POLYGON ## dimension: XYZ ## bbox: xmin: 2485410 ymin: 1075268 xmax: 2833858 ymax: 1295934 ## z_range: zmin: 193.51 zmax: 4613.729 ## projected CRS: CH1903+ / LV95 tm_shape(kantonsgebiet) + tm_polygons(&quot;#f0f0f0&quot;) + tm_shape(bahn_haltestelle_ch) + tm_dots(col = &quot;#e34a33&quot;,size = 0.1, alpha = 0.5) + tm_shape(kantonsgebiet) + tm_borders(col = &quot;black&quot;) + tm_layout(frame = F) We want now to analyse the situation at a particular area. So we are going to create an index with the specific cantons we are interested in. index &lt;- kantonsgebiet$name == &quot;Zürich&quot; | kantonsgebiet$name == &quot;St. Gallen&quot; | kantonsgebiet$name == &quot;Thurgau&quot; | kantonsgebiet$name == &quot;Aargau&quot; kantons_aOi &lt;- kantonsgebiet[index,] hal_clipped &lt;- st_intersection(kantons_aOi,bahn_haltestelle_ch) Plot the result from the clipping operation tm_shape(kantons_aOi) + tm_polygons(&quot;#f0f0f0&quot;) + tm_shape(hal_clipped) + tm_dots(col = &quot;#e34a33&quot;,size = 0.1, alpha = 0.5) + tm_shape(kantons_aOi) + tm_borders() + tm_layout(frame = F) &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD So, ultimately, as we can see above, the st_intersection function creates a result where the point dataset is precisely “clipped” based on the area of interest. 5.3.2 Buffer operation One of the most commonly used operations in ArcGIS pro is the one called Buffer. This operation provides a very convenient way of identifying areas of interest lying in the neighborhood of an existing spatial feature. In R the same action can be performed using the st_buffer function in sf. Below we introduce a line spatial feature that depicts all the mountain bike routes in Switzerland. ## Reading layer `mountainBikes_routes&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\other\\mountainBikes_routes.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 286 features and 29 fields ## geometry type: LINESTRING ## dimension: XYZ ## bbox: xmin: 2497570 ymin: 1077136 xmax: 2836678 ymax: 1296227 ## z_range: zmin: 197.367 zmax: 2860.725 ## projected CRS: CH1903+ / LV95 We focus, as an area of interest, on the canton of Valais. Consequently, we might be interested in identifying all the areas in a radius of 1000 m around these bike routes. Selecting the canton of Valais Apply a buffer of 1000m on each of the mountain bike routes within the canton of Valais routes_buffer &lt;- st_buffer(mountainBikes_routes_valais,1000) tm_shape(canton_valais) + tm_polygons() + tm_shape(mountainBikes_routes_valais) + tm_lines(col = &quot;#e34a33&quot;) + tm_shape(routes_buffer) + tm_polygons(col = &quot;blue&quot;, alpha = 0.2) + tm_shape(canton_valais) + tm_borders(col = &quot;black&quot;) + tm_layout(frame = F) So, ultimately, as we can see above, the st_intersection function creates a result where the point dataset is precisely “clipped” based on the area of interest. "]
]
