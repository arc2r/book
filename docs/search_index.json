[["index.html", "Burning Bridges An intro to spatial-R for ArcGIS users 1 Abstract", " Burning Bridges An intro to spatial-R for ArcGIS users Nils Ratnaweera 1 Abstract This is a resource for people coming from ArcGIS who want to do spatial stuff (Analysis, Visualization) in R. This resource should provide some help on this journey. Who this book is for: youve worked primarily with ArcGIS and would like to transition to R you have some experience with R you dont mind working with the tidyverse "],["foreword.html", "2 Foreword", " 2 Foreword I had long since thought about the necessity of a resource which helps ArcGIS users transition to R or Python. I had tweeted this without getting much reception, and and one point just decided to start my own resource. I, like many, learned GIS in University using ArcGIS. It took me a considerable amount of time to learn that there are alternatives to ArcGIS, but not much longer to realize that Im more attracted to these alternatives than to ArcGIS. When you transition from a proprietary Software like ArcGIS to FOSS, you have to relearn many of the concepts because the proprietary software usually does not adhere to common standards. There are already a great many spatial-R Resources out there, and Im not planning to rewrite everything that has been written. My aim is just to provide a resource for people looking to do spatial stuff in R, but only know the ArcGIS-Term for it. This might mean that for some topics, I will simply provide a link to an existing resource. "],["making-interactive-maps.html", "3 Making Interactive Maps", " 3 Making Interactive Maps Probably one of the first things you want to do when working with a dataset is visualizing it spatially. This is basically always the first thing you do in ArcGIS. So how do you this in R? If your aim is to explore the data, to just get a feel for it, your map needs to: allow pan and zoom display attribute information in popups provide a background map be easy to make Before you start making maps however, you will have to familiarize yourself with importing raster or vector data into R in the first place. For Vector data, you can read chapter 2.2 Vector data from the book Geocomputation with R. The next chapter 2.3 Raster data provides a very good overview on rasterdata in R There are many packages that provide these features. leaflet mapview tmap In terms of simplicity, versatility and scalability tmap is one of the best in my option. "],["introduction-to-tmap.html", "3.1 Introduction to tmap", " 3.1 Introduction to tmap To see how it works, import the usual libraries and the North Carolina Sample data. library(sf) ## Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1 library(tidyverse) library(tmap) nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;),quiet = TRUE) Heres how the data looks in base plot: tmap has two modes: a static mode for printable maps (called plot) and a dynamic mode for exploratory, interactive maps (called view). We want the latter for now, so we switch to the dynamic mode with: tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing tmap has based its syntax loosely on ggplot2: Mainly, layer are added with + and aesthetics are specified within each layer. tm_shape(nc) + tm_polygons() You can have a look at the attributes of each feature by clicking on it. To view the entire attribute table, you can print nc to the console, or have a look at it with View(nc) if you are using Rstudio. Check the following resources for more information: https://github.com/mtennekes/tmap https://geocompr.robinlovelace.net/adv-map.html#interactive-maps "],["making-statics-maps.html", "4 Making Statics Maps", " 4 Making Statics Maps Probably the quickest way to visualize spatial data is with base::plot(). It can handle raster as well as vector data and usually needs not more than this one command, plot(). This can be great to get a first, quick look at the data but in my opinion, base plot will not get you very far. To make nice static maps, you are better served with ggplot2 or with tmap. There are arguments for both packages, and you might just end up using both. Before you start making maps however, you will have to familiarize yourself with importing raster or vector data into R in the first place. For Vector data, you can read chapter 2.2 Vector data from the book Geocomputation with R. The next chapter 2.3 Raster data provides a very good overview on rasterdata in R "],["static-maps-with-ggplot2.html", "4.1 Static maps with ggplot2", " 4.1 Static maps with ggplot2 4.1.1 Basics library(sf) library(tidyverse) getwd() ## [1] &quot;C:/Users/bako/Desktop/Projekte/All_thing_R_Spatial/github/spatialR_for_ArcGIS_Users&quot; eire &lt;- read_sf(&quot;sample_data/spData/eire.shp&quot;) The most basic plot consists of a ggplot() initiation and a single layer. In case of sf data, you can add a layer with geom_sf(). If the coordinate system is unknown, the axes will be labelled with the numerical values of the coorindates. st_crs(eire) ## Coordinate Reference System: NA ggplot(eire) + geom_sf() However, if the coordinate system is known, the WGS84 Coordinates are labelled and used as the major and minor grid lines. eire &lt;- st_set_crs(eire, &quot;+proj=utm +zone=30 +ellps=airy +units=km&quot;) ggplot(eire) + geom_sf() As always in ggplot, if you want to use a column from your dataset as an input for, say, colour, you need to specify this with aes(): ggplot(eire) + geom_sf(aes(fill = INCOME)) There are various ways to beautify this simple plot: ggplot(eire) + geom_sf(aes(fill = log(INCOME)), colour = &quot;grey&quot;) + labs(title = &quot;Counties of the Irish Republic&quot;, subtitle = expression(&quot;Distribution of Income (log&quot;[10]*&quot;)&quot;), fill = &quot;&quot;) + scale_fill_viridis_c() + theme_void() + theme(legend.position = &quot;bottom&quot;) 4.1.2 Adding Raster Maps Files (geotiffs) While vector data is very easily implemented in ggplot2, rasterdata is a little harder. Its complicated enough with standard Raster Data, and even more so with raster maps. There are two packages that facilitate the combination of rastermaps and ggplot: rasterVis RStoolbox However, we will do without these packages to learn more on how rasters work and be as flexible as possible. If you dont have the time or patience to read through the explanation, the following function takes a path to a raster and returns a dataframe with x/y coordinates as well as a column with the hex colours for the according cell. rastermap_to_dataframe &lt;- function(path) { require(tiff) require(raster) raster_file &lt;- raster::brick(path) bands_n &lt;- nbands(raster_file) if(bands_n == 1){ raster_indexed &lt;- readTIFF(path,indexed = TRUE) raster_colormap &lt;- attr(raster_indexed,&quot;color.map&quot;) raster_colormap_hex &lt;- rgb(raster_colormap[1,],raster_colormap[2,],raster_colormap[3,]) raster_df &lt;- data.frame(coordinates(raster_file), values = raster_colormap_hex[getValues(raster_file)+1]) } else if(bands_n == 3){ raster_df &lt;- data.frame( coordinates(raster_file), values = rgb(values(raster_file[[1]]),values(raster_file[[2]]),values(raster_file[[3]]),maxColorValue = 255) ) } return(raster_df) } 4.1.2.1 With Colours Tif files with colours can either be single band or include multiple bands in a single tif file. These need to be treated differently. Lets take two variants of the swiss raster map 1:50k map. One is a single band dataset, the other a 3-band dataset. library(raster) ## Loading required package: sp ## ## Attaching package: &#39;raster&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## select ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract path_1b &lt;- &quot;sample_data/SMR_Musterdaten/SMR50_LV95_KOMB_Mosaic.tif&quot; path_3b &lt;- &quot;sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif&quot; raster(path_1b) ## class : RasterLayer ## dimensions : 800, 800, 640000 (nrow, ncol, ncell) ## resolution : 2.5, 2.5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/bako/Desktop/Projekte/All_thing_R_Spatial/github/spatialR_for_ArcGIS_Users/sample_data/SMR_Musterdaten/SMR50_LV95_KOMB_Mosaic.tif ## names : SMR50_LV95_KOMB_Mosaic ## values : 0, 255 (min, max) raster(path_3b) ## class : RasterLayer ## band : 1 (of 3 bands) ## dimensions : 400, 400, 160000 (nrow, ncol, ncell) ## resolution : 5, 5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/bako/Desktop/Projekte/All_thing_R_Spatial/github/spatialR_for_ArcGIS_Users/sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif ## names : SMR50_LV95_KREL_10L_Mosaic ## values : 0, 255 (min, max) As you can see in the output of raster(path_3b), only one of the 3 bands was imported with raster::raster. In the case of multiband rasters, its better to use raster::brick: map_1b &lt;- raster(path_1b) map_3b &lt;- brick(path_3b) 4.1.2.1.1 Singleband A singleband RasterLayer can be regarded as vector of numeric values arranged in a matrix with some additional metadata. The metadata can be view with str(), the values can be obtained with getValues(). str(map_1b) ## Formal class &#39;RasterLayer&#39; [package &quot;raster&quot;] with 12 slots ## ..@ file :Formal class &#39;.RasterFile&#39; [package &quot;raster&quot;] with 13 slots ## .. .. ..@ name : chr &quot;C:\\\\Users\\\\bako\\\\Desktop\\\\Projekte\\\\All_thing_R_Spatial\\\\github\\\\spatialR_for_ArcGIS_Users\\\\sample_data\\\\SMR_Mu&quot;| __truncated__ ## .. .. ..@ datanotation: chr &quot;INT1U&quot; ## .. .. ..@ byteorder : chr &quot;little&quot; ## .. .. ..@ nodatavalue : num -Inf ## .. .. ..@ NAchanged : logi FALSE ## .. .. ..@ nbands : int 1 ## .. .. ..@ bandorder : chr &quot;BIL&quot; ## .. .. ..@ offset : int 0 ## .. .. ..@ toptobottom : logi TRUE ## .. .. ..@ blockrows : int 1 ## .. .. ..@ blockcols : int 800 ## .. .. ..@ driver : chr &quot;gdal&quot; ## .. .. ..@ open : logi FALSE ## ..@ data :Formal class &#39;.SingleLayerData&#39; [package &quot;raster&quot;] with 13 slots ## .. .. ..@ values : logi(0) ## .. .. ..@ offset : num 0 ## .. .. ..@ gain : num 1 ## .. .. ..@ inmemory : logi FALSE ## .. .. ..@ fromdisk : logi TRUE ## .. .. ..@ isfactor : logi FALSE ## .. .. ..@ attributes: list() ## .. .. ..@ haveminmax: logi TRUE ## .. .. ..@ min : num 0 ## .. .. ..@ max : num 255 ## .. .. ..@ band : int 1 ## .. .. ..@ unit : chr &quot;&quot; ## .. .. ..@ names : chr &quot;SMR50_LV95_KOMB_Mosaic&quot; ## ..@ legend :Formal class &#39;.RasterLegend&#39; [package &quot;raster&quot;] with 5 slots ## .. .. ..@ type : chr(0) ## .. .. ..@ values : logi(0) ## .. .. ..@ color : logi(0) ## .. .. ..@ names : logi(0) ## .. .. ..@ colortable: chr [1:256] &quot;#000000&quot; &quot;#FFFFFF&quot; &quot;#D6EBD8&quot; &quot;#BDDFB5&quot; ... ## ..@ title : chr(0) ## ..@ extent :Formal class &#39;Extent&#39; [package &quot;raster&quot;] with 4 slots ## .. .. ..@ xmin: num 2599000 ## .. .. ..@ xmax: num 2601000 ## .. .. ..@ ymin: num 1196000 ## .. .. ..@ ymax: num 1198000 ## ..@ rotated : logi FALSE ## ..@ rotation:Formal class &#39;.Rotation&#39; [package &quot;raster&quot;] with 2 slots ## .. .. ..@ geotrans: num(0) ## .. .. ..@ transfun:function () ## ..@ ncols : int 800 ## ..@ nrows : int 800 ## ..@ crs :Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot ## .. .. ..@ projargs: chr NA ## ..@ history : list() ## ..@ z : list() head(getValues(map_1b),50) ## [1] 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 ## [26] 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 extent(map_1b) ## class : Extent ## xmin : 2599000 ## xmax : 2601000 ## ymin : 1196000 ## ymax : 1198000 The first 50 cells of this RasterLayer contain the value 37. This value 37 is associated with a specific colour, which can be viewd in the colortable of the RasterLayer. coltab &lt;- colortable(map_1b) head(coltab) ## [1] &quot;#000000&quot; &quot;#FFFFFF&quot; &quot;#D6EBD8&quot; &quot;#BDDFB5&quot; &quot;#A5CF91&quot; &quot;#53A935&quot; scales::show_col(coltab,labels = FALSE) In order to plot this RasterLayer in ggplot, we need to convert it into a dataframe. You can imagine that this is converting the wide matrix into a very long table with three columns: x and y coordinates of the lower left corner of each cell and a value specifying what the cell holds. map_1b_df &lt;- data.frame(coordinates(map_1b),values = getValues(map_1b)) head(map_1b_df) ## x y values ## 1 2599001 1197999 37 ## 2 2599004 1197999 37 ## 3 2599006 1197999 37 ## 4 2599009 1197999 37 ## 5 2599011 1197999 37 ## 6 2599014 1197999 37 We can now use the values column in ggplot2 to specify the fill aesthetic. If we then pass the colortable as our fill values, the colours will be matched correctly. However we need two additional tricks: name the colourtable to make sure the correct colours are correct to the according values wrap the values column in factor() so that the ggplot2 does not mistake the numeric values as a continuous scale: names(coltab) &lt;- 0:255 # 1:256 would be wrong by 1 ggplot() + geom_raster(data = map_1b_df, aes(x,y, fill = factor(values))) + scale_fill_manual(values = coltab) + theme(legend.position = &quot;none&quot;) + coord_equal() Note that there are thee ways to plot this type of data in ggplot2: geom_rect, geom_tile and geom_raster. The latter is a high performance special case for when all the tiles are the same size (see the docs. Alternatively, you can add the hex colourcode to the dataframe and use scale_fill_identitiy(). map_1b_df &lt;- mutate(map_1b_df, colorvalue = coltab[values+1]) ggplot() + geom_raster(data = map_1b_df, aes(x,y, fill = colorvalue)) + scale_fill_identity() + theme(legend.position = &quot;none&quot;) + coord_equal() The big drawback of using ggplot2 in this way: you cannot add a second layer with a fill aesthetic, since ggplot2 only allows one per plot. 4.1.2.1.2 Multiple bands In case of a 3-Band Raster Brick, each layer holds a value of 0 to 255 representing colours in the RGB colour model. Usually, the first layer represents Red, the second Green and the third Blue. We can subset the RasterBrick into the individual RasterLayers using double brackets ([[1]] for the first layer). map_3b ## class : RasterBrick ## dimensions : 400, 400, 160000, 3 (nrow, ncol, ncell, nlayers) ## resolution : 5, 5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/bako/Desktop/Projekte/All_thing_R_Spatial/github/spatialR_for_ArcGIS_Users/sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif ## names : SMR50_LV95_KREL_10L_Mosaic.1, SMR50_LV95_KREL_10L_Mosaic.2, SMR50_LV95_KREL_10L_Mosaic.3 ## min values : 0, 0, 0 ## max values : 255, 255, 255 map_3b[[1]] ## class : RasterLayer ## band : 1 (of 3 bands) ## dimensions : 400, 400, 160000 (nrow, ncol, ncell) ## resolution : 5, 5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/bako/Desktop/Projekte/All_thing_R_Spatial/github/spatialR_for_ArcGIS_Users/sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif ## names : SMR50_LV95_KREL_10L_Mosaic.1 ## values : 0, 255 (min, max) As with the singleband raster, we can extract the Values (this time RGB-Values) of each layer with getValues(). head(values(map_3b[[1]]),50) ## [1] 27 27 31 27 67 124 124 124 124 123 123 123 122 123 122 66 27 57 97 ## [20] 113 123 123 124 100 68 68 68 68 68 68 68 36 27 27 27 27 38 117 ## [39] 105 97 97 100 111 119 54 27 27 27 27 66 Again like with the single band raster, we now transform the Raster into a dataframe, this time storing the rgb values in columns (instead of the hex values as before). map_3b_df &lt;- data.frame( coordinates(map_3b), r = values(map_3b[[1]]), g = values(map_3b[[2]]), b = values(map_3b[[3]])) head(map_3b_df) ## x y r g b ## 1 2599003 1197998 27 26 35 ## 2 2599008 1197998 27 26 35 ## 3 2599013 1197998 31 28 36 ## 4 2599018 1197998 27 26 35 ## 5 2599023 1197998 67 59 58 ## 6 2599028 1197998 124 114 110 With the function rbg() we can transform values into hex-codes. rgb(10,10,10,maxColorValue = 255) ## [1] &quot;#0A0A0A&quot; ggplot() + geom_raster(data = map_3b_df, aes(x,y,fill = rgb(r,g,b,maxColorValue = 255))) + scale_fill_identity() + coord_equal() Tipp: if your file is to large and ggplot has trouble plotting it fast, you can use aggregate to reduce the resolution map_3b_lowres &lt;- raster::aggregate(map_3b, fact = 5) 4.1.2.2 Greyscale In greyscale maps, raster cannot find a associated colortable to match the values to rgb or hex colours. map_grey_path &lt;- &quot;sample_data/SMR_Musterdaten/SMR50_LV95_KGRS_Mosaic.tif&quot; map_grey &lt;- raster(map_grey_path) head(getValues(map_grey)) ## [1] 31 31 31 31 31 31 head(colortable(map_grey)) ## [1] &quot;#000000&quot; &quot;#FFFFFF&quot; &quot;#F4F4F4&quot; &quot;#E7E7E7&quot; &quot;#D3D2D3&quot; &quot;#CAC9CA&quot; However, the package tiff can find the rgb values of a tiff, we just need to set indexed = TRUE and get the color.map attribute of the output: library(tiff) index &lt;- readTIFF(map_grey_path,indexed = TRUE) colormap &lt;- attr(index,&quot;color.map&quot;) colormap[,1:8] # only showing the first 8 columns (of 256) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 0 1 0.9568627 0.9058824 0.8274510 0.7921569 0.7843137 0.7725490 ## [2,] 0 1 0.9568627 0.9058824 0.8235294 0.7882353 0.7803922 0.7686275 ## [3,] 0 1 0.9568627 0.9058824 0.8274510 0.7921569 0.7843137 0.7725490 This is an index with three rows (Red, Green and Blue) and 265 columns (with are the Values from getValues()). We can now use rgb() to turn this matrix into a vector of 265 hex colours: coltab &lt;- rgb(colormap[1,],colormap[2,],colormap[3,]) scales::show_col(coltab,labels = FALSE) Like before, we now turn the RasterLayer into a dataframe and use the Values and the newly created colortable to assign the correct values: map_grey_df &lt;- data.frame(coordinates(map_grey),values = getValues(map_grey)) names(coltab) &lt;- 0:255 ggplot() + geom_raster(data = map_grey_df, aes(x,y, fill = factor(values))) + scale_fill_manual(values = coltab) + theme(legend.position = &quot;none&quot;) + coord_equal() "],["select-by-attribute.html", "4.2 Select by Attribute", " 4.2 Select by Attribute One of the popular approaches in ArcGIS pro for selecting features in a layer is by using an attribute query. The action is performed using the Select By Attributes tool. Select By Attributes tool allows us to provide an SQL query expression to select features that match the selection criteria. R on the other hand offers quite easy and straightforward options to perform similar operations. Lets examine one of them. As a first step, we might want to import a shapefile. To do so, we can use sf package to work with vector data in R. Important to know is that the rgdal package automatically loads when sf is loaded. In the code snippet below, we read the shapefile, which represents the parking spots for bicycles within the canton of Zurich. The dataset is publicly available for download in the following link: (https://opendata.swiss/en/dataset/veloparkierungsanlagen). library(sf) library(ggplot2) parkBikes &lt;- st_read(&quot;sample_data/Kanton_Zuerich/Veloparkierungsanlagen/OGD_VELOPARKIERANLAGEN_P.shp&quot;) ## Reading layer `OGD_VELOPARKIERANLAGEN_P&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\Kanton_Zuerich\\Veloparkierungsanlagen\\OGD_VELOPARKIERANLAGEN_P.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 511 features and 28 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2669965 ymin: 1229454 xmax: 2707390 ymax: 1280235 ## projected CRS: CH1903+ / LV95 After importing the dataset, lets say we want to filter it by selecting only the parking spots that lie within a specific municipality (Gemeinde) in the canton of Zurich. More specifically, we will select only the parking spots within the municipality of Winterthur. For the aforementioned operation, R offers the function filter(), which lies within the dplyr package. This functions works as follows: filter(dataset, condition) library(dplyr) parkBikes_winti &lt;- filter(parkBikes,GEMEINDE == &quot;Winterthur&quot;) The operation above produces the same outcome as the one depicted in the figure below 4.1. Figure 4.1: Select by Attributes in ArcGIS pro "],["select-by-location.html", "4.3 Select by Location", " 4.3 Select by Location One of the most commonly used operations in ArcGIS pro is the process of selecting features of a spatial object (layer) based on whether or not these relate spatially to another object (layer). This process is also referred as spatial subsetting. In ArcGIS pro this can be performed in various ways using the Select by Location tool. In R the same operation is, on a first level, performed using the square bracket ([]) operator from the base R package. An example of spatial subsetting could be the following. Lets assume we have as a shapefile (polygon dataframe) with all the municipalities (Gemeinde) of the Canton of Zurich. Furthermore, we are also using a shapefile in the form of a point dataframe, which represents all the swimming spots (Badenplätze) in the same spatial region (Canton of Zurich). So, ultimately, our goal is to find out the swimming spots that lie within a specific municipality of the Canton of Zurich. # Minicipalities (Gemeinde) in Canton Zurich gemeinde_ZH &lt;- st_read(&quot;sample_data/Kanton_Zuerich/Gemeinde_ZH.shp&quot;) ## Reading layer `Gemeinde_ZH&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\Kanton_Zuerich\\Gemeinde_ZH.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 166 features and 7 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 2669245 ymin: 1223896 xmax: 2716900 ymax: 1283343 ## projected CRS: CH1903+ / LV95 # &quot;Swimming&quot; spots in the Canton of Zurich swimmSpots &lt;- st_read(&quot;sample_data/Kanton_Zuerich/Badeplaetze_ZH.shp&quot;) ## Reading layer `Badeplaetze_ZH&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\Kanton_Zuerich\\Badeplaetze_ZH.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 71 features and 6 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2671636 ymin: 1226720 xmax: 2710101 ymax: 1282760 ## projected CRS: CH1903+ / LV95 After importing and depicting the swimming spots throughout the canton of Zurich, lets assume we want to check if and how many of them lie within the Municipality of Richterswil. To do so, we will perform an operation, which belongs to the category of Spatial subsetting. swimmSpots_richt &lt;- swimmSpots[richterswil, ,op = st_within] The operation above is based on the following rule: x[y, ,operation], where: div.note { background-color:#f0f0f0; border-radius: 5px; padding: 20px;} x and y are the spatial objects for which we want to investigate if there is a spatial relationship (x is the target feature, while y is the source one) the second argument [, ,] within the brackets denotes the column number we want to retrieve from the spatial subsetting. In our example this argument was empty, which means we wanted to retrieve all rows for every attribute column. the third argument [op = ] specifies the spatial operation we want to perform. In the example above, the goal was to find out how many subset features of the target object swimmSpots lie withing the source spatial object richterswil. For that reason we chose the function st_within(). Depending on what we want to examine, we choose the respective function. "],["analysis-toolbox.html", "5 Analysis Toolbox ", " 5 Analysis Toolbox "],["extract-toolset.html", "5.1 Extract Toolset", " 5.1 Extract Toolset 5.1.1 Clip Quite often in spatial analysis, we come across with cases, where we do not want to use all the available data there is. In other words, we want to focus on a specific area of interest, which dictates the need for clipping the existing dataset based on its relationship to some other existing spatial feature. In R this operation can be easily performed using the st_intersection function in sf. Lets assume in the example below that we want to clip the available dataset of all the train stations in Switzerland by focusing our analysis on four specific cantons. # Point dataset depicting the train stations locations across Switzerland bahn_haltestelle_ch &lt;- st_read(&quot;sample_data/other/Haltestelle_Bahn_CH.shp&quot;) ## Reading layer `Haltestelle_Bahn_CH&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\other\\Haltestelle_Bahn_CH.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 3134 features and 16 fields ## geometry type: POINT ## dimension: XYZ ## bbox: xmin: 2488908 ymin: 1076850 xmax: 2817389 ymax: 1289090 ## z_range: zmin: 194.905 zmax: 3453.525 ## projected CRS: CH1903+ / LV95 # Dataset depicting Switzerland on canton level kantonsgebiet &lt;- st_read(&quot;sample_data/other/Kantonsgebiet.shp&quot;) ## Reading layer `Kantonsgebiet&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\other\\Kantonsgebiet.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 56 features and 22 fields ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2485410 ymin: 1075268 xmax: 2833858 ymax: 1295934 ## z_range: zmin: 193.51 zmax: 4613.729 ## projected CRS: CH1903+ / LV95 tmap_mode(mode = c(&quot;plot&quot;)) # setting the plotting mode to static -- optimizing the process tm_shape(kantonsgebiet) + tm_polygons(&quot;#f0f0f0&quot;) + tm_shape(bahn_haltestelle_ch) + tm_dots(col = &quot;#e34a33&quot;,size = 0.1, alpha = 0.5) + tm_shape(kantonsgebiet) + tm_borders(col = &quot;black&quot;) + tm_layout(frame = F) As it was mentioned above, the aim is to analyse the situation at a particular area. So we are going to create an index with the specific cantons we are interested in. index &lt;- kantonsgebiet$name == &quot;Zürich&quot; | kantonsgebiet$name == &quot;St. Gallen&quot; | kantonsgebiet$name == &quot;Thurgau&quot; | kantonsgebiet$name == &quot;Aargau&quot; # Selecting the cantons based on the previously generated index kantons_aOi &lt;- kantonsgebiet[index,] # Performing the clipping operation hal_clipped &lt;- st_intersection(kantons_aOi,bahn_haltestelle_ch) Plotting the result from the clipping operation tm_shape(kantons_aOi) + tm_polygons(&quot;#f0f0f0&quot;) + tm_shape(hal_clipped) + tm_dots(col = &quot;#e34a33&quot;,size = 0.1, alpha = 0.5) + tm_shape(kantons_aOi) + tm_borders() + tm_layout(frame = F) So, ultimately, as we can see above, the st_intersection function creates a result where the point dataset is precisely clipped based on the area of interest The operation above produces the same outcome as the one depicted in the figure below 5.1. Figure 5.1: Clip operation in ArcGIS pro 5.1.2 Split 5.1.3 Split by Attributes 5.1.4 Table Select "],["overlay-toolset.html", "5.2 Overlay Toolset", " 5.2 Overlay Toolset 5.2.1 Merge Lets assume in the example below that instead of having four individual areas of interest, we are interested in having one common, unified area on which we focus our analysis. In other words, we have to merge the existing four areas into one. In ArcGIS pro the respective tools for this action is either the Merge or the Dissolve tool. In R on the other hand, this can be easily performed using the st_union function in the sf package. # The area of interest from the previous example - section Clip kantons_aOi ## Simple feature collection with 12 features and 22 fields (with 5 geometries empty) ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2620698 ymin: 1193269 xmax: 2768769 ymax: 1283504 ## z_range: zmin: 260.666 zmax: 3246.858 ## projected CRS: CH1903+ / LV95 ## First 10 features: ## uuid datum_aend datum_erst erstellung ## 6 {05D55405-466B-4ECC-83C7-A906DEB0D607} 2017-12-04 2012-10-26 2012 ## 7 {FB7105B8-6D7C-4787-846E-17B2BC145C6E} 2018-11-22 2012-10-26 2012 ## 10 {E11CD2CA-2E2D-415C-8789-C10D7C26E441} 2016-12-09 2012-10-26 2012 ## 12 {87370D3F-DBBE-4D05-AF85-C358C3924B3D} 2018-11-22 2012-10-26 2012 ## 41 {99488953-65F6-4F86-8606-337113587F85} 2015-12-08 2012-10-26 2012 ## 47 {F1A07951-AC8B-4EBA-B48F-64BC8B92228C} 2015-12-08 2012-10-26 2012 ## 48 {784EB478-2D40-4620-80F8-ACC252A6FD02} 2015-12-08 2012-10-26 2012 ## NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA ## NA.1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA ## NA.2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA ## erstellu_1 revision_j revision_m grund_aend herkunft herkunft_j herkunft_m ## 6 10 2019 1 400 100 2018 1 ## 7 10 2019 1 400 500 2019 1 ## 10 10 2019 1 400 100 2017 1 ## 12 10 2019 1 400 500 2019 1 ## 41 10 2019 1 400 500 2015 12 ## 47 10 2019 1 400 500 2015 12 ## 48 10 2019 1 400 500 2015 12 ## NA NA NA NA NA NA NA NA ## NA.1 NA NA NA NA NA NA NA ## NA.2 NA NA NA NA NA NA NA ## objektart kantonsnum see_flaech revision_q kantonsfla kanton_tei ## 6 0 17 7720 2018_Aufbau 202820 1 ## 7 0 1 6811 2018_Aufbau 172894 0 ## 10 0 19 870 2018_Aufbau 140380 1 ## 12 0 20 13121 2018_Aufbau 99433 1 ## 41 0 20 0 2018_Aufbau 0 2 ## 47 0 17 0 2018_Aufbau 0 2 ## 48 0 19 0 2018_Aufbau 0 2 ## NA NA NA NA &lt;NA&gt; NA NA ## NA.1 NA NA NA &lt;NA&gt; NA NA ## NA.2 NA NA NA &lt;NA&gt; NA NA ## name icc einwohnerz Shape_Leng Shape_Area ## 6 St. Gallen CH 504686 494074.195 2.028094e+09 ## 7 Zürich CH 1504346 312972.523 1.728942e+09 ## 10 Aargau CH 670988 328943.352 1.403783e+09 ## 12 Thurgau CH 273801 287778.920 9.905920e+08 ## 41 Thurgau CH 0 8640.269 3.737271e+06 ## 47 St. Gallen CH 0 1481.811 1.054068e+05 ## 48 Aargau CH 0 537.994 1.486573e+04 ## NA &lt;NA&gt; &lt;NA&gt; NA NA NA ## NA.1 &lt;NA&gt; &lt;NA&gt; NA NA NA ## NA.2 &lt;NA&gt; &lt;NA&gt; NA NA NA ## geometry ## 6 MULTIPOLYGON Z (((2703763 1... ## 7 MULTIPOLYGON Z (((2673542 1... ## 10 MULTIPOLYGON Z (((2673542 1... ## 12 MULTIPOLYGON Z (((2701937 1... ## 41 MULTIPOLYGON Z (((2751489 1... ## 47 MULTIPOLYGON Z (((2744263 1... ## 48 MULTIPOLYGON Z (((2675447 1... ## NA MULTIPOLYGON Z EMPTY ## NA.1 MULTIPOLYGON Z EMPTY ## NA.2 MULTIPOLYGON Z EMPTY # Merging the four areas into one aOi_merged &lt;- st_union(kantons_aOi) Plot the merged area of interest tm_shape(aOi_merged) + tm_polygons(&quot;#f0f0f0&quot;) + tm_layout(frame = F) The operation above produces the same outcome as the one depicted in the figure below 5.2. Figure 5.2: Dissolve operation in ArcGIS pro 5.2.2 Erase 5.2.3 Union 5.2.4 Symmetrical Difference 5.2.5 Spatial Join § Say you have two datasets: library(sf) library(tidyverse) zweitwohnung &lt;- read_sf(&quot;sample_data/other/zweitwohnung_gemeinden.gpkg&quot;) %&gt;% dplyr::filter(kanton == &quot;Valais / Wallis&quot;) %&gt;% select(NAME) bbox &lt;- st_bbox(zweitwohnung) %&gt;% st_as_sfc() points &lt;- st_sample(bbox,500) ggplot(zweitwohnung) + geom_sf() + geom_sf(data = points) In R, the function used to join two datastes is st_join(x,y). If you have to different data types (e.g. Points and Polygons) the first question you have to ask yourself is: what data type should the output be? The datatype of x determins what the output datatype is. So with the above data: Say for each point, we want to know the Name (NAME) of the Geimeinde in which it lies. This means the output is a point dataset. We therefore write: st_join(st_sf(points),zweitwohnung,join = st_within) Note that points not located in a Gemeinde get the value NA. You have to specify the spatial relationship of your join method within the argument join =. This argument take a so called spatial predicate function. From the join_methods available in ArcGIS, heres the equivalant spatial predicate function: ArcGIS Term R Spatial Predicate Intersect st_intersect Intersect 3D (1) Within a distance st_is_within_distance Within a distance geodesic ?? Within a distance 3D (1) Contains st_contains Completely contains st_contains_properly? Contains clementini ?? Within st_within Completely within Within clementini ?? Are identical to st_equals? boundry touches st_touches Share a line segment Have their center in Closest st_nearest_feature? Closest geodesic ?? All binary predicates only work on 2D Objects (see this issue) 5.2.6 Intersect 5.2.7 Identity 5.2.8 Update "],["proximity-toolset.html", "5.3 Proximity Toolset", " 5.3 Proximity Toolset 5.3.1 Buffer One of the most commonly used operations in ArcGIS pro is the one called Buffer. This operation provides a very convenient way of identifying areas of interest lying in the neighborhood of an existing spatial feature. In R the same action can be performed using the st_buffer function in sf. Below we introduce a line spatial feature that depicts all the mountain bike routes in Switzerland. ## Reading layer `mountainBikes_routes&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\other\\mountainBikes_routes.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 286 features and 29 fields ## geometry type: LINESTRING ## dimension: XYZ ## bbox: xmin: 2497570 ymin: 1077136 xmax: 2836678 ymax: 1296227 ## z_range: zmin: 197.367 zmax: 2860.725 ## projected CRS: CH1903+ / LV95 We focus, as an area of interest, on the canton of Valais. Consequently, we might be interested in identifying all the areas in a radius of 1000 m around these bike routes. Selecting the canton of Valais Apply a buffer of 1000m on each of the mountain bike routes within the canton of Valais routes_buffer &lt;- st_buffer(mountainBikes_routes_valais,1000) tm_shape(canton_valais) + tm_polygons() + tm_shape(mountainBikes_routes_valais) + tm_lines(col = &quot;#e34a33&quot;) + tm_shape(routes_buffer) + tm_polygons(col = &quot;blue&quot;, alpha = 0.2) + tm_shape(canton_valais) + tm_borders(col = &quot;black&quot;) + tm_layout(frame = F) The operation above produces the same outcome as the one depicted in the figure below 5.3. Figure 5.3: Buffer operation in ArcGIS pro "],["data-management-toolbox.html", "6 Data Management Toolbox ", " 6 Data Management Toolbox "],["joins-and-relates-toolset.html", "6.1 Joins and Relates Toolset", " 6.1 Joins and Relates Toolset "],["projections-and-transformations-toolset.html", "6.2 Projections and Transformations Toolset", " 6.2 Projections and Transformations Toolset Quite often in GIS, users found themselves before the necessity of transforming (reprojecting) the coordinate system of a dataset (vector or raster). In fact this is one of the most commonly used operations. In ArcGIS pro the aforementioned action is performed using the following tools: Project (Data Management) -&gt; Projects spatial data from one coordinate system to another. Project Raster (Data Management) -&gt; Transforms a raster dataset from one coordinate system to another. The question now is how we can perform similar operations with R. 6.2.1 Reproject vector data in R For our example we will use the following dataset. bezirke.gpkg -&gt; Dataset that depicts the Municipal structure in Switzerland R and more specifically sf package offers options (functions) not only for transforming the coordinate system of a dataset, but also for identifying the current existing one. Lets dive in :) # Importing the dataset library(sf) bezirke &lt;- read_sf(&quot;sample_data/other/bezirke.gpkg&quot;) # Visualising the imported dataset library(ggplot2) ggplot() + geom_sf(data = bezirke) In order to identify the current coordinate system of a dataset, sf package offers the function st_crs. The main usage of the function is to retrieve the coordinate reference system from an sf object. # retrieving the coordinate of the imported layer st_crs(bezirke) ## Coordinate Reference System: NA As an output we received that there is no assigned coordinate system to this specific dataset. st_set_crs function helps us assigning a coordinate system to a dataset. # Assigning the World Geodetic System (WGS84) as a coordinate system to our dataset bezirke &lt;- st_set_crs(bezirke, 4326) In the function above, the number 4326 represents the EPSG Geodetic Parameter Dataset (EPSG) of the respective coordinate system. EPSG is a public registry of geodetic datums, spatial reference systems, Earth ellipsoids, coordinate transformations and related units of measurement. st_crs(bezirke) ## Coordinate Reference System: ## User input: EPSG:4326 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;World&quot;], ## BBOX[-90,-180,90,180]], ## ID[&quot;EPSG&quot;,4326]] After rerunning the st_crs function, we are getting now that the assigned coordinate system of the dataset is World Geodetic System (WGS84). As a next step, we might want to transform the dataset to the Swiss coordinate system. The respective EPSG for code for the latest Swiss coordinate system (CH1903+LV95) is 2056. For this purpose we use the st_transform function of the sf package. Important &gt; Click to expand! st_set_crs function does not reproject the coordinates of the given dataset. In other words, it does not affect the actual geometry column of the sf object. st_tranform on the other hand indeed does indeed reproject the dataset to another coordinate system. bezirke_swiss &lt;- st_transform(bezirke, 2056) # retrieve the coordinate system st_crs(bezirke_swiss) ## Coordinate Reference System: ## User input: EPSG:2056 ## wkt: ## PROJCRS[&quot;CH1903+ / LV95&quot;, ## BASEGEOGCRS[&quot;CH1903+&quot;, ## DATUM[&quot;CH1903+&quot;, ## ELLIPSOID[&quot;Bessel 1841&quot;,6377397.155,299.1528128, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4150]], ## CONVERSION[&quot;Swiss Oblique Mercator 1995&quot;, ## METHOD[&quot;Hotine Oblique Mercator (variant B)&quot;, ## ID[&quot;EPSG&quot;,9815]], ## PARAMETER[&quot;Latitude of projection centre&quot;,46.9524055555556, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8811]], ## PARAMETER[&quot;Longitude of projection centre&quot;,7.43958333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8812]], ## PARAMETER[&quot;Azimuth of initial line&quot;,90, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8813]], ## PARAMETER[&quot;Angle from Rectified to Skew Grid&quot;,90, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8814]], ## PARAMETER[&quot;Scale factor on initial line&quot;,1, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8815]], ## PARAMETER[&quot;Easting at projection centre&quot;,2600000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8816]], ## PARAMETER[&quot;Northing at projection centre&quot;,1200000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8817]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;Europe - Liechtenstein and Switzerland&quot;], ## BBOX[45.82,5.96,47.81,10.49]], ## ID[&quot;EPSG&quot;,2056]] 6.2.2 Reproject raster data in R Working with Raster datasets in GIS of operations is of equal importance, as working with vector ones. One of the spatial properties of raster datasets is the the Coordinate Reference System (CRS). CRS is the specific system that associates the raster coordinates (which are just pairs of x/y values) to geographic locations. In ArcGIS pro the tool for projecting a raster dataset is called Project Raster (Data Management). Lets see how we can perform the same operation with R. We can use the projectRaster() function to reproject a raster into a new CRS. It is important to remember that raster reprojection only works when the raster object has already a defined CRS. "],["topology-toolset.html", "6.3 Topology Toolset", " 6.3 Topology Toolset "],["sampling-toolset.html", "6.4 Sampling Toolset", " 6.4 Sampling Toolset 6.4.1 Generate Tessellation Hexagon Tranverse Hexagon Square Diamond Triangle 6.4.2 Create Fishnet 6.4.3 Create Random Points 6.4.4 Generate Points Along Lines 6.4.5 Generate Rectangles Along Lines 6.4.6 Generate Transsects Along Lines "],["raster-toolset.html", "6.5 Raster Toolset", " 6.5 Raster Toolset 6.5.1 Mosaic Dataset Toolset 6.5.2 Ortho Mapping Toolset 6.5.3 Raster Dataset Toolset 6.5.4 Raster Processing Toolset 6.5.4.1 Clip Raster In GIS operations is quite common the necessity of clipping an area based on some specific region of interest. This is a quite useful and necessary procedure not only when we are dealing with vector datasets, but also when we have to work with raster ones. In ArcGIS pro the procedure of cutting a portion of a raster dataset, mosaic dataset, or an image service layer is performed using Clip Raster tool. In R, the respective operation can be performed using the mask() function. For the example below, we are using the following datasets: ARE_waedi -&gt; vector dataset that depicts the public transport connection quality in the city of Wädenswil recycle_Waedi -&gt; raster dataset .. # Read raster dataset library(raster) library(stars) library(sf) library(dplyr) library(stars) # Insert a vector dataset that depicts the public transport connection quality in # the city of Wädenswil and plot it ARE_waedi &lt;- read_sf(&quot;sample_data/Entsorgung_Waedenswil/ARE_waedenswil.shp&quot;) # Read the raster dataset and plot it recycle_Waedi &lt;- raster(&quot;sample_data/Entsorgung_Waedenswil/abfall_raster.tif&quot;) Plot the two datasets one over the other. In our case, the vector dataset serves as the clipping extent for the clipping operation. recycle_Waedi_clip &lt;- mask(recycle_Waedi,ARE_waedi) Visualising the clipped output 6.5.4.2 Composite Bands 6.5.4.3 Compute Pansharpen Weights 6.5.4.4 Create Ortho Corrected Raster Dataset 6.5.4.5 Create Pansharpened Raster Dataset 6.5.4.6 Extract Subdataset 6.5.4.7 Generate Table From Raster Function 6.5.4.8 Raster To DTED 6.5.4.9 Resample 6.5.4.10 Split Raster 6.5.5 Raster Properties Toolset "]]
