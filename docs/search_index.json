[["index.html", "Burning Bridges An intro to spatial-R for ArcGIS users 1 Abstract", " Burning Bridges An intro to spatial-R for ArcGIS users Nils Ratnaweera 1 Abstract This is a resource for people coming from ArcGIS who want to do spatial stuff (Analysis, Visualization) in R. This resource should provide some help on this journey. Who this book is for: youve worked primarily with ArcGIS and would like to transition to R you have some experience with R you dont mind working with the tidyverse "],["foreword.html", "2 Foreword", " 2 Foreword I had long since thought about the necessity of a resource which helps ArcGIS users transition to R or Python. I had tweeted this without getting much reception, and and one point just decided to start my own resource. I, like many, learned GIS in University using ArcGIS. It took me a considerable amount of time to learn that there are alternatives to ArcGIS, but not much longer to realize that Im more attracted to these alternatives than to ArcGIS. When you transition from a proprietary Software like ArcGIS to FOSS, you have to relearn many of the concepts because the proprietary software usually does not adhere to common standards. There are already a great many spatial-R Resources out there, and Im not planning to rewrite everything that has been written. My aim is just to provide a resource for people looking to do spatial stuff in R, but only know the ArcGIS-Term for it. This might mean that for some topics, I will simply provide a link to an existing resource. "],["making-maps.html", "3 Making Maps", " 3 Making Maps Probably the quickest way to visualize spatial data is with base::plot(). It can handle raster as well as vector data and usually needs not more than this one command, plot(). This can be great to get a first, quick look at the data but in my opinion, base plot will not get you very far. To make nice static maps, you are better served with ggplot2 or with tmap. There are arguments for both packages, and you might just end up using both. "],["making-static-maps.html", "3.1 Making Static Maps", " 3.1 Making Static Maps Before you start making maps however, you will have to familiarize yourself with importing raster or vector data into R in the first place. For Vector data, you can read chapter 2.2 Vector data from the book Geocomputation with R. The next chapter 2.3 Raster data provides a very good overview on rasterdata in R 3.1.1 Static maps with ggplot2 3.1.1.1 Basics library(sf) ## Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1 library(tidyverse) getwd() ## [1] &quot;C:/Users/bako/Desktop/Projekte/All_thing_R_Spatial/github/spatialR_for_ArcGIS_Users&quot; eire &lt;- read_sf(&quot;sample_data/spData/eire.shp&quot;) The most basic plot consists of a ggplot() initiation and a single layer. In case of sf data, you can add a layer with geom_sf(). If the coordinate system is unknown, the axes will be labelled with the numerical values of the coorindates. st_crs(eire) ## Coordinate Reference System: NA ggplot(eire) + geom_sf() However, if the coordinate system is known, the WGS84 Coordinates are labelled and used as the major and minor grid lines. eire &lt;- st_set_crs(eire, &quot;+proj=utm +zone=30 +ellps=airy +units=km&quot;) ggplot(eire) + geom_sf() As always in ggplot, if you want to use a column from your dataset as an input for, say, colour, you need to specify this with aes(): ggplot(eire) + geom_sf(aes(fill = INCOME)) There are various ways to beautify this simple plot: ggplot(eire) + geom_sf(aes(fill = log(INCOME)), colour = &quot;grey&quot;) + labs(title = &quot;Counties of the Irish Republic&quot;, subtitle = expression(&quot;Distribution of Income (log&quot;[10]*&quot;)&quot;), fill = &quot;&quot;) + scale_fill_viridis_c() + theme_void() + theme(legend.position = &quot;bottom&quot;) 3.1.1.2 Adding Raster Maps Files (geotiffs) While vector data is very easily implemented in ggplot2, rasterdata is a little harder. Its complicated enough with standard Raster Data, and even more so with raster maps. There are two packages that facilitate the combination of rastermaps and ggplot: rasterVis RStoolbox However, we will do without these packages to learn more on how rasters work and be as flexible as possible. If you dont have the time or patience to read through the explanation, the following function takes a path to a raster and returns a dataframe with x/y coordinates as well as a column with the hex colours for the according cell. rastermap_to_dataframe &lt;- function(path) { require(tiff) require(raster) raster_file &lt;- raster::brick(path) bands_n &lt;- nbands(raster_file) if(bands_n == 1){ raster_indexed &lt;- readTIFF(path,indexed = TRUE) raster_colormap &lt;- attr(raster_indexed,&quot;color.map&quot;) raster_colormap_hex &lt;- rgb(raster_colormap[1,],raster_colormap[2,],raster_colormap[3,]) raster_df &lt;- data.frame(coordinates(raster_file), values = raster_colormap_hex[getValues(raster_file)+1]) } else if(bands_n == 3){ raster_df &lt;- data.frame( coordinates(raster_file), values = rgb(values(raster_file[[1]]),values(raster_file[[2]]),values(raster_file[[3]]),maxColorValue = 255) ) } return(raster_df) } 3.1.1.2.1 With Colours Tif files with colours can either be single band or include multiple bands in a single tif file. These need to be treated differently. Lets take two variants of the swiss raster map 1:50k map. One is a single band dataset, the other a 3-band dataset. library(raster) ## Loading required package: sp ## ## Attaching package: &#39;raster&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## select ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract path_1b &lt;- &quot;sample_data/SMR_Musterdaten/SMR50_LV95_KOMB_Mosaic.tif&quot; path_3b &lt;- &quot;sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif&quot; raster(path_1b) ## class : RasterLayer ## dimensions : 800, 800, 640000 (nrow, ncol, ncell) ## resolution : 2.5, 2.5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/bako/Desktop/Projekte/All_thing_R_Spatial/github/spatialR_for_ArcGIS_Users/sample_data/SMR_Musterdaten/SMR50_LV95_KOMB_Mosaic.tif ## names : SMR50_LV95_KOMB_Mosaic ## values : 0, 255 (min, max) raster(path_3b) ## class : RasterLayer ## band : 1 (of 3 bands) ## dimensions : 400, 400, 160000 (nrow, ncol, ncell) ## resolution : 5, 5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/bako/Desktop/Projekte/All_thing_R_Spatial/github/spatialR_for_ArcGIS_Users/sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif ## names : SMR50_LV95_KREL_10L_Mosaic ## values : 0, 255 (min, max) As you can see in the output of raster(path_3b), only one of the 3 bands was imported with raster::raster. In the case of multiband rasters, its better to use raster::brick: map_1b &lt;- raster(path_1b) map_3b &lt;- brick(path_3b) 3.1.1.2.1.1 Singleband A singleband RasterLayer can be regarded as vector of numeric values arranged in a matrix with some additional metadata. The metadata can be view with str(), the values can be obtained with getValues(). str(map_1b) ## Formal class &#39;RasterLayer&#39; [package &quot;raster&quot;] with 12 slots ## ..@ file :Formal class &#39;.RasterFile&#39; [package &quot;raster&quot;] with 13 slots ## .. .. ..@ name : chr &quot;C:\\\\Users\\\\bako\\\\Desktop\\\\Projekte\\\\All_thing_R_Spatial\\\\github\\\\spatialR_for_ArcGIS_Users\\\\sample_data\\\\SMR_Mu&quot;| __truncated__ ## .. .. ..@ datanotation: chr &quot;INT1U&quot; ## .. .. ..@ byteorder : chr &quot;little&quot; ## .. .. ..@ nodatavalue : num -Inf ## .. .. ..@ NAchanged : logi FALSE ## .. .. ..@ nbands : int 1 ## .. .. ..@ bandorder : chr &quot;BIL&quot; ## .. .. ..@ offset : int 0 ## .. .. ..@ toptobottom : logi TRUE ## .. .. ..@ blockrows : int 1 ## .. .. ..@ blockcols : int 800 ## .. .. ..@ driver : chr &quot;gdal&quot; ## .. .. ..@ open : logi FALSE ## ..@ data :Formal class &#39;.SingleLayerData&#39; [package &quot;raster&quot;] with 13 slots ## .. .. ..@ values : logi(0) ## .. .. ..@ offset : num 0 ## .. .. ..@ gain : num 1 ## .. .. ..@ inmemory : logi FALSE ## .. .. ..@ fromdisk : logi TRUE ## .. .. ..@ isfactor : logi FALSE ## .. .. ..@ attributes: list() ## .. .. ..@ haveminmax: logi TRUE ## .. .. ..@ min : num 0 ## .. .. ..@ max : num 255 ## .. .. ..@ band : int 1 ## .. .. ..@ unit : chr &quot;&quot; ## .. .. ..@ names : chr &quot;SMR50_LV95_KOMB_Mosaic&quot; ## ..@ legend :Formal class &#39;.RasterLegend&#39; [package &quot;raster&quot;] with 5 slots ## .. .. ..@ type : chr(0) ## .. .. ..@ values : logi(0) ## .. .. ..@ color : logi(0) ## .. .. ..@ names : logi(0) ## .. .. ..@ colortable: chr [1:256] &quot;#000000&quot; &quot;#FFFFFF&quot; &quot;#D6EBD8&quot; &quot;#BDDFB5&quot; ... ## ..@ title : chr(0) ## ..@ extent :Formal class &#39;Extent&#39; [package &quot;raster&quot;] with 4 slots ## .. .. ..@ xmin: num 2599000 ## .. .. ..@ xmax: num 2601000 ## .. .. ..@ ymin: num 1196000 ## .. .. ..@ ymax: num 1198000 ## ..@ rotated : logi FALSE ## ..@ rotation:Formal class &#39;.Rotation&#39; [package &quot;raster&quot;] with 2 slots ## .. .. ..@ geotrans: num(0) ## .. .. ..@ transfun:function () ## ..@ ncols : int 800 ## ..@ nrows : int 800 ## ..@ crs :Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot ## .. .. ..@ projargs: chr NA ## ..@ history : list() ## ..@ z : list() head(getValues(map_1b),50) ## [1] 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 ## [26] 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 extent(map_1b) ## class : Extent ## xmin : 2599000 ## xmax : 2601000 ## ymin : 1196000 ## ymax : 1198000 The first 50 cells of this RasterLayer contain the value 37. This value 37 is associated with a specific colour, which can be viewd in the colortable of the RasterLayer. coltab &lt;- colortable(map_1b) head(coltab) ## [1] &quot;#000000&quot; &quot;#FFFFFF&quot; &quot;#D6EBD8&quot; &quot;#BDDFB5&quot; &quot;#A5CF91&quot; &quot;#53A935&quot; scales::show_col(coltab,labels = FALSE) In order to plot this RasterLayer in ggplot, we need to convert it into a dataframe. You can imagine that this is converting the wide matrix into a very long table with three columns: x and y coordinates of the lower left corner of each cell and a value specifying what the cell holds. map_1b_df &lt;- data.frame(coordinates(map_1b),values = getValues(map_1b)) head(map_1b_df) ## x y values ## 1 2599001 1197999 37 ## 2 2599004 1197999 37 ## 3 2599006 1197999 37 ## 4 2599009 1197999 37 ## 5 2599011 1197999 37 ## 6 2599014 1197999 37 We can now use the values column in ggplot2 to specify the fill aesthetic. If we then pass the colortable as our fill values, the colours will be matched correctly. However we need two additional tricks: name the colourtable to make sure the correct colours are correct to the according values wrap the values column in factor() so that the ggplot2 does not mistake the numeric values as a continuous scale: names(coltab) &lt;- 0:255 # 1:256 would be wrong by 1 ggplot() + geom_raster(data = map_1b_df, aes(x,y, fill = factor(values))) + scale_fill_manual(values = coltab) + theme(legend.position = &quot;none&quot;) + coord_equal() Note that there are thee ways to plot this type of data in ggplot2: geom_rect, geom_tile and geom_raster. The latter is a high performance special case for when all the tiles are the same size (see the docs. Alternatively, you can add the hex colourcode to the dataframe and use scale_fill_identitiy(). map_1b_df &lt;- mutate(map_1b_df, colorvalue = coltab[values+1]) ggplot() + geom_raster(data = map_1b_df, aes(x,y, fill = colorvalue)) + scale_fill_identity() + theme(legend.position = &quot;none&quot;) + coord_equal() The big drawback of using ggplot2 in this way: you cannot add a second layer with a fill aesthetic, since ggplot2 only allows one per plot. 3.1.1.2.1.2 Multiple bands In case of a 3-Band Raster Brick, each layer holds a value of 0 to 255 representing colours in the RGB colour model. Usually, the first layer represents Red, the second Green and the third Blue. We can subset the RasterBrick into the individual RasterLayers using double brackets ([[1]] for the first layer). map_3b ## class : RasterBrick ## dimensions : 400, 400, 160000, 3 (nrow, ncol, ncell, nlayers) ## resolution : 5, 5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/bako/Desktop/Projekte/All_thing_R_Spatial/github/spatialR_for_ArcGIS_Users/sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif ## names : SMR50_LV95_KREL_10L_Mosaic.1, SMR50_LV95_KREL_10L_Mosaic.2, SMR50_LV95_KREL_10L_Mosaic.3 ## min values : 0, 0, 0 ## max values : 255, 255, 255 map_3b[[1]] ## class : RasterLayer ## band : 1 (of 3 bands) ## dimensions : 400, 400, 160000 (nrow, ncol, ncell) ## resolution : 5, 5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/bako/Desktop/Projekte/All_thing_R_Spatial/github/spatialR_for_ArcGIS_Users/sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif ## names : SMR50_LV95_KREL_10L_Mosaic.1 ## values : 0, 255 (min, max) As with the singleband raster, we can extract the Values (this time RGB-Values) of each layer with getValues(). head(values(map_3b[[1]]),50) ## [1] 27 27 31 27 67 124 124 124 124 123 123 123 122 123 122 66 27 57 97 ## [20] 113 123 123 124 100 68 68 68 68 68 68 68 36 27 27 27 27 38 117 ## [39] 105 97 97 100 111 119 54 27 27 27 27 66 Again like with the single band raster, we now transform the Raster into a dataframe, this time storing the rgb values in columns (instead of the hex values as before). map_3b_df &lt;- data.frame( coordinates(map_3b), r = values(map_3b[[1]]), g = values(map_3b[[2]]), b = values(map_3b[[3]])) head(map_3b_df) ## x y r g b ## 1 2599003 1197998 27 26 35 ## 2 2599008 1197998 27 26 35 ## 3 2599013 1197998 31 28 36 ## 4 2599018 1197998 27 26 35 ## 5 2599023 1197998 67 59 58 ## 6 2599028 1197998 124 114 110 With the function rbg() we can transform values into hex-codes. rgb(10,10,10,maxColorValue = 255) ## [1] &quot;#0A0A0A&quot; ggplot() + geom_raster(data = map_3b_df, aes(x,y,fill = rgb(r,g,b,maxColorValue = 255))) + scale_fill_identity() + coord_equal() Tipp: if your file is to large and ggplot has trouble plotting it fast, you can use aggregate to reduce the resolution map_3b_lowres &lt;- raster::aggregate(map_3b, fact = 5) 3.1.1.2.2 Greyscale In greyscale maps, raster cannot find a associated colortable to match the values to rgb or hex colours. map_grey_path &lt;- &quot;sample_data/SMR_Musterdaten/SMR50_LV95_KGRS_Mosaic.tif&quot; map_grey &lt;- raster(map_grey_path) head(getValues(map_grey)) ## [1] 31 31 31 31 31 31 head(colortable(map_grey)) ## [1] &quot;#000000&quot; &quot;#FFFFFF&quot; &quot;#F4F4F4&quot; &quot;#E7E7E7&quot; &quot;#D3D2D3&quot; &quot;#CAC9CA&quot; However, the package tiff can find the rgb values of a tiff, we just need to set indexed = TRUE and get the color.map attribute of the output: library(tiff) index &lt;- readTIFF(map_grey_path,indexed = TRUE) colormap &lt;- attr(index,&quot;color.map&quot;) colormap[,1:8] # only showing the first 8 columns (of 256) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 0 1 0.9568627 0.9058824 0.8274510 0.7921569 0.7843137 0.7725490 ## [2,] 0 1 0.9568627 0.9058824 0.8235294 0.7882353 0.7803922 0.7686275 ## [3,] 0 1 0.9568627 0.9058824 0.8274510 0.7921569 0.7843137 0.7725490 This is an index with three rows (Red, Green and Blue) and 265 columns (with are the Values from getValues()). We can now use rgb() to turn this matrix into a vector of 265 hex colours: coltab &lt;- rgb(colormap[1,],colormap[2,],colormap[3,]) scales::show_col(coltab,labels = FALSE) Like before, we now turn the RasterLayer into a dataframe and use the Values and the newly created colortable to assign the correct values: map_grey_df &lt;- data.frame(coordinates(map_grey),values = getValues(map_grey)) names(coltab) &lt;- 0:255 ggplot() + geom_raster(data = map_grey_df, aes(x,y, fill = factor(values))) + scale_fill_manual(values = coltab) + theme(legend.position = &quot;none&quot;) + coord_equal() "],["making-interactive-maps.html", "3.2 Making Interactive Maps", " 3.2 Making Interactive Maps Probably one of the first things you want to do when working with a dataset is visualizing it spatially. This is basically always the first thing you do in ArcGIS. So how do you this in R? If your aim is to explore the data, to just get a feel for it, your map needs to: allow pan and zoom display attribute information in popups provide a background map be easy to make Before you start making maps however, you will have to familiarize yourself with importing raster or vector data into R in the first place. For Vector data, you can read chapter 2.2 Vector data from the book Geocomputation with R. The next chapter 2.3 Raster data provides a very good overview on rasterdata in R There are many packages that provide these features. leaflet mapview tmap In terms of simplicity, versatility and scalability tmap is one of the best in my option. 3.2.1 Introduction to tmap To see how it works, import the usual libraries and the North Carolina Sample data. library(sf) library(tidyverse) library(tmap) nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;),quiet = TRUE) Heres how the data looks in base plot: tmap has two modes: a static mode for printable maps (called plot) and a dynamic mode for exploratory, interactive maps (called view). We want the latter for now, so we switch to the dynamic mode with: tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing tmap has based its syntax loosely on ggplot2: Mainly, layer are added with + and aesthetics are specified within each layer. tm_shape(nc) + tm_polygons() You can have a look at the attributes of each feature by clicking on it. To view the entire attribute table, you can print nc to the console, or have a look at it with View(nc) if you are using Rstudio. Check the following resources for more information: https://github.com/mtennekes/tmap https://geocompr.robinlovelace.net/adv-map.html#interactive-maps "],["basic-spatial-operations.html", "4 Basic spatial operations", " 4 Basic spatial operations "],["select-by-attribute.html", "4.1 Select by Attribute", " 4.1 Select by Attribute One of the popular approaches in ArcGIS pro for selecting features in a layer is by using an attribute query. The action is performed using the Select By Attributes tool. Select By Attributes tool allows us to provide an SQL query expression to select features that match the selection criteria. R on the other hand offers quite easy and straightforward options to perform similar operations. Lets examine one of them. As a first step, we might want to import a shapefile. To do so, we can use sf package to work with vector data in R. Important to know is that the rgdal package automatically loads when sf is loaded. In the code snippet below, we read the shapefile, which represents the parking spots for bicycles within the canton of Zurich. The dataset is publicly available for download in the following link: (https://opendata.swiss/en/dataset/veloparkierungsanlagen). library(sf) library(ggplot2) parkBikes &lt;- st_read(&quot;sample_data/Kanton_Zuerich/Veloparkierungsanlagen/OGD_VELOPARKIERANLAGEN_P.shp&quot;) ## Reading layer `OGD_VELOPARKIERANLAGEN_P&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\Kanton_Zuerich\\Veloparkierungsanlagen\\OGD_VELOPARKIERANLAGEN_P.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 511 features and 28 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2669965 ymin: 1229454 xmax: 2707390 ymax: 1280235 ## projected CRS: CH1903+ / LV95 After importing the dataset, lets say we want to filter it by selecting only the parking spots that lie within a specific municipality (Gemeinde) in the canton of Zurich. More specifically, we will select only the parking spots within the municipality of Winterthur. For the aforementioned operation, R offers the function filter(), which lies within the dplyr package. This functions works as follows: filter(dataset, condition) library(dplyr) parkBikes_winti &lt;- filter(parkBikes,GEMEINDE == &quot;Winterthur&quot;) The operation above produces the same outcome as the one depicted in the figure below 4.1. Figure 4.1: Select by Attributes in ArcGIS pro "],["select-by-location.html", "4.2 Select by Location", " 4.2 Select by Location One of the most commonly used operations in ArcGIS pro is the process of selecting features of a spatial object (layer) based on whether or not these relate spatially to another object (layer). This process is also referred as spatial subsetting. In ArcGIS pro this can be performed in various ways using the Select by Location tool. In R the same operation is, on a first level, performed using the square bracket ([]) operator from the base R package. An example of spatial subsetting could be the following. Lets assume we have as a shapefile (polygon dataframe) with all the municipalities (Gemeinde) of the Canton of Zurich. Furthermore, we are also using a shapefile in the form of a point dataframe, which represents all the swimming spots (Badenplätze) in the same spatial region (Canton of Zurich). So, ultimately, our goal is to find out the swimming spots that lie within a specific municipality of the Canton of Zurich. # Minicipalities (Gemeinde) in Canton Zurich gemeinde_ZH &lt;- st_read(&quot;sample_data/Kanton_Zuerich/Gemeinde_ZH.shp&quot;) ## Reading layer `Gemeinde_ZH&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\Kanton_Zuerich\\Gemeinde_ZH.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 166 features and 7 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: 2669245 ymin: 1223896 xmax: 2716900 ymax: 1283343 ## projected CRS: CH1903+ / LV95 # &quot;Swimming&quot; spots in the Canton of Zurich swimmSpots &lt;- st_read(&quot;sample_data/Kanton_Zuerich/Badeplaetze_ZH.shp&quot;) ## Reading layer `Badeplaetze_ZH&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\Kanton_Zuerich\\Badeplaetze_ZH.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 71 features and 6 fields ## geometry type: POINT ## dimension: XY ## bbox: xmin: 2671636 ymin: 1226720 xmax: 2710101 ymax: 1282760 ## projected CRS: CH1903+ / LV95 After importing and depicting the swimming spots throughout the canton of Zurich, lets assume we want to check if and how many of them lie within the Municipality of Richterswil. To do so, we will perform an operation, which belongs to the category of Spatial subsetting. swimmSpots_richt &lt;- swimmSpots[richterswil, ,op = st_within] The operation above is based on the following rule: x[y, ,operation], where: div.note { background-color:#f0f0f0; border-radius: 5px; padding: 20px;} x and y are the spatial objects for which we want to investigate if there is a spatial relationship (x is the target feature, while y is the source one) the second argument [, ,] within the brackets denotes the column number we want to retrieve from the spatial subsetting. In our example this argument was empty, which means we wanted to retrieve all rows for every attribute column. the third argument [op = ] specifies the spatial operation we want to perform. In the example above, the goal was to find out how many subset features of the target object swimmSpots lie withing the source spatial object richterswil. For that reason we chose the function st_within(). Depending on what we want to examine, we choose the respective function. "],["data-management-toolbox.html", "5 Data Management Toolbox ", " 5 Data Management Toolbox "],["joins-toolset.html", "5.1 Joins Toolset", " 5.1 Joins Toolset In R we have two main options for merging two data frames. On the one hand there is the base R function called merge. The arguments of the merge() function offers the option to perform natural joins. In other words joins such as inner join, left join, right join etc. On the other hand we can come up with similar results by using the join functions that lie within the dplyr package. In the examples below, we choose to use the later case. Before we begin with our examples, we have to make clear the differences among the various forms of join operations. Natural join or Inner Join reflects on keeping only rows that match from the two data frames. Full outer join or Outer Join reflects on keeping all rows from both data frames. Figure 5.1: Join operations 5.1.1 Inner join Inner Join in R is the most common type of join. It is an operation that returns the rows when the matching condition is fulfilled. Below we demonstrate it with an example. library(dplyr) df1 &lt;- data.frame(TeamID = c(1,4,6,11), TeamName = c(&quot;new york knicks&quot;,&quot;los angeles lakers&quot;,&quot;milwaukee bucks&quot;,&quot;boston celtics&quot;), Championships = c(2,17,1,17)) df2 &lt;- data.frame(TeamID = c(1,2,11,8), TeamName = c(&quot;new york knicks&quot;,&quot;philadelphia 76ers&quot;,&quot;boston celtics&quot;,&quot;los angeles clippers&quot;), Championships = c(2,3,17,0)) df_innerJoin &lt;- df1 %&gt;% inner_join(df2, by = NULL) df_innerJoin ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 11 boston celtics 17 5.1.2 Outer join Outer join in R using simply returns all rows from both data frames. This is very well depicted in 5.1. df_fullJoin &lt;- full_join(df1,df2) df_fullJoin ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 4 los angeles lakers 17 ## 3 6 milwaukee bucks 1 ## 4 11 boston celtics 17 ## 5 2 philadelphia 76ers 3 ## 6 8 los angeles clippers 0 5.1.3 Left / Right join The left join in R returns all records from the data frame on the left, as well as and the matched records from the one at the right. df_leftJoin &lt;- left_join(df1,df2) df_leftJoin ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 4 los angeles lakers 17 ## 3 6 milwaukee bucks 1 ## 4 11 boston celtics 17 Similarly works also the right join. df_rightJoin &lt;- right_join(df1,df2) df_rightJoin ## TeamID TeamName Championships ## 1 1 new york knicks 2 ## 2 11 boston celtics 17 ## 3 2 philadelphia 76ers 3 ## 4 8 los angeles clippers 0 "],["projections-and-transformations-toolset.html", "5.2 Projections and Transformations Toolset", " 5.2 Projections and Transformations Toolset Quite often in GIS, users found themselves before the necessity of transforming (reprojecting) the coordinate system of a dataset (vector or raster). In fact this is one of the most commonly used operations. In ArcGIS pro the aforementioned action is performed using the following tools: Project (Data Management) -&gt; Projects spatial data from one coordinate system to another. Project Raster (Data Management) -&gt; Transforms a raster dataset from one coordinate system to another. The question now is how we can perform similar operations with R. 5.2.1 Reproject vector data in R For our example we will use the following dataset. bezirke.gpkg -&gt; Dataset that depicts the Municipal structure in Switzerland R and more specifically sf package offers options (functions) not only for transforming the coordinate system of a dataset, but also for identifying the current existing one. Lets dive in :) # Importing the dataset library(sf) bezirke &lt;- read_sf(&quot;sample_data/other/bezirke.gpkg&quot;) # Visualising the imported dataset library(ggplot2) ggplot() + geom_sf(data = bezirke) In order to identify the current coordinate system of a dataset, sf package offers the function st_crs. The main usage of the function is to retrieve the coordinate reference system from an sf object. # retrieving the coordinate of the imported layer st_crs(bezirke) ## Coordinate Reference System: NA As an output we received that there is no assigned coordinate system to this specific dataset. st_set_crs function helps us assigning a coordinate system to a dataset. # Assigning the World Geodetic System (WGS84) as a coordinate system to our dataset bezirke &lt;- st_set_crs(bezirke, 4326) In the function above, the number 4326 represents the EPSG Geodetic Parameter Dataset (EPSG) of the respective coordinate system. EPSG is a public registry of geodetic datums, spatial reference systems, Earth ellipsoids, coordinate transformations and related units of measurement. st_crs(bezirke) ## Coordinate Reference System: ## User input: EPSG:4326 ## wkt: ## GEOGCRS[&quot;WGS 84&quot;, ## DATUM[&quot;World Geodetic System 1984&quot;, ## ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## CS[ellipsoidal,2], ## AXIS[&quot;geodetic latitude (Lat)&quot;,north, ## ORDER[1], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## AXIS[&quot;geodetic longitude (Lon)&quot;,east, ## ORDER[2], ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;World&quot;], ## BBOX[-90,-180,90,180]], ## ID[&quot;EPSG&quot;,4326]] After rerunning the st_crs function, we are getting now that the assigned coordinate system of the dataset is World Geodetic System (WGS84). As a next step, we might want to transform the dataset to the Swiss coordinate system. The respective EPSG for code for the latest Swiss coordinate system (CH1903+LV95) is 2056. For this purpose we use the st_transform function of the sf package. Important &gt; Click to expand! st_set_crs function does not reproject the coordinates of the given dataset. In other words, it does not affect the actual geometry column of the sf object. st_tranform on the other hand indeed does indeed reproject the dataset to another coordinate system. bezirke_swiss &lt;- st_transform(bezirke, 2056) # retrieve the coordinate system st_crs(bezirke_swiss) ## Coordinate Reference System: ## User input: EPSG:2056 ## wkt: ## PROJCRS[&quot;CH1903+ / LV95&quot;, ## BASEGEOGCRS[&quot;CH1903+&quot;, ## DATUM[&quot;CH1903+&quot;, ## ELLIPSOID[&quot;Bessel 1841&quot;,6377397.155,299.1528128, ## LENGTHUNIT[&quot;metre&quot;,1]]], ## PRIMEM[&quot;Greenwich&quot;,0, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], ## ID[&quot;EPSG&quot;,4150]], ## CONVERSION[&quot;Swiss Oblique Mercator 1995&quot;, ## METHOD[&quot;Hotine Oblique Mercator (variant B)&quot;, ## ID[&quot;EPSG&quot;,9815]], ## PARAMETER[&quot;Latitude of projection centre&quot;,46.9524055555556, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8811]], ## PARAMETER[&quot;Longitude of projection centre&quot;,7.43958333333333, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8812]], ## PARAMETER[&quot;Azimuth of initial line&quot;,90, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8813]], ## PARAMETER[&quot;Angle from Rectified to Skew Grid&quot;,90, ## ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], ## ID[&quot;EPSG&quot;,8814]], ## PARAMETER[&quot;Scale factor on initial line&quot;,1, ## SCALEUNIT[&quot;unity&quot;,1], ## ID[&quot;EPSG&quot;,8815]], ## PARAMETER[&quot;Easting at projection centre&quot;,2600000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8816]], ## PARAMETER[&quot;Northing at projection centre&quot;,1200000, ## LENGTHUNIT[&quot;metre&quot;,1], ## ID[&quot;EPSG&quot;,8817]]], ## CS[Cartesian,2], ## AXIS[&quot;(E)&quot;,east, ## ORDER[1], ## LENGTHUNIT[&quot;metre&quot;,1]], ## AXIS[&quot;(N)&quot;,north, ## ORDER[2], ## LENGTHUNIT[&quot;metre&quot;,1]], ## USAGE[ ## SCOPE[&quot;unknown&quot;], ## AREA[&quot;Europe - Liechtenstein and Switzerland&quot;], ## BBOX[45.82,5.96,47.81,10.49]], ## ID[&quot;EPSG&quot;,2056]] 5.2.2 Reproject raster data in R Working with Raster datasets in GIS of operations is of equal importance, as working with vector ones. One of the spatial properties of raster datasets is the the Coordinate Reference System (CRS). CRS is the specific system that associates the raster coordinates (which are just pairs of x/y values) to geographic locations. In ArcGIS pro the tool for projecting a raster dataset is called Project Raster (Data Management). Lets see how we can perform the same operation with R. # Importing the datasets library(raster) # Dataset derived from the spatial interpolation of all the available &quot;recycling points&quot; # in the city of Wädenwil raster_recycling &lt;- raster(&quot;sample_data/Raster/raster_recycling.tif&quot;) # CRS -&gt; CH1903+LV95 # Dataset representing the public transport quality in the city of Wädenswil publicTransport &lt;- raster(&quot;sample_data/Raster/publicTransport_waedi.tif&quot;) # CRS -&gt; WGS84 # Plot the raster dataset - World Geodetic System 1984 plot(publicTransport,las=1, main = &quot;Quality of public transport in the city of Wädenwil - CRS: WGS84&quot;, cex.main=1,font.main=4) We can use the projectRaster() function to reproject a raster into a new CRS. The first argument of the aforementioned function is the raster dataset we want to reproject, while the second one is the dataset to whose projection we are targeting to. So, in our case, we are targeting to the coordinate system of the raster_recycling dataset. It is important to remember that raster reprojection only works when the raster object has already a defined CRS. # Transform the coordinate system of the raster dataset publicTransport_CH # into the Swiss Coordinate system - CH1903+LV95 publicTransport_CH = projectRaster(publicTransport, raster_recycling) # Plot the raster dataset - Swiss Coordinate System CH1903+LV95 plot(publicTransport_CH,las=1, main = &quot;Quality of public transport in the city of Wädenwil - CRS: CH1903+LV95&quot;, cex.main=1,font.main=4) 5.2.3 Generate Tessellation Hexagon Tranverse Hexagon Square Diamond Triangle &gt; 5.2.3.1 Clip Raster In GIS operations is quite common the necessity of clipping an area based on some specific region of interest. This is a quite useful and necessary procedure not only when we are dealing with vector datasets, but also when we have to work with raster ones. In ArcGIS pro the procedure of cutting a portion of a raster dataset, mosaic dataset, or an image service layer is performed using Clip Raster tool. In R, the respective operation can be performed using the mask() function. For the example below, we are using the following datasets: ARE_waedi: Vector dataset that depicts the public transport connection quality in the city of Wädenswil raster_recycling: Dataset derived from the spatial interpolation of all the available recycling pointsin the city of Wädenwil # Read raster dataset library(raster) library(stars) library(sf) library(dplyr) library(stars) # Insert a vector dataset that depicts the public transport connection quality in # the city of Wädenswil and plot it ARE_waedi &lt;- read_sf(&quot;sample_data/Entsorgung_Waedenswil/ARE_waedenswil.shp&quot;) # Read the raster dataset and plot it raster_recycling &lt;- raster(&quot;sample_data/Entsorgung_Waedenswil/abfall_raster.tif&quot;) Plot the two datasets one over the other. In our case, the vector dataset serves as the clipping extent for the clipping operation. recycle_Waedi_clip &lt;- mask(raster_recycling,ARE_waedi) Visualising the clipped output library(sf) library(tidyverse) library(raster) "],["spatial-analyst-toolbox.html", "6 Spatial Analyst Toolbox", " 6 Spatial Analyst Toolbox 6.0.1 Kernel Denisity There are several Function that can be tweaked to calculate KDE for sf-Point object: tmaptools::smooth_map(): Depricated (is there a successor?) spatstat::density.ppp(): Takes only objects of Class ppp MASS::kde2d(): Takes x/y coordinates as vectors and returns a matrix In this example, I take MASS:kde2d() and tweak it to take sf and return raster. First, lets create some sample data: set.seed(10) mypoints &lt;- data.frame(x = rnorm(1000),y = rnorm(1000)) %&gt;% st_as_sf(coords = c(1,2)) plot(mypoints) my_kde &lt;- function(points,cellsize, bandwith, extent = NULL){ require(MASS) require(raster) require(sf) if(is.null(extent)){ extent_vec &lt;- st_bbox(points)[c(1,3,2,4)] } else{ extent_vec &lt;- st_bbox(extent)[c(1,3,2,4)] } n_y &lt;- ceiling((extent_vec[4]-extent_vec[3])/cellsize) n_x &lt;- ceiling((extent_vec[2]-extent_vec[1])/cellsize) extent_vec[2] &lt;- extent_vec[1]+(n_x*cellsize)-cellsize extent_vec[4] &lt;- extent_vec[3]+(n_y*cellsize)-cellsize coords &lt;- st_coordinates(points) matrix &lt;- kde2d(coords[,1],coords[,2],h = bandwith,n = c(n_x,n_y),lims = extent_vec) raster(matrix) } mypoints_kde &lt;- my_kde(mypoints,0.01,1) library(stars) ggplot() + geom_stars(data = st_as_stars(mypoints_kde)) + geom_sf(data = mypoints, alpha = 0.2, fill = &quot;black&quot;) + scale_fill_viridis_c() + labs(fill = &quot;KDE&quot;) + theme_void() "],["reclass-toolset.html", "6.1 Reclass Toolset", " 6.1 Reclass Toolset 6.1.1 Slope and Aspect In mathematics, the slope or gradient of a line describes its steepness, incline, or grade. A higher slope value indicates a steeper incl. Source: http://wiki.gis.com/wiki/index.php/Slope In GIS and specifically in terrain analysis, calculating the terrain slope is of great importance, since it can play a significant role in various forms of technical analysis. The most common way of calculating the slope is from a Digital Elevation Model (DEM). In ArcGIS pro the tool used for computing the slope of a raster dataset with elevation data is called Slope (3D Analyst).It identifies the steepness at each cell of a raster surface. The lower the slope value, the flatter the terrain; the higher the slope value, the steeper the terrain. In R, raster package includes the function terrain(), which helps us compute slope, aspect and other terrain characteristics from a raster with elevation data. Lets start by computing the slope of the swissAlti3d raster dataset. # Importing a raster dataset # swissALTI3D2019.tif -- Source: https://geovite.ethz.ch library(raster) swissAlti3d &lt;- raster(&quot;sample_data/Raster/swissALTI3D2019.tif&quot;) plot(swissAlti3d, main = &quot;swissALTI3D2019 - CRS: CH1903+LV95&quot;, cex.main=1,font.main=4) After importing and visualizing our raster dataset, we use the terrain function to calculate the slope. # Computing the slope of a raster dataset using the terrain() function swissAlti3d_slope &lt;- terrain(swissAlti3d, opt=&quot;slope&quot;, unit=&quot;degrees&quot;) plot(swissAlti3d_slope, main = &quot;Slope of swissALTI3D2019 in degrees (°)&quot;, cex.main=1,font.main=4) In the function above, we define the operation we want to perform as the second argument of the function (opt = slope). Furthermore, we also define the units of the final result. Similarly, we compute the aspect of a given dataset. Basically as aspect we can consider the compass direction that a slope leans towards. Lets compute now, using again the same function terrain, the aspect of the same dataset swissALTI3D2019. # Computing the aspect of the terrain dataset swissAlti3d_aspect &lt;- terrain(swissAlti3d, opt=&quot;aspect&quot;, unit=&quot;degrees&quot;) plot(swissAlti3d_aspect, main = &quot;Aspect of swissALTI3D2019 in degrees (°)&quot;, cex.main=1,font.main=4) So, R gives us the option to retrieve multiple terrain characteristics of a raster dataset, using only one function. The aforementioned spatial operation in ArcGIS pro could be performed using the tool Aspect (Spatial Analyst). 6.1.2 Reclassify In GIS quite often arises the necessity to reclassify a raster dataset. In other words, to create new classes with different range of values for the existing cell values of the dataset. This operation in ArcGIS Pro is performed using the Reclassify (Spatial Analyst) tool. In R the respective operation is quite straightforward and is based on the use of the reclassify function of the raster package. For our example we use the raster dataset we computed previously, which depicts the aspect of the swissALTI3D2019 dataset. As a first step, we can compute the histogram of our dataset. summary(swissAlti3d_aspect) ## aspect ## Min. 0.0000 ## 1st Qu. 104.1014 ## Median 163.3606 ## 3rd Qu. 258.6777 ## Max. 359.9991 ## NA&#39;s 12652.0000 histinfo &lt;- hist(swissAlti3d_aspect) histinfo$breaks ## [1] 0 20 40 60 80 100 120 140 160 180 200 220 240 260 280 300 320 340 360 The number of breaks for our raster values are 19. The aim of ours is to create 4 different classes with the following values: 0°-90° -&gt; Class 1 90°-180° -&gt; Class 2 180°-270° -&gt; Class 3 270°-360° -&gt; Class 4 To do so, we create below a reclassification matrix with the respective values. # create a reclassification matrix reclass_df &lt;- c(0,90,1,90,180,2,180,270,3,270,360,4) # convert to Matrix reclass_m &lt;- matrix(reclass_df, ncol = 3, byrow = TRUE) reclass_m ## [,1] [,2] [,3] ## [1,] 0 90 1 ## [2,] 90 180 2 ## [3,] 180 270 3 ## [4,] 270 360 4 After creating the respective matrix with the new classes, we are ready to call the reclassify function. The function takes as a first argument the dataset set to be reclassified and as second the matrix, on which the reclassification is based on. swissAlti3d_aspect_reclass &lt;- reclassify(swissAlti3d_aspect, reclass_m) plot(swissAlti3d_aspect_reclass, col = c(&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;,&quot;blue&quot;), main = &quot;Aspect of swissALTI3D2019 in 4 classes&quot;, cex.main=1,font.main=4, legend = FALSE) legend(&quot;topright&quot;, legend = c(&quot;0°-90°&quot;, &quot;90°-180°&quot;, &quot;180°-270°&quot;,&quot;270°-360°&quot;), fill = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;), border = FALSE, bty = &quot;n&quot;) # turn off legend border "],["d-analyst-toolbox.html", "7 3D Analyst Toolbox ", " 7 3D Analyst Toolbox "],["raster-interpolation-toolset.html", "7.1 Raster Interpolation Toolset", " 7.1 Raster Interpolation Toolset library(sp) library(sf) library(tidyverse) library(stars) data(meuse) meuse_sf &lt;- meuse %&gt;% st_as_sf(coords = c(&quot;x&quot;,&quot;y&quot;)) 7.1.1 IDW my_idw &lt;- function(groundtruth,column,cellsize, nmax = Inf, maxdist = Inf, idp = 2, extent = NULL){ require(gstat) require(sf) require(raster) if(is.null(extent)){ extent &lt;- groundtruth } samples &lt;- st_make_grid(extent,cellsize,what = &quot;centers&quot;) %&gt;% st_as_sf() my_formula &lt;- formula(paste(column,&quot;~1&quot;)) idw_sf &lt;- gstat::idw(formula = my_formula,groundtruth,newdata = samples,nmin = 1, maxdist = maxdist, idp = idp) idw_matrix &lt;- cbind(st_coordinates(idw_sf),idw_sf$var1.pred) ras &lt;- raster::rasterFromXYZ(idw_matrix) if(all(grepl(&quot;polygon&quot;,st_geometry_type(extent),ignore.case = TRUE))){ ras &lt;- raster::mask(ras,st_as_sf(st_zm(extent))) } ras } meuse_idw &lt;- my_idw(meuse_sf,&quot;copper&quot;,cellsize = 10,idp = 3) ## [inverse distance weighted interpolation] ggplot() + geom_stars(data = st_as_stars(meuse_idw)) + scale_fill_viridis_c() + theme_void() + labs(fill = &quot;copper&quot;) + coord_equal() 7.1.2 Kriging my_krige &lt;- function(groundtruth,column,cellsize, nmax = Inf, maxdist = Inf, extent = NULL){ require(gstat) require(sf) require(raster) if(is.null(extent)){ extent &lt;- groundtruth } samples &lt;- st_make_grid(extent,cellsize,what = &quot;centers&quot;) %&gt;% st_as_sf() my_formula &lt;- formula(paste(column,&quot;~1&quot;)) idw_sf &lt;- gstat::krige(formula = my_formula,groundtruth,newdata = samples,nmin = 1, maxdist = maxdist) idw_matrix &lt;- cbind(st_coordinates(idw_sf),idw_sf$var1.pred) ras &lt;- raster::rasterFromXYZ(idw_matrix) if(all(grepl(&quot;polygon&quot;,st_geometry_type(extent),ignore.case = TRUE))){ ras &lt;- raster::mask(ras,st_as_sf(st_zm(extent))) } ras } meuse_krige &lt;- my_krige(meuse_sf,&quot;copper&quot;,cellsize = 10,nmax = 30, maxdist = 500) ## [inverse distance weighted interpolation] ggplot() + geom_stars(data = st_as_stars(meuse_krige)) + scale_fill_viridis_c(na.value = NA) + theme_void() + labs(fill = &quot;copper&quot;) + coord_equal() 7.1.3 Natural Neighbor Nearest Neighbor: meuse_thiessen &lt;- st_voronoi(st_union(meuse_sf)) meuse_thiessen &lt;- st_cast(meuse_thiessen) meuse_bbox &lt;- meuse_sf %&gt;% st_bbox() %&gt;% st_as_sfc() meuse_thiessen &lt;- st_intersection(meuse_thiessen,meuse_bbox) meuse_thiessen &lt;- st_as_sf(meuse_thiessen) meuse_thiessen &lt;- st_join(meuse_thiessen,meuse_sf) ggplot() + geom_sf(data = meuse_thiessen, aes(fill = copper)) + geom_sf(data = meuse_sf) + scale_fill_viridis_c() + theme_void() "],["image-analysis-toolbox.html", "8 Image Analysis Toolbox ", " 8 Image Analysis Toolbox "],["map-algebra-toolset.html", "8.1 Map Algebra Toolset", " 8.1 Map Algebra Toolset 8.1.1 Raster Calulator In GIS Softwares (ArcGIS pro, QGIS etc) Raster Calculator is one of the most commonly used tools for performing various operations with raster datasets. Lets explore our options for performing similar tasks with R. library(raster) pop_2000 &lt;- raster(&quot;sample_data/population_raster/gpw_v4_population_count_rev11_2000_2pt5_min.tif&quot;) pop_2010 &lt;- raster(&quot;sample_data/population_raster/gpw_v4_population_count_rev11_2010_2pt5_min.tif&quot;) par(mfrow=c(1,2)) plot(pop_2000) plot(pop_2010) 8.1.2 Focal Statistics Focal statistics performs a neighbourhood operation that computes an output raster, where the value for each output cell is a function of the values of all the input cells that are in a specified neighborhood around that location. The function performed on the input is a statistic, such as the maximum, average, or sum of all values encountered in that neighborhood. Source: https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-analyst/how-focal-statistics-works.html In R in order to apply functions focally to rasters, important is to define the neighbouring cells. In other words to define the moving window for each of these functions. As an example below, we will create our own raster object. library(raster) r &lt;- raster(ncol=10, nrow=10) values(r) &lt;- 1:ncell(r) plot(r, main=&#39;Raster with 100 cells&#39;, cex.main = 1) We will recompute now the raster based on the focal function of the raster package. In the function below, the neighbourhood for which we apply the statistic is represented by the argument w, while the statistic by the argument fun. f1 &lt;- focal(r, w=matrix(1,nrow=3,ncol=3),fun=sum) plot(f1, main = &quot;Raster after applying the focal function - raster package&quot;, cex.main = 1) The operation above can be also performed with the use of the focal function of the terra package. w represents the moving window of the function. The window can be defined as one (for a square) or two numbers (row, col); or with an odd-sized weights matrix. More details can be found here: https://rdrr.io/cran/terra/man/focal.html fun represents the specified statistic for the identified neighbourhood (e.g mean,sum etc) library(terra) r_spat &lt;- as(r, &quot;SpatRaster&quot;) f2 &lt;- terra::focal(r_spat,w=3,fun = &quot;sum&quot;) plot(f2, main = &quot;Raster after applying the focal function - terra package&quot;, cex.main = 1) 8.1.3 Zonal Statistics Zonal Statistics tool in ArcGIS pro is used for calculating the statistics on values of a raster within the zones of another dataset. In R we are able to produce similar results with the use of zonal function of the raster package. x r &lt;- raster(ncols=10, nrows=10) # generating random numbers that will used as values in our raster layer (r) - input values raster values(r) &lt;- runif(ncell(r)) * 1:ncell(r) z &lt;- r # generating integer values for the raster layer z, which will be used as the zone raster values(z) &lt;- rep(1:5, each=20) # Zonal statistics - Summarize zonal(r, z, &quot;sum&quot;) ## zone sum ## [1,] 1 99.58052 ## [2,] 2 305.81367 ## [3,] 3 475.71375 ## [4,] 4 707.51735 ## [5,] 5 796.50114 # Zonal statistics - Mean zonal(r, z, &quot;mean&quot;) ## zone mean ## [1,] 1 4.979026 ## [2,] 2 15.290684 ## [3,] 3 23.785688 ## [4,] 4 35.375867 ## [5,] 5 39.825057 # Zonal statistics - Minimum zonal(r, z, &quot;min&quot;) ## zone min ## [1,] 1 0.1487266 ## [2,] 2 1.9187318 ## [3,] 3 3.1954170 ## [4,] 4 4.5574448 ## [5,] 5 2.8274044 "],["analysis-toolbox.html", "9 Analysis Toolbox", " 9 Analysis Toolbox 9.0.1 Clip Quite often in spatial analysis, we come across with cases, where we do not want to use all the available data there is. In other words, we want to focus on a specific area of interest, which dictates the need for clipping the existing dataset based on its relationship to some other existing spatial feature. In R this operation can be easily performed using the st_intersection function in sf. Lets assume in the example below that we want to clip the available dataset of all the train stations in Switzerland by focusing our analysis on four specific cantons. # Point dataset depicting the train stations locations across Switzerland bahn_haltestelle_ch &lt;- st_read(&quot;sample_data/other/Haltestelle_Bahn_CH.shp&quot;) ## Reading layer `Haltestelle_Bahn_CH&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\other\\Haltestelle_Bahn_CH.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 3134 features and 16 fields ## geometry type: POINT ## dimension: XYZ ## bbox: xmin: 2488908 ymin: 1076850 xmax: 2817389 ymax: 1289090 ## z_range: zmin: 194.905 zmax: 3453.525 ## projected CRS: CH1903+ / LV95 # Dataset depicting Switzerland on canton level kantonsgebiet &lt;- st_read(&quot;sample_data/other/Kantonsgebiet.shp&quot;) ## Reading layer `Kantonsgebiet&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\other\\Kantonsgebiet.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 56 features and 22 fields ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2485410 ymin: 1075268 xmax: 2833858 ymax: 1295934 ## z_range: zmin: 193.51 zmax: 4613.729 ## projected CRS: CH1903+ / LV95 tmap_mode(mode = c(&quot;plot&quot;)) # setting the plotting mode to static -- optimizing the process tm_shape(kantonsgebiet) + tm_polygons(&quot;#f0f0f0&quot;) + tm_shape(bahn_haltestelle_ch) + tm_dots(col = &quot;#e34a33&quot;,size = 0.1, alpha = 0.5) + tm_shape(kantonsgebiet) + tm_borders(col = &quot;black&quot;) + tm_layout(frame = F) As it was mentioned above, the aim is to analyse the situation at a particular area. So we are going to create an index with the specific cantons we are interested in. index &lt;- kantonsgebiet$name == &quot;Zürich&quot; | kantonsgebiet$name == &quot;St. Gallen&quot; | kantonsgebiet$name == &quot;Thurgau&quot; | kantonsgebiet$name == &quot;Aargau&quot; # Selecting the cantons based on the previously generated index kantons_aOi &lt;- kantonsgebiet[index,] # Performing the clipping operation hal_clipped &lt;- st_intersection(kantons_aOi,bahn_haltestelle_ch) Plotting the result from the clipping operation tm_shape(kantons_aOi) + tm_polygons(&quot;#f0f0f0&quot;) + tm_shape(hal_clipped) + tm_dots(col = &quot;#e34a33&quot;,size = 0.1, alpha = 0.5) + tm_shape(kantons_aOi) + tm_borders() + tm_layout(frame = F) So, ultimately, as we can see above, the st_intersection function creates a result where the point dataset is precisely clipped based on the area of interest The operation above produces the same outcome as the one depicted in the figure below 9.1. Figure 9.1: Clip operation in ArcGIS pro 9.0.2 Merge Lets assume in the example below that instead of having four individual areas of interest, we are interested in having one common, unified area on which we focus our analysis. In other words, we have to merge the existing four areas into one. In ArcGIS pro the respective tools for this action is either the Merge or the Dissolve tool. In R on the other hand, this can be easily performed using the st_union function in the sf package. # The area of interest from the previous example - section Clip kantons_aOi ## Simple feature collection with 12 features and 22 fields (with 5 geometries empty) ## geometry type: MULTIPOLYGON ## dimension: XYZ ## bbox: xmin: 2620698 ymin: 1193269 xmax: 2768769 ymax: 1283504 ## z_range: zmin: 260.666 zmax: 3246.858 ## projected CRS: CH1903+ / LV95 ## First 10 features: ## uuid datum_aend datum_erst erstellung ## 6 {05D55405-466B-4ECC-83C7-A906DEB0D607} 2017-12-04 2012-10-26 2012 ## 7 {FB7105B8-6D7C-4787-846E-17B2BC145C6E} 2018-11-22 2012-10-26 2012 ## 10 {E11CD2CA-2E2D-415C-8789-C10D7C26E441} 2016-12-09 2012-10-26 2012 ## 12 {87370D3F-DBBE-4D05-AF85-C358C3924B3D} 2018-11-22 2012-10-26 2012 ## 41 {99488953-65F6-4F86-8606-337113587F85} 2015-12-08 2012-10-26 2012 ## 47 {F1A07951-AC8B-4EBA-B48F-64BC8B92228C} 2015-12-08 2012-10-26 2012 ## 48 {784EB478-2D40-4620-80F8-ACC252A6FD02} 2015-12-08 2012-10-26 2012 ## NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA ## NA.1 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA ## NA.2 &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA ## erstellu_1 revision_j revision_m grund_aend herkunft herkunft_j herkunft_m ## 6 10 2019 1 400 100 2018 1 ## 7 10 2019 1 400 500 2019 1 ## 10 10 2019 1 400 100 2017 1 ## 12 10 2019 1 400 500 2019 1 ## 41 10 2019 1 400 500 2015 12 ## 47 10 2019 1 400 500 2015 12 ## 48 10 2019 1 400 500 2015 12 ## NA NA NA NA NA NA NA NA ## NA.1 NA NA NA NA NA NA NA ## NA.2 NA NA NA NA NA NA NA ## objektart kantonsnum see_flaech revision_q kantonsfla kanton_tei ## 6 0 17 7720 2018_Aufbau 202820 1 ## 7 0 1 6811 2018_Aufbau 172894 0 ## 10 0 19 870 2018_Aufbau 140380 1 ## 12 0 20 13121 2018_Aufbau 99433 1 ## 41 0 20 0 2018_Aufbau 0 2 ## 47 0 17 0 2018_Aufbau 0 2 ## 48 0 19 0 2018_Aufbau 0 2 ## NA NA NA NA &lt;NA&gt; NA NA ## NA.1 NA NA NA &lt;NA&gt; NA NA ## NA.2 NA NA NA &lt;NA&gt; NA NA ## name icc einwohnerz Shape_Leng Shape_Area ## 6 St. Gallen CH 504686 494074.195 2.028094e+09 ## 7 Zürich CH 1504346 312972.523 1.728942e+09 ## 10 Aargau CH 670988 328943.352 1.403783e+09 ## 12 Thurgau CH 273801 287778.920 9.905920e+08 ## 41 Thurgau CH 0 8640.269 3.737271e+06 ## 47 St. Gallen CH 0 1481.811 1.054068e+05 ## 48 Aargau CH 0 537.994 1.486573e+04 ## NA &lt;NA&gt; &lt;NA&gt; NA NA NA ## NA.1 &lt;NA&gt; &lt;NA&gt; NA NA NA ## NA.2 &lt;NA&gt; &lt;NA&gt; NA NA NA ## geometry ## 6 MULTIPOLYGON Z (((2703763 1... ## 7 MULTIPOLYGON Z (((2673542 1... ## 10 MULTIPOLYGON Z (((2673542 1... ## 12 MULTIPOLYGON Z (((2701937 1... ## 41 MULTIPOLYGON Z (((2751489 1... ## 47 MULTIPOLYGON Z (((2744263 1... ## 48 MULTIPOLYGON Z (((2675447 1... ## NA MULTIPOLYGON Z EMPTY ## NA.1 MULTIPOLYGON Z EMPTY ## NA.2 MULTIPOLYGON Z EMPTY # Merging the four areas into one aOi_merged &lt;- st_union(kantons_aOi) Plot the merged area of interest tm_shape(aOi_merged) + tm_polygons(&quot;#f0f0f0&quot;) + tm_layout(frame = F) The operation above produces the same outcome as the one depicted in the figure below 9.2. Figure 9.2: Dissolve operation in ArcGIS pro 9.0.3 Spatial Join Say you have two datasets: library(sf) library(tidyverse) zweitwohnung &lt;- read_sf(&quot;sample_data/other/zweitwohnung_gemeinden.gpkg&quot;) %&gt;% dplyr::filter(kanton == &quot;Valais / Wallis&quot;) %&gt;% select(NAME) bbox &lt;- st_bbox(zweitwohnung) %&gt;% st_as_sfc() points &lt;- st_sample(bbox,500) ggplot(zweitwohnung) + geom_sf() + geom_sf(data = points) In R, the function used to join two datastes is st_join(x,y). If you have to different data types (e.g. Points and Polygons) the first question you have to ask yourself is: what data type should the output be? The datatype of x determins what the output datatype is. So with the above data: Say for each point, we want to know the Name (NAME) of the Geimeinde in which it lies. This means the output is a point dataset. We therefore write: st_join(st_sf(points),zweitwohnung,join = st_within) Note that points not located in a Gemeinde get the value NA. You have to specify the spatial relationship of your join method within the argument join =. This argument take a so called spatial predicate function. From the join_methods available in ArcGIS, heres the equivalant spatial predicate function: ArcGIS Term R Spatial Predicate Intersect st_intersect Intersect 3D (1) Within a distance st_is_within_distance Within a distance geodesic ?? Within a distance 3D (1) Contains st_contains Completely contains st_contains_properly? Contains clementini ?? Within st_within Completely within Within clementini ?? Are identical to st_equals? boundry touches st_touches Share a line segment Have their center in Closest st_nearest_feature? Closest geodesic ?? All binary predicates only work on 2D Objects (see this issue) 9.0.4 Buffer One of the most commonly used operations in ArcGIS pro is the one called Buffer. This operation provides a very convenient way of identifying areas of interest lying in the neighborhood of an existing spatial feature. In R the same action can be performed using the st_buffer function in sf. Below we introduce a line spatial feature that depicts all the mountain bike routes in Switzerland. ## Reading layer `mountainBikes_routes&#39; from data source `C:\\Users\\bako\\Desktop\\Projekte\\All_thing_R_Spatial\\github\\spatialR_for_ArcGIS_Users\\sample_data\\other\\mountainBikes_routes.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 286 features and 29 fields ## geometry type: LINESTRING ## dimension: XYZ ## bbox: xmin: 2497570 ymin: 1077136 xmax: 2836678 ymax: 1296227 ## z_range: zmin: 197.367 zmax: 2860.725 ## projected CRS: CH1903+ / LV95 We focus, as an area of interest, on the canton of Valais. Consequently, we might be interested in identifying all the areas in a radius of 1000 m around these bike routes. Selecting the canton of Valais Apply a buffer of 1000m on each of the mountain bike routes within the canton of Valais routes_buffer &lt;- st_buffer(mountainBikes_routes_valais,1000) tm_shape(canton_valais) + tm_polygons() + tm_shape(mountainBikes_routes_valais) + tm_lines(col = &quot;#e34a33&quot;) + tm_shape(routes_buffer) + tm_polygons(col = &quot;blue&quot;, alpha = 0.2) + tm_shape(canton_valais) + tm_borders(col = &quot;black&quot;) + tm_layout(frame = F) The operation above produces the same outcome as the one depicted in the figure below 9.3. Figure 9.3: Buffer operation in ArcGIS pro "]]
