[
["index.html", "Burning the Bridges Spatial R for ArcGIS Users 1 TL;DR", " Burning the Bridges Spatial R for ArcGIS Users Nils Ratnaweera 1 TL;DR This is a ressource for people coming from ArcGIS who want to learn spatial stuff (Analysis, Visualization) in R. This ressource should provide some help on this journey. Who this book is for: you’ve worked primarily with ArcGIS and would like to transition to R you have some experience with R you don’t mind working with the tidyverse (if you don’t know what this is, you probabbly won’t mind) "],
["foreword.html", "2 Foreword", " 2 Foreword After tweeting this a couple of times, I decided to start my own ressource on the topic: “Spatial Stuff in R for People indoctrinated with ArcGIS”. I, like many, leared GIS in University using ArcGIS. It took me a considerable amount of time to learn that there are alternatives to ArcGIS, but not much longer to realize that I’m more attracted to these alternatives than to ArcGIS. When you transition from a proriatary Software like ArcGIS to FOSS, you have to relearn many of the concepts because the proprietery software usually does not adhere to common standards. There are already a great many spatial-R Ressources out there, and I’m not planning to rewrite everything that has been written. My aim is just to provide a resource for people looking to do spial stuff in R, but only know the ArcGIS-Term for it. This might mean that for some topics, I will simply provide a link to an existing ressource. "],
["making-maps.html", "3 Making Maps", " 3 Making Maps "],
["interactive-for-data-exploration.html", "3.1 Interactive (for Data Exploration)", " 3.1 Interactive (for Data Exploration) Probabbly one of the first things you want to do when working with a dataset is visualizing it spatially. This is basically always the first thing you do in ArcGIS. So how do you this in R? If your aim is to explore the data, to just get a feel for it, your map needs to: allow pan and zoom display attribute information in popups provide a background map be easy to make If all of these features are important to you, check out the next section on tmap. If interactivity (feature 1 &amp; 2) aren’t important to you, and especially if you are a season’t ggplot2 user, check the section on ggplot2. There are many packages that provide these features. In terms of simplicity, versatility and scaleablity tmap is one of the best in my opion. To see how it works, import the usual libraries and the North Carlolina Sample data. library(sf) ## Warning: package &#39;sf&#39; was built under R version 3.6.1 ## Linking to GEOS 3.6.1, GDAL 2.2.3, PROJ 4.9.3 library(tidyverse) ## Warning: package &#39;tidyverse&#39; was built under R version 3.6.1 ## -- Attaching packages -------------------------------------------- tidyverse 1.2.1 -- ## v ggplot2 3.2.0 v purrr 0.3.2 ## v tibble 2.1.3 v dplyr 0.8.3 ## v tidyr 0.8.3 v stringr 1.4.0 ## v readr 1.3.1 v forcats 0.4.0 ## Warning: package &#39;dplyr&#39; was built under R version 3.6.1 ## -- Conflicts ----------------------------------------------- tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() library(tmap) ## Warning: package &#39;tmap&#39; was built under R version 3.6.1 nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package = &quot;sf&quot;),quiet = TRUE) Here’s how the data looks in base plot: tmap has two modes: a static mode for printable maps (called plot) and a dynamic mode for exploratory, interactive maps (called view). We want the latter for now, so we switch to the dynamic mode with: tmap_mode(&quot;view&quot;) ## tmap mode set to interactive viewing tmap has based it’s syntax loosely on ggplot2: Mainly, layer are added with + and aesthetics are specified within each layer. tm_shape(nc) + tm_polygons() You can have a look at the attributes of each feature by clicking on it. To view the entire attribute table, you can print nc to the console, or have a look at it with View(nc) if you are using Rstudio. Check the following ressources for more information: https://github.com/mtennekes/tmap https://geocompr.robinlovelace.net/adv-map.html#interactive-maps "],
["static-for-presentation.html", "3.2 Static (for Presentation)", " 3.2 Static (for Presentation) If you are a seasond ggplot2 user (or want) to become one, you can create very nice static maps with ggplot2. Some facets of mapmaking are not native to this package however, and it might be worthwile to learn a new framework like tmap. Additional reading: see https://geocompr.robinlovelace.net/adv-map.html#static-maps "],
["static-maps-with-ggplot2.html", "3.3 Static maps with ggplot2", " 3.3 Static maps with ggplot2 3.3.1 Basics library(sf) library(tidyverse) eire &lt;- read_sf(system.file(&quot;shapes/eire.shp&quot;, package=&quot;spData&quot;)) The most basic plot consists of a ggplot() initiation and a single layer. In case of sf data, you can add a layer with geom_sf(). If the coordinate system is unknown, the axes will be labelled with the numerical values of the coorindates. st_crs(eire) ## Coordinate Reference System: NA ggplot(eire) + geom_sf() However, if the coordinate system is known, the WGS84 Coordinates are labelled and used as the major and minor grid lines. eire &lt;- st_set_crs(eire, &quot;+proj=utm +zone=30 +ellps=airy +units=km&quot;) ggplot(eire) + geom_sf() As always in ggplot, if you want to use a column from your dataset as an input for, say, colour, you need to specify this with aes(): ggplot(eire) + geom_sf(aes(fill = INCOME)) There are various ways to beautify this simple plot: ggplot(eire) + geom_sf(aes(fill = log(INCOME)), colour = &quot;grey&quot;) + labs(title = &quot;Counties of the Irish Republic&quot;, subtitle = expression(&quot;Distribution of Income (log&quot;[10]*&quot;)&quot;), fill = &quot;&quot;) + scale_fill_viridis_c() + theme_void() + theme(legend.position = &quot;bottom&quot;) 3.3.2 Adding Raster Data While vector data is very easily implemented in ggplot2, rasterdata is not. 3.3.3 Raster Maps One of the most common formats for raster background maps are (geo-) tif files. These can include colours or be greyscale. We’ll have a look at both cases. 3.3.3.1 With Colours Tif files with colours can either be single band or include multiple bands in a single tif file. These need to be treated differently. Let’s take two variants of the swiss raster map 1:50k map. One is a single band dataset, the other a 3-band dataset. Take the foll library(raster) ## Warning: package &#39;raster&#39; was built under R version 3.6.1 ## Loading required package: sp ## ## Attaching package: &#39;raster&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## select ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract path_1b &lt;- &quot;sample_data/SMR_Musterdaten/SMR50_LV95_KOMB_Mosaic.tif&quot; path_3b &lt;- &quot;sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif&quot; raster(path_1b) ## class : RasterLayer ## dimensions : 800, 800, 640000 (nrow, ncol, ncell) ## resolution : 2.5, 2.5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/rata/switchdrive/Projekte/2019_15_R_for_ArcGISusers/sample_data/SMR_Musterdaten/SMR50_LV95_KOMB_Mosaic.tif ## names : SMR50_LV95_KOMB_Mosaic ## values : 0, 255 (min, max) raster(path_3b) ## class : RasterLayer ## band : 1 (of 3 bands) ## dimensions : 400, 400, 160000 (nrow, ncol, ncell) ## resolution : 5, 5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/rata/switchdrive/Projekte/2019_15_R_for_ArcGISusers/sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif ## names : SMR50_LV95_KREL_10L_Mosaic ## values : 0, 255 (min, max) As you can see in the output of raster(path_3b), only one of the 3 bands was imported with raster::raster. In the case of multiband rasters, it’s better to use raster::brick: map_1b &lt;- raster(path_1b) map_3b &lt;- brick(path_3b) 3.3.3.1.1 Singleband A singleband RasterLayer can be regarded as vector of numeric values arranged in a matrix with some additional metadata. The metadata can be view with str(), the values can be obtained with getValues(). str(map_1b) ## Formal class &#39;RasterLayer&#39; [package &quot;raster&quot;] with 12 slots ## ..@ file :Formal class &#39;.RasterFile&#39; [package &quot;raster&quot;] with 13 slots ## .. .. ..@ name : chr &quot;C:\\\\Users\\\\rata\\\\switchdrive\\\\Projekte\\\\2019_15_R_for_ArcGISusers\\\\sample_data\\\\SMR_Musterdaten\\\\SMR50_LV95_KOMB_Mosaic.tif&quot; ## .. .. ..@ datanotation: chr &quot;INT1U&quot; ## .. .. ..@ byteorder : chr &quot;little&quot; ## .. .. ..@ nodatavalue : num -Inf ## .. .. ..@ NAchanged : logi FALSE ## .. .. ..@ nbands : int 1 ## .. .. ..@ bandorder : chr &quot;BIL&quot; ## .. .. ..@ offset : int 0 ## .. .. ..@ toptobottom : logi TRUE ## .. .. ..@ blockrows : int 1 ## .. .. ..@ blockcols : int 800 ## .. .. ..@ driver : chr &quot;gdal&quot; ## .. .. ..@ open : logi FALSE ## ..@ data :Formal class &#39;.SingleLayerData&#39; [package &quot;raster&quot;] with 13 slots ## .. .. ..@ values : logi(0) ## .. .. ..@ offset : num 0 ## .. .. ..@ gain : num 1 ## .. .. ..@ inmemory : logi FALSE ## .. .. ..@ fromdisk : logi TRUE ## .. .. ..@ isfactor : logi FALSE ## .. .. ..@ attributes: list() ## .. .. ..@ haveminmax: logi TRUE ## .. .. ..@ min : num 0 ## .. .. ..@ max : num 255 ## .. .. ..@ band : int 1 ## .. .. ..@ unit : chr &quot;&quot; ## .. .. ..@ names : chr &quot;SMR50_LV95_KOMB_Mosaic&quot; ## ..@ legend :Formal class &#39;.RasterLegend&#39; [package &quot;raster&quot;] with 5 slots ## .. .. ..@ type : chr(0) ## .. .. ..@ values : logi(0) ## .. .. ..@ color : logi(0) ## .. .. ..@ names : logi(0) ## .. .. ..@ colortable: chr [1:256] &quot;#000000&quot; &quot;#FFFFFF&quot; &quot;#D6EBD8&quot; &quot;#BDDFB5&quot; ... ## ..@ title : chr(0) ## ..@ extent :Formal class &#39;Extent&#39; [package &quot;raster&quot;] with 4 slots ## .. .. ..@ xmin: num 2599000 ## .. .. ..@ xmax: num 2601000 ## .. .. ..@ ymin: num 1196000 ## .. .. ..@ ymax: num 1198000 ## ..@ rotated : logi FALSE ## ..@ rotation:Formal class &#39;.Rotation&#39; [package &quot;raster&quot;] with 2 slots ## .. .. ..@ geotrans: num(0) ## .. .. ..@ transfun:function () ## ..@ ncols : int 800 ## ..@ nrows : int 800 ## ..@ crs :Formal class &#39;CRS&#39; [package &quot;sp&quot;] with 1 slot ## .. .. ..@ projargs: chr NA ## ..@ history : list() ## ..@ z : list() head(getValues(map_1b),50) ## [1] 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 ## [24] 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 37 ## [47] 37 37 37 37 extent(map_1b) ## class : Extent ## xmin : 2599000 ## xmax : 2601000 ## ymin : 1196000 ## ymax : 1198000 The first 50 cells of this RasterLayer contain the value 37. This value 37 is associated with a specific colour, which can be viewd in the colortable of the RasterLayer. coltab &lt;- colortable(map_1b) coltab ## [1] &quot;#000000&quot; &quot;#FFFFFF&quot; &quot;#D6EBD8&quot; &quot;#BDDFB5&quot; &quot;#A5CF91&quot; &quot;#53A935&quot; &quot;#50A833&quot; ## [8] &quot;#4CA830&quot; &quot;#F0D7BD&quot; &quot;#BC821E&quot; &quot;#B9801C&quot; &quot;#B67C19&quot; &quot;#F6ADCD&quot; &quot;#D4057D&quot; ## [15] &quot;#D4007B&quot; &quot;#FFF799&quot; &quot;#FFF685&quot; &quot;#F9AA8F&quot; &quot;#FDB940&quot; &quot;#D30908&quot; &quot;#D30505&quot; ## [22] &quot;#D20000&quot; &quot;#D4EFFD&quot; &quot;#8ED8F8&quot; &quot;#008ED7&quot; &quot;#008DD5&quot; &quot;#008BD3&quot; &quot;#0089D2&quot; ## [29] &quot;#0088D0&quot; &quot;#D1D3D4&quot; &quot;#221E26&quot; &quot;#1F1C24&quot; &quot;#1E1D24&quot; &quot;#1D1C24&quot; &quot;#1D1B24&quot; ## [36] &quot;#1C1B24&quot; &quot;#1C1B23&quot; &quot;#1B1A23&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [43] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [50] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [57] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [64] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [71] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [78] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [85] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [92] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [99] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [106] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [113] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [120] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [127] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [134] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [141] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [148] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [155] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [162] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [169] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [176] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [183] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [190] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [197] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [204] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [211] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [218] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [225] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [232] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [239] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [246] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [253] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#FFFFFF&quot; scales::show_col(coltab,labels = FALSE) In order to plot this RasterLayer in ggplot, we need to convert it into a dataframe. You can imagine that this is converting the wide matrix into a very long table with three columns: x and y coordinates of the lower left corner of each cell and a value specifying what the cell holds. map_1b_df &lt;- data.frame(coordinates(map_1b),values = getValues(map_1b)) head(map_1b_df) ## x y values ## 1 2599001 1197999 37 ## 2 2599004 1197999 37 ## 3 2599006 1197999 37 ## 4 2599009 1197999 37 ## 5 2599011 1197999 37 ## 6 2599014 1197999 37 We can now use the values column in ggplot2 to specify the fill aesthetic. If we then pass the colortable as our fill values, the colours will be matched correctly. However we need two additional tricks: name the colourtable to make sure the correct colours are correct to the according values wrap the values column in factor() so that the ggplot2 does not mistake the numeric values as a continuous scale: names(coltab) &lt;- 0:255 # 1:256 would be wrong by 1 ggplot() + geom_raster(data = map_1b_df, aes(x,y, fill = factor(values))) + scale_fill_manual(values = coltab) + theme(legend.position = &quot;none&quot;) + coord_equal() Note that there are thee ways to plot this type of data in ggplot2: geom_rect, geom_tile and geom_raster. The latter is “a high performance special case for when all the tiles are the same size” (see the docs. Alternatively, you can add the hex colourcode to the dataframe and use scale_fill_identitiy(). map_1b_df &lt;- mutate(map_1b_df, colorvalue = coltab[values+1]) ggplot() + geom_raster(data = map_1b_df, aes(x,y, fill = colorvalue)) + scale_fill_identity() + theme(legend.position = &quot;none&quot;) + coord_equal() The big drawback of using ggplot2 in this way: you cannot add a second layer with a fill aesthetic, since ggplot2 only allows one per plot. 3.3.3.1.2 Multiple bands In case of a 3-Band Raster Brick, each layer holds a value of 0 to 255 representing colours in the RGB colour model. Usually, the first layer represents Red, the second Green and the third Blue. We can subset the RasterBrick into the individual RasterLayers using double brackets ([[1]] for the first layer). map_3b ## class : RasterBrick ## dimensions : 400, 400, 160000, 3 (nrow, ncol, ncell, nlayers) ## resolution : 5, 5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/rata/switchdrive/Projekte/2019_15_R_for_ArcGISusers/sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif ## names : SMR50_LV95_KREL_10L_Mosaic.1, SMR50_LV95_KREL_10L_Mosaic.2, SMR50_LV95_KREL_10L_Mosaic.3 ## min values : 0, 0, 0 ## max values : 255, 255, 255 map_3b[[1]] ## class : RasterLayer ## band : 1 (of 3 bands) ## dimensions : 400, 400, 160000 (nrow, ncol, ncell) ## resolution : 5, 5 (x, y) ## extent : 2599000, 2601000, 1196000, 1198000 (xmin, xmax, ymin, ymax) ## crs : NA ## source : C:/Users/rata/switchdrive/Projekte/2019_15_R_for_ArcGISusers/sample_data/SMR_Musterdaten/SMR50_LV95_KREL_10L_Mosaic.tif ## names : SMR50_LV95_KREL_10L_Mosaic.1 ## values : 0, 255 (min, max) We can extract the Values of each layer again with getValues(): head(values(map_3b[[1]]),50) ## [1] 27 27 31 27 67 124 124 124 124 123 123 123 122 123 122 66 27 ## [18] 57 97 113 123 123 124 100 68 68 68 68 68 68 68 36 27 27 ## [35] 27 27 38 117 105 97 97 100 111 119 54 27 27 27 27 66 We can then use these values to create hex-codes from the RGB values. rgb(10,10,10,maxColorValue = 255) ## [1] &quot;#0A0A0A&quot; cols &lt;- rgb(values(map_3b[[1]]),values(map_3b[[2]]),values(map_3b[[3]]),maxColorValue = 255) head(cols,50) ## [1] &quot;#1B1A23&quot; &quot;#1B1A23&quot; &quot;#1F1C24&quot; &quot;#1B1A23&quot; &quot;#433B3A&quot; &quot;#7C726E&quot; &quot;#7C726D&quot; ## [8] &quot;#7C726D&quot; &quot;#7C726D&quot; &quot;#7B726C&quot; &quot;#7B726D&quot; &quot;#7B726C&quot; &quot;#7A716D&quot; &quot;#7B726C&quot; ## [15] &quot;#7A716D&quot; &quot;#423A39&quot; &quot;#1B1A23&quot; &quot;#392D29&quot; &quot;#614225&quot; &quot;#715E4D&quot; &quot;#7B736C&quot; ## [22] &quot;#7B726C&quot; &quot;#7C736D&quot; &quot;#645D57&quot; &quot;#443C3D&quot; &quot;#443D3D&quot; &quot;#443D3C&quot; &quot;#443D3C&quot; ## [29] &quot;#443D3D&quot; &quot;#443D3D&quot; &quot;#443D3D&quot; &quot;#242027&quot; &quot;#1B1A23&quot; &quot;#1B1A23&quot; &quot;#1B1A23&quot; ## [36] &quot;#1B1A23&quot; &quot;#262229&quot; &quot;#756659&quot; &quot;#695239&quot; &quot;#614225&quot; &quot;#614225&quot; &quot;#64472B&quot; ## [43] &quot;#6F5B45&quot; &quot;#776B60&quot; &quot;#363031&quot; &quot;#1B1A23&quot; &quot;#1B1A23&quot; &quot;#1B1A23&quot; &quot;#1B1A23&quot; ## [50] &quot;#42443C&quot; Like with the single band raster, we now transform the Raster into a dataframe, this time using the output of rgb() to directly add the hex colourvalues to the table. map_3b_df &lt;- data.frame(coordinates(map_3b),colorvalue = cols) head(map_3b_df) ## x y colorvalue ## 1 2599003 1197998 #1B1A23 ## 2 2599008 1197998 #1B1A23 ## 3 2599013 1197998 #1F1C24 ## 4 2599018 1197998 #1B1A23 ## 5 2599023 1197998 #433B3A ## 6 2599028 1197998 #7C726E ggplot() + geom_raster(data = map_3b_df, aes(x,y,fill = colorvalue)) + scale_fill_identity() + coord_equal() Tipp, if your file is to large and ggplot has trouble plotting it fast, you can use aggregate to reduce the resolution map_3b_lowres &lt;- raster::aggregate(map_3b, fact = 5) map_3b_lowres_df &lt;- data.frame(coordinates(map_3b_lowres),colorvalue = rgb(values(map_3b_lowres[[1]]),values(map_3b_lowres[[2]]),values(map_3b_lowres[[3]]),maxColorValue = 255)) ggplot() + geom_raster(data = map_3b_lowres_df, aes(x,y,fill = colorvalue)) + scale_fill_identity() + coord_equal() 3.3.3.2 Greyscale In greyscale maps, raster cannot find a associated colortable to match the values to rgb or hex colours. map_grey_path &lt;- &quot;sample_data/SMR_Musterdaten/SMR50_LV95_KGRS_Mosaic.tif&quot; map_grey &lt;- raster(map_grey_path) head(getValues(map_grey)) ## [1] 31 31 31 31 31 31 colortable(map_grey) ## [1] &quot;#000000&quot; &quot;#FFFFFF&quot; &quot;#F4F4F4&quot; &quot;#E7E7E7&quot; &quot;#D3D2D3&quot; &quot;#CAC9CA&quot; &quot;#C8C7C8&quot; ## [8] &quot;#C5C4C5&quot; &quot;#A7A7A7&quot; &quot;#A3A2A3&quot; &quot;#9E9D9E&quot; &quot;#D1D0D1&quot; &quot;#B4B4B4&quot; &quot;#B3B3B3&quot; ## [15] &quot;#8F8E8F&quot; &quot;#8D8C8D&quot; &quot;#8A898A&quot; &quot;#FCFCFC&quot; &quot;#F9F8F8&quot; &quot;#6A6A6C&quot; &quot;#676668&quot; ## [22] &quot;#646365&quot; &quot;#626264&quot; &quot;#5C5E61&quot; &quot;#201D25&quot; &quot;#1F1C24&quot; &quot;#1E1D24&quot; &quot;#1D1C24&quot; ## [29] &quot;#1D1B24&quot; &quot;#1C1B24&quot; &quot;#1C1B23&quot; &quot;#1B1A23&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [36] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [43] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [50] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [57] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [64] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [71] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [78] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [85] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [92] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [99] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [106] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [113] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [120] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [127] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [134] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [141] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [148] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [155] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [162] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [169] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [176] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [183] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [190] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [197] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [204] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [211] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [218] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [225] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [232] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [239] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [246] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; ## [253] &quot;#969696&quot; &quot;#969696&quot; &quot;#969696&quot; &quot;#FFFFFF&quot; However, the package tiff can find the rgb values of a tiff, we just need to set indexed = TRUE and get the color.map attribute of the output: library(tiff) index &lt;- readTIFF(map_grey_path,indexed = TRUE) colormap &lt;- attr(index,&quot;color.map&quot;) colormap[,1:10] # only showing the first 10 columns (of 256) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] ## [1,] 0 1 0.9568627 0.9058824 0.8274510 0.7921569 0.7843137 0.7725490 ## [2,] 0 1 0.9568627 0.9058824 0.8235294 0.7882353 0.7803922 0.7686275 ## [3,] 0 1 0.9568627 0.9058824 0.8274510 0.7921569 0.7843137 0.7725490 ## [,9] [,10] ## [1,] 0.654902 0.6392157 ## [2,] 0.654902 0.6352941 ## [3,] 0.654902 0.6392157 This is an index with three rows (Red, Green and Blue) and 265 columns (with are the Values from getValues()). We can now use rgb() to turn this matrix into a vector of 265 hex colours: coltab &lt;- rgb(colormap[1,],colormap[2,],colormap[3,]) scales::show_col(coltab,labels = FALSE) Like before, we now turn the RasterLayer into a dataframe and use the Values and the newly created colortable to assign the correct values: map_grey_df &lt;- data.frame(coordinates(map_grey),values = getValues(map_grey)) names(coltab) &lt;- 0:255 ggplot() + geom_raster(data = map_grey_df, aes(x,y, fill = factor(values))) + scale_fill_manual(values = coltab) + theme(legend.position = &quot;none&quot;) + coord_equal() "],
["select-by-attribute-or-location.html", "4 Select (by Attribute or Location)", " 4 Select (by Attribute or Location) "],
["select-by-attribute.html", "4.1 Select by Attribute", " 4.1 Select by Attribute "],
["select-by-location.html", "4.2 Select by Location", " 4.2 Select by Location library(sf) library(tidyverse) "],
["spatial-analyst-toolbox.html", "5 Spatial Analyst Toolbox ", " 5 Spatial Analyst Toolbox "],
["conditional-toolset.html", "5.1 Conditional Toolset", " 5.1 Conditional Toolset "],
["density-toolset.html", "5.2 Density Toolset", " 5.2 Density Toolset 5.2.1 Kernel Denisity There are several Function that can be tweaked to calculate KDE for sf-Point object: tmaptools::smooth_map(): Depricated (is there a successor?) spatstat::density.ppp(): Takes only objects of Class ppp MASS::kde2d(): Takes x/y coordinates as vectors and returns a matrix In this example, I take MASS:kde2d() and tweak it to take sf and return raster. First, let’s create some sample data: set.seed(10) mypoints &lt;- data.frame(x = rnorm(1000),y = rnorm(1000)) %&gt;% st_as_sf(coords = c(1,2)) plot(mypoints) my_kde &lt;- function(points,cellsize, bandwith, extent = NULL){ require(MASS) require(raster) require(sf) if(is.null(extent)){ extent_vec &lt;- st_bbox(points)[c(1,3,2,4)] } else{ extent_vec &lt;- st_bbox(extent)[c(1,3,2,4)] } n_y &lt;- ceiling((extent_vec[4]-extent_vec[3])/cellsize) n_x &lt;- ceiling((extent_vec[2]-extent_vec[1])/cellsize) extent_vec[2] &lt;- extent_vec[1]+(n_x*cellsize)-cellsize extent_vec[4] &lt;- extent_vec[3]+(n_y*cellsize)-cellsize coords &lt;- st_coordinates(points) matrix &lt;- kde2d(coords[,1],coords[,2],h = bandwith,n = c(n_x,n_y),lims = extent_vec) raster(matrix) } mypoints_kde &lt;- my_kde(mypoints,0.01,1) ## Loading required package: MASS ## ## Attaching package: &#39;MASS&#39; ## The following objects are masked from &#39;package:raster&#39;: ## ## area, select ## The following object is masked from &#39;package:dplyr&#39;: ## ## select library(stars) ## Warning: package &#39;stars&#39; was built under R version 3.6.1 ## Loading required package: abind ggplot() + geom_stars(data = st_as_stars(mypoints_kde)) + geom_sf(data = mypoints, alpha = 0.2, fill = &quot;black&quot;) + scale_fill_viridis_c() + labs(fill = &quot;KDE&quot;) + theme_void() 5.2.2 Line Density 5.2.3 Point Density "],
["distance-toolset.html", "5.3 Distance Toolset", " 5.3 Distance Toolset "],
["extraction-toolset.html", "5.4 Extraction Toolset", " 5.4 Extraction Toolset "],
["generalization-toolset.html", "5.5 Generalization Toolset", " 5.5 Generalization Toolset "],
["interpolation-toolset.html", "5.6 Interpolation Toolset", " 5.6 Interpolation Toolset "],
["map-algebra-toolset.html", "5.7 Map Algebra Toolset", " 5.7 Map Algebra Toolset "],
["math-toolset.html", "5.8 Math Toolset", " 5.8 Math Toolset "],
["neighborhood-toolset.html", "5.9 Neighborhood Toolset", " 5.9 Neighborhood Toolset "],
["overlay-toolset.html", "5.10 Overlay Toolset", " 5.10 Overlay Toolset "],
["reclass-toolset.html", "5.11 Reclass Toolset", " 5.11 Reclass Toolset "],
["surface-toolset.html", "5.12 Surface Toolset", " 5.12 Surface Toolset "],
["zonal-toolset.html", "5.13 Zonal Toolset", " 5.13 Zonal Toolset "],
["d-analyst-toolbox.html", "6 3D Analyst Toolbox ", " 6 3D Analyst Toolbox "],
["raster-interpolation-toolset.html", "6.1 Raster Interpolation Toolset", " 6.1 Raster Interpolation Toolset library(sp) library(sf) library(tidyverse) library(stars) data(meuse) meuse_sf &lt;- meuse %&gt;% st_as_sf(coords = c(&quot;x&quot;,&quot;y&quot;)) 6.1.1 IDW my_idw &lt;- function(groundtruth,column,cellsize, nmax = Inf, maxdist = Inf, idp = 2, extent = NULL){ require(gstat) require(sf) require(raster) if(is.null(extent)){ extent &lt;- groundtruth } samples &lt;- st_make_grid(extent,cellsize,what = &quot;centers&quot;) %&gt;% st_as_sf() my_formula &lt;- formula(paste(column,&quot;~1&quot;)) idw_sf &lt;- gstat::idw(formula = my_formula,groundtruth,newdata = samples,nmin = 1, maxdist = maxdist, idp = idp) idw_matrix &lt;- cbind(st_coordinates(idw_sf),idw_sf$var1.pred) ras &lt;- raster::rasterFromXYZ(idw_matrix) if(all(grepl(&quot;polygon&quot;,st_geometry_type(extent),ignore.case = TRUE))){ ras &lt;- raster::mask(ras,st_as_sf(st_zm(extent))) } ras } meuse_idw &lt;- my_idw(meuse_sf,&quot;copper&quot;,cellsize = 10,idp = 3) ## Loading required package: gstat ## Warning: package &#39;gstat&#39; was built under R version 3.6.1 ## Registered S3 method overwritten by &#39;xts&#39;: ## method from ## as.zoo.xts zoo ## [inverse distance weighted interpolation] ggplot() + geom_stars(data = st_as_stars(meuse_idw)) + scale_fill_viridis_c() + theme_void() + labs(fill = &quot;copper&quot;) + coord_equal() 6.1.2 Kriging my_krige &lt;- function(groundtruth,column,cellsize, nmax = Inf, maxdist = Inf, extent = NULL){ require(gstat) require(sf) require(raster) if(is.null(extent)){ extent &lt;- groundtruth } samples &lt;- st_make_grid(extent,cellsize,what = &quot;centers&quot;) %&gt;% st_as_sf() my_formula &lt;- formula(paste(column,&quot;~1&quot;)) idw_sf &lt;- gstat::krige(formula = my_formula,groundtruth,newdata = samples,nmin = 1, maxdist = maxdist) idw_matrix &lt;- cbind(st_coordinates(idw_sf),idw_sf$var1.pred) ras &lt;- raster::rasterFromXYZ(idw_matrix) if(all(grepl(&quot;polygon&quot;,st_geometry_type(extent),ignore.case = TRUE))){ ras &lt;- raster::mask(ras,st_as_sf(st_zm(extent))) } ras } meuse_krige &lt;- my_krige(meuse_sf,&quot;copper&quot;,cellsize = 10,nmax = 30, maxdist = 500) ## [inverse distance weighted interpolation] ggplot() + geom_stars(data = st_as_stars(meuse_krige)) + scale_fill_viridis_c(na.value = NA) + theme_void() + labs(fill = &quot;copper&quot;) + coord_equal() ## Warning: Removed 31412 rows containing missing values (geom_raster). 6.1.3 Natural Neighbor Nearest Neighbor: meuse_thiessen &lt;- st_voronoi(st_union(meuse_sf)) meuse_thiessen &lt;- st_cast(meuse_thiessen) meuse_bbox &lt;- meuse_sf %&gt;% st_bbox() %&gt;% st_as_sfc() meuse_thiessen &lt;- st_intersection(meuse_thiessen,meuse_bbox) meuse_thiessen &lt;- st_as_sf(meuse_thiessen) meuse_thiessen &lt;- st_join(meuse_thiessen,meuse_sf) ggplot() + geom_sf(data = meuse_thiessen, aes(fill = copper)) + geom_sf(data = meuse_sf) + scale_fill_viridis_c() + theme_void() 6.1.4 Spline "],
["analysis-toolbox.html", "7 Analysis Toolbox ", " 7 Analysis Toolbox "],
["extract-toolset.html", "7.1 Extract Toolset", " 7.1 Extract Toolset 7.1.1 Clip 7.1.2 Select 7.1.3 Split 7.1.4 Aplit by Attributes 7.1.5 Table Select "],
["overlay-toolset-1.html", "7.2 Overlay Toolset", " 7.2 Overlay Toolset 7.2.1 Erase 7.2.2 Union 7.2.3 Symmetrical Difference 7.2.4 Spatial Join 7.2.5 Intersect 7.2.6 Identity 7.2.7 Update "],
["proximity-toolset.html", "7.3 Proximity Toolset", " 7.3 Proximity Toolset "],
["geocoding-toolbox.html", "8 Geocoding Toolbox", " 8 Geocoding Toolbox "],
["image-analysis-toolbox.html", "9 Image Analysis Toolbox ", " 9 Image Analysis Toolbox "],
["map-algebra-toolset-1.html", "9.1 Map Algebra Toolset", " 9.1 Map Algebra Toolset 9.1.1 Raster Calulator "],
["spatial-statistics-toolbox.html", "10 Spatial Statistics Toolbox ", " 10 Spatial Statistics Toolbox "],
["analyzing-patterns-toolset.html", "10.1 Analyzing Patterns Toolset", " 10.1 Analyzing Patterns Toolset "],
["morans-i.html", "10.2 Morans I", " 10.2 Morans I morans_i &lt;- function(sf_object,col) { require(sf) n &lt;- nrow(sf_object) y &lt;- unlist(st_set_geometry(sf_object,NULL)[,col],use.names = FALSE) ybar &lt;- mean(y, na.rm = TRUE) dy &lt;- y - ybar dy_sum &lt;- sum(dy^2, na.rm = TRUE) vr &lt;- n/dy_sum w &lt;- st_touches(sf_object,sparse = FALSE) pm &lt;- tcrossprod(dy) pmw &lt;- pm * w spmw &lt;- sum(pmw, na.rm = TRUE) smw &lt;- sum(w, na.rm = TRUE) sw &lt;- spmw / smw MI &lt;- vr * sw MI } "],
["toplogy-rules.html", "11 Toplogy Rules", " 11 Toplogy Rules in ArcGIS, you create a topology rule by first creating a Feature Dataset in a Geodatabase, and then adding one or more Topology Rules to that Feature Dataset. In R, you can check topology using the DE-9IM together with st_relate(). "],
["polygon.html", "11.1 Polygon", " 11.1 Polygon 11.1.1 Must not overlap In context of DE-9IM, this is a simple case. The polygon interiors should not overlap at all, everything else does not matter. Interior-Interior is the first of the 9 intersections, so the the intersection matrix as a code string would be: 2********. In the case of the example below: set.seed(10) nrows &lt;- 10 circs &lt;- data.frame( id = 1:nrows, x = rnorm(nrows), y = rnorm(nrows) ) %&gt;% st_as_sf(coords = c(2,3)) %&gt;% st_buffer(0.25) circsplot &lt;- ggplot(circs) + geom_sf(fill = &quot;blue&quot;,alpha = 0.3) + geom_sf_text(aes(label = id)) + theme_void() circsplot This gives us a sparse matrix as an output, which is esentially a list with the same length as the x, where each position is a vector of integers with the indicies of the features in y (which may equal to x) where the pattern matches. st_relate(circs,pattern = &quot;2********&quot;) ## Sparse geometry binary predicate list of length 10, where the predicate was `relate_pattern&#39; ## 1: 1, 2, 5 ## 2: 1, 2, 4, 5, 10 ## 3: 3 ## 4: 2, 4 ## 5: 1, 2, 5 ## 6: 6 ## 7: 7 ## 8: 8 ## 9: 9 ## 10: 2, 10 Setting sparse = FALSE returns a crossmatrix of all combinations.W crossmatrix &lt;- st_relate(circs,pattern = &quot;2********&quot;,sparse = FALSE) crossmatrix[1:6,1:6] # only showing 6 since this prints nicely ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] TRUE TRUE FALSE FALSE TRUE FALSE ## [2,] TRUE TRUE FALSE TRUE TRUE FALSE ## [3,] FALSE FALSE TRUE FALSE FALSE FALSE ## [4,] FALSE TRUE FALSE TRUE FALSE FALSE ## [5,] TRUE TRUE FALSE FALSE TRUE FALSE ## [6,] FALSE FALSE FALSE FALSE FALSE TRUE # Remove the diagonals since it&#39;s simply each feature tested against itself diag(crossmatrix) &lt;- FALSE error &lt;- which(crossmatrix,arr.ind = TRUE) %&gt;% as.vector() %&gt;% unique() circsplot + geom_sf(data = circs[error,], fill = &quot;red&quot;, alpha = 0.3) 11.1.2 Must not have gaps Lets cosider the North Carolina Dataset for this question. nc = st_read(system.file(&quot;shape/nc.shp&quot;, package=&quot;sf&quot;), quiet = TRUE) ggplot(nc) + geom_sf() + theme_void() The first task is to dissolve all adjecent polygons together nc_union &lt;- st_union(nc) nc_union ## Geometry set for 1 feature ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 ## epsg (SRID): 4267 ## proj4string: +proj=longlat +datum=NAD27 +no_defs If the output is a multipolygon as it is the case here, it’s bad news, there are gaps. To check which parts are disconnected from each other, we can cast the multipolygon to a polygon (in ArcGIS Terms “Multipart to singlepart”), add a rowname for each part and colour it by rowname. nc_singlepart &lt;- nc_union %&gt;% st_cast(&quot;POLYGON&quot;)%&gt;% st_sf() %&gt;% mutate(id = 1:n()) ggplot(nc_singlepart) + geom_sf(aes(fill = factor(id))) + labs(fill = &quot;id&quot;) + theme_void() But maybe we can live with these Islands in the state of North Carolina, since this is in fact an accurate representation of reality (the gaps are a result of the Atlantic Ocean). We must now check whether the individual geometries have holes. Here we can make use of the way polygons are defined in sf: geometry with a positive area (two-dimensional); sequence of points form a closed, non-self intersecting ring; the first ring denotes the exterior ring, zero or more subsequent rings denote holes in this exterior ring This means that the length of each Polygon geometry must be 1. A length of 2 or more would mean that there are one (or more) holes in the geometry. We can do this with any of the functions from the apply family, I prefer purrr: map_lgl(nc_singlepart$geometry,~length(.x)== 1) ## [1] TRUE TRUE TRUE TRUE TRUE TRUE Let’s see what happens if we cut a hole into the polygons holes &lt;- nc_singlepart %&gt;% st_union() %&gt;% st_centroid() %&gt;% st_buffer(0.5) nc_holes &lt;- st_difference(nc_singlepart,holes) ggplot(nc_holes) + geom_sf() + theme_void() map_lgl(nc_holes$geometry,~length(.x)== 1) ## [1] TRUE TRUE TRUE TRUE FALSE TRUE 11.1.3 Contains point 11.1.4 Contains one Point 11.1.5 Must be covered by feature class of 11.1.6 Boundary must be covered by 11.1.7 Must not overlap with 11.1.8 Must be covered by 11.1.9 Area boundary must be covered by boundary of 11.1.10 Must cover each other "],
["line-or-polygon.html", "11.2 Line or Polygon", " 11.2 Line or Polygon 11.2.1 Must be larger than cluster tolarance "],
["line.html", "11.3 Line", " 11.3 Line 11.3.1 Must not have pseudo nodes 11.3.2 Must not have dangles 11.3.3 Must not self overlap 11.3.4 Must not overlap 11.3.5 Must not self-intersect 11.3.6 Must not intersect 11.3.7 Must be single part 11.3.8 Must not intersect with 11.3.9 Must be covered by feature class of 11.3.10 Must not intersect or touch interior 11.3.11 Must be covered by boundary of 11.3.12 Must not intersect or touch interior with 11.3.13 Must be properly inside 11.3.14 Must not overlap with 11.3.15 Endpoint must be covered by "],
["point.html", "11.4 Point", " 11.4 Point 11.4.1 Must coincide with 11.4.2 Must be disjoint 11.4.3 Must be covered by endpoint of 11.4.4 Point must be covered by line 11.4.5 Must be properly inside 11.4.6 Must be covered by boundary of "],
["additional-reading.html", "12 Additional Reading ", " 12 Additional Reading "],
["binary-predicates-and-de-9im.html", "12.1 Binary Predicates and DE-9IM", " 12.1 Binary Predicates and DE-9IM Binary Predicates check topological relationships betweeen geometries. This can be very practical for data quality questions (e.g. “None of the State borders should ovelap”) or for neighbourhood question (e.g. “which states border the state of Nevada?”). Lets take the example of a chessboard: Some topological relationships have specific names. For example, if we want to know which field touch a specific field, the name for this predicate is “touches”. This is implemented in the function st_touches of the packages sf: So to see which field touch field number 36, we can write the following line of code: st_touches(board[36,],board) ## Sparse geometry binary predicate list of length 1, where the predicate was `touches&#39; ## 1: 27, 28, 29, 35, 37, 43, 44, 45 Visually, these are the following fields: Similarly, there are further named topological relationships. Each of them has it’s own function in R: Contains (st_contains) Covers (st_covers) Intersects (st_intersects) Within / Inside (st_within) Covered by (st_covered_by) Crosses (st_crosses) Overlaps (st_overlaps) Regarding the visual example above, we can imagine a chess piece placed on field #36. If this figure was a Queen or a King, all of the fields resulting from st_touches are reachable. In terms of contiguity, this is what is typically called the Queen’s or the King’s Case. However, this is might not the relationship that we are looking for: Say we would want to exclude the diagonal fields from our selection, the way a Rook would move in chess. How can we implement this in R? None of the named topological relationships (binary predicates) above correctly describes this case (touches_but_not_at_edges or shares_boundary would be appropriate). In this case, we can use the Dimensionally Extended 9-Intersection Model (DE-9IM) to precisely formulate the realtionship we are looking for: the Rooks Case. IN DE-9IM, the intersection of two objects is viewed at three levels for each object: The Interior, the Boundry and the Exterior (\\(3^2= 9\\), hence the name). These levels mean different things for Polygons, Lines or Points, but let’s just look at the simple case for now, polygons (which is the case for our chess fields). Take the following example The interior of a polygon is the area inside the polygon. If the two areas overlap (as is the case of blue and red), the result from an intersection would also be a polygon. More formally: The Dimesion of \\(I(blue) \\cap I(red)\\) is an area. Areas get a value of 2, Lines 1 and points 0. If there is no intersection (as is the case in blue and green), the result equals to FALSE. This was the first of 9 Intersections. Let’s look at the next one: Interior of blue with the boundry of green: The resulting object has a dimenion “line”, i.e. 1. Formally: \\(dim(I(blue) \\cap B(red)) = 1\\). Now just for the sake of looking at the third level (Exerior), let’s look at what this looks like: p2_ls &lt;- st_cast(p2,&quot;LINESTRING&quot;) p2_ls2 &lt;- st_intersection(p1,p2_ls) ggplot() + geom_sf(data = p1, fill = &quot;blue&quot;, alpha = 0.4) + geom_sf(data = p2, fill = &quot;red&quot;, alpha = 0.4)+ geom_sf(data = st_difference(p1,p2), fill = &quot;yellow&quot;, lwd = 2)+ theme_void() The resulting object is again an area, i.e. 2. Formally \\(dim(I(blue) \\cap E(red)) = 2\\). If we go through all intersections of Interior, Boundry and Exterior of both geometries, we can denote for each comination what type of dimesion we “allow”. This can be either 0 (for points), 1 (for lines) or 3 (for areas) or TRUE (for either of these), or FALSE (for none of these) or * (for \"I dont care). Why go through all this trouble? Because we would like to specify the rooks case, and none of the named predicates matches. So let’s define the rooks case ourselves: 12.1.1 Rooks Case If we go throught the all nine combinations of the DE-9IM, this is what defines the rooks case: Interior Boundary Exterior Interior nothing don’t care don’t care Boundary don’t care Line don’t care Exterior don’t care don’t care don’t care We can now write this into a string, starting from the top left: F1* Now that we have this string, we case use st_relate()and specify the string as the pattern we are looking for: st_relate(board[36,],board,pattern = &quot;F***1****&quot;) ## Sparse geometry binary predicate list of length 1, where the predicate was `relate_pattern&#39; ## 1: 28, 35, 37, 44 Which visually gives us this pattern: Because this was so much fun, let’s also have a look at the opposite, the Bishops Case. 12.1.2 Bishops Case Interior Boundary Exterior Interior nothing don’t care don’t care Boundary don’t care Point don’t care Exterior don’t care don’t care don’t care st_relate(board[36,],board,pattern = &quot;F***0****&quot;) ## Sparse geometry binary predicate list of length 1, where the predicate was `relate_pattern&#39; ## 1: 27, 29, 43, 45 Visually: "]
]
