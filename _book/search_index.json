[
["index.html", "Burning the Bridges Spatial R for ArcGIS Users 1 Abstract", " Burning the Bridges Spatial R for ArcGIS Users 1 Abstract After tweeting this a couple of times, I decided to start my own ressource on the topic: “Spatial Stuff in R for People indoctrinated with ArcGIS”. I, like many, leared GIS in University using ArcGIS. It took me a considerable amount of time to learn that there are alternatives to ArcGIS, but not much longer to realize that I’m more attracted to these alternatives than to ArcGIS. When you transition from a proriatary Software like ArcGIS to FOSS, you have to relearn many of the concepts because the proprietery software usually does not adhere to common standards. There are already a great many spatial-R Ressources out there, and I’m not planning to rewrite everything that has been written. My aim is just to provide a resource for people looking to do spial stuff in R, but only know the ArcGIS-Term for it. This might mean that for some topics, I will simply provide a link to an existing ressource. Currently, I have to following topics in mind: Making Maps Dynamic, for exploration purposes Static, for presentation purposes Select by Attribute Select by Location Topology Rules Spatial Joins Geoprocessing Tools KDE Multippoint to singlepoint Merge, Join, Intersect, Erase… Aggregate Polygons "],
["making-maps.html", "2 Making Maps 2.1 Interactive (for Data Exploration) 2.2 Static (for Presentation)", " 2 Making Maps 2.1 Interactive (for Data Exploration) see https://geocompr.robinlovelace.net/adv-map.html#interactive-maps 2.2 Static (for Presentation) see https://geocompr.robinlovelace.net/adv-map.html#static-maps "],
["select-by-attribute-or-location.html", "3 Select (by Attribute or Location) 3.1 Select by Attribute 3.2 Select by Location", " 3 Select (by Attribute or Location) 3.1 Select by Attribute 3.2 Select by Location library(sf) ## Warning: package &#39;sf&#39; was built under R version 3.6.1 ## Linking to GEOS 3.6.1, GDAL 2.2.3, PROJ 4.9.3 library(tidyverse) ## Warning: package &#39;tidyverse&#39; was built under R version 3.6.1 ## -- Attaching packages ------------------ ## v ggplot2 3.2.0 v purrr 0.3.2 ## v tibble 2.1.3 v dplyr 0.8.3 ## v tidyr 0.8.3 v stringr 1.4.0 ## v readr 1.3.1 v forcats 0.4.0 ## Warning: package &#39;dplyr&#39; was built under R version 3.6.1 ## -- Conflicts -- tidyverse_conflicts() -- ## x dplyr::filter() masks stats::filter() ## x dplyr::lag() masks stats::lag() "],
["geoprocessing-tools.html", "4 Geoprocessing Tools 4.1 Spatial Analyst Toolbox 4.2 Spatial Statistics Toolbox 4.3 Analysis Toolbox 4.4 Geocoding Toolbox 4.5 Image Analysis Toolbox 4.6 3D Analyst Toolbox", " 4 Geoprocessing Tools 4.1 Spatial Analyst Toolbox 4.1.1 Conditional Toolset 4.1.2 Density Toolset 4.1.2.1 Kernel Denisity There are several Function that can be tweaked to calculate KDE for sf-Point object: tmaptools::smooth_map(): Depricated spatstat::density.ppp(): Takes only objects of Class ppp MASS::kde2d(): Takes x/y coordinates as vectors and returns a matrix In this example, I take MASS:kde2d() and tweak it to take sf and return raster. First, let’s create some sample data: set.seed(10) mypoints &lt;- data.frame(x = rnorm(1000),y = rnorm(1000)) %&gt;% st_as_sf(coords = c(1,2)) plot(mypoints) my_kde &lt;- function(points,cellsize, bandwith, extent = NULL){ require(MASS) require(raster) require(sf) require(stars) if(is.null(extent)){ extent_vec &lt;- st_bbox(points)[c(1,3,2,4)] } else{ extent_vec &lt;- st_bbox(extent)[c(1,3,2,4)] } n_y &lt;- ceiling((extent_vec[4]-extent_vec[3])/cellsize) n_x &lt;- ceiling((extent_vec[2]-extent_vec[1])/cellsize) extent_vec[2] &lt;- extent_vec[1]+(n_x*cellsize)-cellsize extent_vec[4] &lt;- extent_vec[3]+(n_y*cellsize)-cellsize coords &lt;- st_coordinates(points) matrix &lt;- kde2d(coords[,1],coords[,2],h = bandwith,n = c(n_x,n_y),lims = extent_vec) raster(matrix) } mypoints_kde &lt;- my_kde(mypoints,0.01,1) ## Loading required package: MASS ## ## Attaching package: &#39;MASS&#39; ## The following object is masked from &#39;package:dplyr&#39;: ## ## select ## Loading required package: raster ## Warning: package &#39;raster&#39; was built under R version 3.6.1 ## Loading required package: sp ## ## Attaching package: &#39;raster&#39; ## The following objects are masked from &#39;package:MASS&#39;: ## ## area, select ## The following object is masked from &#39;package:dplyr&#39;: ## ## select ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract ## Loading required package: stars ## Warning: package &#39;stars&#39; was built under R version 3.6.1 ## Loading required package: abind library(stars) ggplot() + geom_stars(data = st_as_stars(mypoints_kde)) + geom_sf(data = mypoints, alpha = 0.2, fill = &quot;black&quot;) + scale_fill_viridis_c() + labs(fill = &quot;KDE&quot;) + theme_void() 4.1.2.2 Line Density 4.1.2.3 Point Density 4.1.3 Distance Toolset 4.1.4 Extraction Toolset 4.1.5 Generalization Toolset 4.1.6 Interpolation Toolset 4.1.7 Map Algebra Toolset 4.1.8 Math Toolset 4.1.9 Neighborhood Toolset 4.1.10 Overlay Toolset 4.1.11 Reclass Toolset 4.1.12 Surface Toolset 4.1.13 Zonal Toolset 4.2 Spatial Statistics Toolbox 4.2.1 Analyzing Patterns Toolset 4.2.2 Morans I morans_i &lt;- function(sf_object,col) { require(sf) n &lt;- nrow(sf_object) y &lt;- unlist(st_set_geometry(sf_object,NULL)[,col],use.names = FALSE) ybar &lt;- mean(y, na.rm = TRUE) dy &lt;- y - ybar dy_sum &lt;- sum(dy^2, na.rm = TRUE) vr &lt;- n/dy_sum w &lt;- st_touches(sf_object,sparse = FALSE) pm &lt;- tcrossprod(dy) pmw &lt;- pm * w spmw &lt;- sum(pmw, na.rm = TRUE) smw &lt;- sum(w, na.rm = TRUE) sw &lt;- spmw / smw MI &lt;- vr * sw MI } 4.3 Analysis Toolbox 4.3.1 Extract Toolset 4.3.1.1 Clip 4.3.1.2 Select 4.3.1.3 Split 4.3.1.4 Aplit by Attributes 4.3.1.5 Table Select 4.3.2 Overlay Toolset 4.3.2.1 Erase 4.3.2.2 Union 4.3.2.3 Symmetrical Difference 4.3.2.4 Spatial Join 4.3.2.5 Intersect 4.3.2.6 Identity 4.3.2.7 Update 4.3.3 Proximity Toolset 4.4 Geocoding Toolbox 4.5 Image Analysis Toolbox 4.5.1 Map Algebra Toolset 4.5.1.1 Raster Calulator 4.6 3D Analyst Toolbox 4.6.1 Raster Interpolation Toolset 4.6.1.1 IDW my_idw &lt;- function(groundtruth,column,cellsize, nmax = Inf, maxdist = Inf, idp = 2, extent = NULL){ require(gstat) require(sf) require(raster) if(is.null(extent)){ extent &lt;- groundtruth } samples &lt;- st_make_grid(extent,cellsize,what = &quot;centers&quot;) %&gt;% st_as_sf() my_formula &lt;- formula(paste(column,&quot;~1&quot;)) idw_sf &lt;- gstat::idw(formula = my_formula,groundtruth,newdata = samples,nmin = 1, maxdist = maxdist, idp = idp) idw_matrix &lt;- cbind(st_coordinates(idw_sf),idw_sf$var1.pred) ras &lt;- raster::rasterFromXYZ(idw_matrix) if(all(grepl(&quot;polygon&quot;,st_geometry_type(extent),ignore.case = TRUE))){ ras &lt;- raster::mask(ras,st_as_sf(st_zm(extent))) } ras } 4.6.1.2 Kriging my_krige &lt;- function(groundtruth,column,cellsize, nmax = Inf, maxdist = Inf, idp = 2, extent = NULL){ require(gstat) require(sf) require(raster) if(is.null(extent)){ extent &lt;- groundtruth } samples &lt;- st_make_grid(extent,cellsize,what = &quot;centers&quot;) %&gt;% st_as_sf() my_formula &lt;- formula(paste(column,&quot;~1&quot;)) idw_sf &lt;- gstat::krige(formula = my_formula,groundtruth,newdata = samples,nmin = 1, maxdist = maxdist, idp = idp) idw_matrix &lt;- cbind(st_coordinates(idw_sf),idw_sf$var1.pred) ras &lt;- raster::rasterFromXYZ(idw_matrix) if(all(grepl(&quot;polygon&quot;,st_geometry_type(extent),ignore.case = TRUE))){ ras &lt;- raster::mask(ras,st_as_sf(st_zm(extent))) } ras } 4.6.1.3 Natural Neighbor Nearest Neighbor: nc &lt;- st_read(system.file(&quot;shape/nc.shp&quot;, package=&quot;sf&quot;), quiet = TRUE) nc_union &lt;- st_union(nc) points &lt;- nc_union %&gt;% st_sample(1000) %&gt;% st_sf() %&gt;% mutate(val = rnorm(1000)) ## although coordinates are longitude/latitude, st_intersects assumes that they are planar ## although coordinates are longitude/latitude, st_intersects assumes that they are planar ## although coordinates are longitude/latitude, st_intersects assumes that they are planar ## although coordinates are longitude/latitude, st_intersects assumes that they are planar ## although coordinates are longitude/latitude, st_intersects assumes that they are planar ## although coordinates are longitude/latitude, st_intersects assumes that they are planar ## although coordinates are longitude/latitude, st_intersects assumes that they are planar ## although coordinates are longitude/latitude, st_intersects assumes that they are planar thiessen &lt;- st_voronoi(st_union(points)) ## Warning in st_voronoi.sfc(st_union(points)): st_voronoi does not correctly ## triangulate longitude/latitude data thiessen &lt;- st_cast(thiessen) thiessen &lt;- st_intersection(thiessen,nc_union) ## although coordinates are longitude/latitude, st_intersection assumes that they are planar ggplot() + geom_sf(data = nc) + geom_sf(data = thiessen, fill = NA) + geom_sf(data = points, aes(colour = val)) + theme_void() thiessen &lt;- st_as_sf(thiessen) thiessen &lt;- st_join(thiessen,points) ## although coordinates are longitude/latitude, st_intersects assumes that they are planar ggplot() + geom_sf(data = thiessen, aes(fill = val)) + geom_sf(data = points) + scale_fill_viridis_c() + theme_void() 4.6.1.4 Spline "],
["toplogy-rules.html", "5 Toplogy Rules 5.1 Polygons 5.2 Line or Polygon 5.3 Line 5.4 Point", " 5 Toplogy Rules in ArcGIS, you create a topology rule by first creating a Feature Dataset in a Geodatabase, and then adding one or more Topology Rules to that Feature Dataset. In R, you can check topology using the DE-9IM together with st_relate(). 5.1 Polygons 5.1.1 Must not overlap In context of DE-9IM, this is a simple case. The polygon interiors should not overlap at all, everything else does not matter. Interior-Interior is the first of the 9 intersections, so the the intersection matrix as a code string would be: 2********. In the case of the example below: set.seed(10) nrows &lt;- 10 circs &lt;- data.frame( id = 1:nrows, x = rnorm(nrows), y = rnorm(nrows) ) %&gt;% st_as_sf(coords = c(2,3)) %&gt;% st_buffer(0.25) circsplot &lt;- ggplot(circs) + geom_sf(fill = &quot;blue&quot;,alpha = 0.3) + geom_sf_text(aes(label = id)) + theme_void() circsplot This gives us a sparse matrix as an output, which is esentially a list with the same length as the x, where each position is a vector of integers with the indicies of the features in y (which may equal to x) where the pattern matches. st_relate(circs,pattern = &quot;2********&quot;) ## Sparse geometry binary predicate list of length 10, where the predicate was `relate_pattern&#39; ## 1: 1, 2, 5 ## 2: 1, 2, 4, 5, 10 ## 3: 3 ## 4: 2, 4 ## 5: 1, 2, 5 ## 6: 6 ## 7: 7 ## 8: 8 ## 9: 9 ## 10: 2, 10 Setting sparse = FALSE returns a crossmatrix of all combinations.W crossmatrix &lt;- st_relate(circs,pattern = &quot;2********&quot;,sparse = FALSE) crossmatrix[1:6,1:6] # only showing 6 since this prints nicely ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] TRUE TRUE FALSE FALSE TRUE FALSE ## [2,] TRUE TRUE FALSE TRUE TRUE FALSE ## [3,] FALSE FALSE TRUE FALSE FALSE FALSE ## [4,] FALSE TRUE FALSE TRUE FALSE FALSE ## [5,] TRUE TRUE FALSE FALSE TRUE FALSE ## [6,] FALSE FALSE FALSE FALSE FALSE TRUE # Remove the diagonals since it&#39;s simply each feature tested against itself diag(crossmatrix) &lt;- FALSE error &lt;- which(crossmatrix,arr.ind = TRUE) %&gt;% as.vector() %&gt;% unique() circsplot + geom_sf(data = circs[error,], fill = &quot;red&quot;, alpha = 0.3) 5.1.2 Must not have gaps Lets cosider the North Carolina Dataset for this question. nc = st_read(system.file(&quot;shape/nc.shp&quot;, package=&quot;sf&quot;), quiet = TRUE) ggplot(nc) + geom_sf() + theme_void() The first task is to dissolve all adjecent polygons together nc_union &lt;- st_union(nc) nc_union ## Geometry set for 1 feature ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 ## epsg (SRID): 4267 ## proj4string: +proj=longlat +datum=NAD27 +no_defs If the output is a multipolygon as it is the case here, it’s bad news, there are gaps. To check which parts are disconnected from each other, we can cast the multipolygon to a polygon (in ArcGIS Terms “Multipart to singlepart”), add a rowname for each part and colour it by rowname. nc_singlepart &lt;- nc_union %&gt;% st_cast(&quot;POLYGON&quot;)%&gt;% st_sf() %&gt;% mutate(id = 1:n()) ggplot(nc_singlepart) + geom_sf(aes(fill = factor(id))) + labs(fill = &quot;id&quot;) + theme_void() But maybe we can live with these Islands in the state of North Carolina, since this is in fact an accurate representation of reality (the gaps are a result of the Atlantic Ocean). We must now check whether the individual geometries have holes. Here we can make use of the way polygons are defined in sf: geometry with a positive area (two-dimensional); sequence of points form a closed, non-self intersecting ring; the first ring denotes the exterior ring, zero or more subsequent rings denote holes in this exterior ring This means that the length of each Polygon geometry must be 1. A length of 2 or more would mean that there are one (or more) holes in the geometry. We can do this with any of the functions from the apply family, I prefer purrr: map_lgl(nc_singlepart$geometry,~length(.x)== 1) ## [1] TRUE TRUE TRUE TRUE TRUE TRUE Let’s see what happens if we cut a hole into the polygons holes &lt;- nc_singlepart %&gt;% st_union() %&gt;% st_centroid() %&gt;% st_buffer(0.5) nc_holes &lt;- st_difference(nc_singlepart,holes) ggplot(nc_holes) + geom_sf() + theme_void() map_lgl(nc_holes$geometry,~length(.x)== 1) ## [1] TRUE TRUE TRUE TRUE FALSE TRUE 5.1.3 Contains point 5.1.4 Contains one Point 5.1.5 Must be covered by feature class of 5.1.6 Boundary must be covered by 5.1.7 Must not overlap with 5.1.8 Must be covered by 5.1.9 Area boundary must be covered by boundary of 5.1.10 Must cover each other 5.2 Line or Polygon 5.2.1 Must be larger than cluster tolarance 5.3 Line 5.3.1 Must not have pseudo nodes 5.3.2 Must not have dangles 5.3.3 Must not self overlap 5.3.4 Must not overlap 5.3.5 Must not self-intersect 5.3.6 Must not intersect 5.3.7 Must be single part 5.3.8 Must not intersect with 5.3.9 Must be covered by feature class of 5.3.10 Must not intersect or touch interior 5.3.11 Must be covered by boundary of 5.3.12 Must not intersect or touch interior with 5.3.13 Must be properly inside 5.3.14 Must not overlap with 5.3.15 Endpoint must be covered by 5.4 Point 5.4.1 Must coincide with 5.4.2 Must be disjoint 5.4.3 Must be covered by endpoint of 5.4.4 Point must be covered by line 5.4.5 Must be properly inside 5.4.6 Must be covered by boundary of "],
["additional-reading.html", "6 Additional Reading 6.1 Binary Predicates and DE-9IM", " 6 Additional Reading 6.1 Binary Predicates and DE-9IM Binary Predicates check topological relationships betweeen geometries. This can be very practical for data quality questions (e.g. “None of the State borders should ovelap”) or for neighbourhood question (e.g. “which states border the state of Nevada?”). Lets take the example of a chessboard: Some topological relationships have specific names. For example, if we want to know which field touch a specific field, the name for this predicate is “touches”. This is implemented in the function st_touches of the packages sf: So to see which field touch field number 36, we can write the following line of code: st_touches(board[36,],board) ## Sparse geometry binary predicate list of length 1, where the predicate was `touches&#39; ## 1: 27, 28, 29, 35, 37, 43, 44, 45 Visually, these are the following fields: Similarly, there are further named topological relationships. Each of them has it’s own function in R: Contains (st_contains) Covers (st_covers) Intersects (st_intersects) Within / Inside (st_within) Covered by (st_covered_by) Crosses (st_crosses) Overlaps (st_overlaps) Regarding the visual example above, we can imagine a chess piece placed on field #36. If this figure was a Queen or a King, all of the fields resulting from st_touches are reachable. In terms of contiguity, this is what is typically called the Queen’s or the King’s Case. However, this is might not the relationship that we are looking for: Say we would want to exclude the diagonal fields from our selection, the way a Rook would move in chess. How can we implement this in R? None of the named topological relationships (binary predicates) above correctly describes this case (touches_but_not_at_edges or shares_boundary would be appropriate). In this case, we can use the Dimensionally Extended 9-Intersection Model (DE-9IM) to precisely formulate the realtionship we are looking for: the Rooks Case. IN DE-9IM, the intersection of two objects is viewed at three levels for each object: The Interior, the Boundry and the Exterior (\\(3^2= 9\\), hence the name). These levels mean different things for Polygons, Lines or Points, but let’s just look at the simple case for now, polygons (which is the case for our chess fields). Take the following example The interior of a polygon is the area inside the polygon. If the two areas overlap (as is the case of blue and red), the result from an intersection would also be a polygon. More formally: The Dimesion of \\(I(blue) \\cap I(red)\\) is an area. Areas get a value of 2, Lines 1 and points 0. If there is no intersection (as is the case in blue and green), the result equals to FALSE. This was the first of 9 Intersections. Let’s look at the next one: Interior of blue with the boundry of green: The resulting object has a dimenion “line”, i.e. 1. Formally: \\(dim(I(blue) \\cap B(red)) = 1\\). Now just for the sake of looking at the third level (Exerior), let’s look at what this looks like: p2_ls &lt;- st_cast(p2,&quot;LINESTRING&quot;) p2_ls2 &lt;- st_intersection(p1,p2_ls) ggplot() + geom_sf(data = p1, fill = &quot;blue&quot;, alpha = 0.4) + geom_sf(data = p2, fill = &quot;red&quot;, alpha = 0.4)+ geom_sf(data = st_difference(p1,p2), fill = &quot;yellow&quot;, lwd = 2)+ theme_void() The resulting object is again an area, i.e. 2. Formally \\(dim(I(blue) \\cap E(red)) = 2\\). If we go through all intersections of Interior, Boundry and Exterior of both geometries, we can denote for each comination what type of dimesion we “allow”. This can be either 0 (for points), 1 (for lines) or 3 (for areas) or TRUE (for either of these), or FALSE (for none of these) or * (for \"I dont care). Why go through all this trouble? Because we would like to specify the rooks case, and none of the named predicates matches. So let’s define the rooks case ourselves: 6.1.1 Rooks Case If we go throught the all nine combinations of the DE-9IM, this is what defines the rooks case: Interior Boundary Exterior Interior nothing don’t care don’t care Boundary don’t care Line don’t care Exterior don’t care don’t care don’t care We can now write this into a string, starting from the top left: F1* Now that we have this string, we case use st_relate()and specify the string as the pattern we are looking for: st_relate(board[36,],board,pattern = &quot;F***1****&quot;) ## Sparse geometry binary predicate list of length 1, where the predicate was `relate_pattern&#39; ## 1: 28, 35, 37, 44 Which visually gives us this pattern: Because this was so much fun, let’s also have a look at the opposite, the Bishops Case. 6.1.2 Bishops Case Interior Boundary Exterior Interior nothing don’t care don’t care Boundary don’t care Point don’t care Exterior don’t care don’t care don’t care st_relate(board[36,],board,pattern = &quot;F***0****&quot;) ## Sparse geometry binary predicate list of length 1, where the predicate was `relate_pattern&#39; ## 1: 27, 29, 43, 45 Visually: "]
]
