```{r}
library(sf)
library(tidyverse)
```

# Geoprocessing Tools

## Spatial Analyst Toolbox

### Conditional Toolset
### Density Toolset

#### Kernel Denisity


There are several Function that can be tweaked to calculate KDE for `sf`-Point object:

- `tmaptools::smooth_map()`: Depricated
- `spatstat::density.ppp()`: Takes only objects of Class `ppp`
- `MASS::kde2d()`: Takes x/y coordinates as vectors and returns a matrix

In this example, I take `MASS:kde2d()` and tweak it to take `sf` and return `raster`. First, let's create some sample data:

```{r}
set.seed(10)
mypoints <- data.frame(x = rnorm(1000),y = rnorm(1000)) %>%
  st_as_sf(coords = c(1,2))

plot(mypoints)
```


```{r}
my_kde <- function(points,cellsize, bandwith, extent = NULL){
  require(MASS)
  require(raster)
  require(sf)
  require(stars)
  if(is.null(extent)){
    extent_vec <- st_bbox(points)[c(1,3,2,4)]
  } else{
    extent_vec <- st_bbox(extent)[c(1,3,2,4)]
  }
  
  n_y <- ceiling((extent_vec[4]-extent_vec[3])/cellsize)
  n_x <- ceiling((extent_vec[2]-extent_vec[1])/cellsize)
  
  extent_vec[2] <- extent_vec[1]+(n_x*cellsize)-cellsize
  extent_vec[4] <- extent_vec[3]+(n_y*cellsize)-cellsize

  coords <- st_coordinates(points)
  matrix <- kde2d(coords[,1],coords[,2],h = bandwith,n = c(n_x,n_y),lims = extent_vec)
  raster(matrix)
}
```

```{r}

mypoints_kde <- my_kde(mypoints,0.01,1)
library(stars)

ggplot() +
  geom_stars(data = st_as_stars(mypoints_kde)) +
  geom_sf(data = mypoints, alpha = 0.2, fill = "black") +
  scale_fill_viridis_c() +
  labs(fill = "KDE") +
  theme_void() 


```


#### Line Density
#### Point Density

### Distance Toolset
### Extraction Toolset
### Generalization Toolset
### Interpolation Toolset
### Map Algebra Toolset
### Math Toolset
### Neighborhood Toolset
### Overlay Toolset
### Reclass Toolset
### Surface Toolset
### Zonal Toolset

## Spatial Statistics Toolbox

### Analyzing Patterns Toolset

### Morans I

```{r}
morans_i <- function(sf_object,col) {
  require(sf)
  n <- nrow(sf_object)
  y <- unlist(st_set_geometry(sf_object,NULL)[,col],use.names = FALSE)
  ybar <- mean(y, na.rm = TRUE)
  dy <- y - ybar
  dy_sum <- sum(dy^2, na.rm = TRUE)
  vr <- n/dy_sum
  w <- st_touches(sf_object,sparse = FALSE)
  pm <- tcrossprod(dy)
  pmw <- pm * w
  spmw <- sum(pmw, na.rm = TRUE)
  smw <- sum(w, na.rm = TRUE)
  sw  <- spmw / smw
  MI <- vr * sw
  MI
}
```



## Analysis Toolbox

### Extract Toolset

#### Clip

#### Select

#### Split

#### Aplit by Attributes

#### Table Select

### Overlay Toolset

#### Erase

#### Union

#### Symmetrical Difference

#### Spatial Join

#### Intersect

#### Identity

#### Update

### Proximity Toolset


## Geocoding Toolbox

## Image Analysis Toolbox

### Map Algebra Toolset

#### Raster Calulator


## 3D Analyst Toolbox

### Raster Interpolation Toolset

```{r}
library(sp)
library(sf)
library(tidyverse)
library(stars)
data(meuse)

meuse_sf <- meuse %>%
  st_as_sf(coords = c("x","y"))

```


#### IDW

```{r}
my_idw <- function(groundtruth,column,cellsize, nmax = Inf, maxdist = Inf, idp = 2, extent = NULL){
  require(gstat)
  require(sf)
  require(raster)
  if(is.null(extent)){
    extent <- groundtruth
  }
  
  samples <- st_make_grid(extent,cellsize,what = "centers") %>% st_as_sf()
  my_formula <- formula(paste(column,"~1"))
  idw_sf <- gstat::idw(formula = my_formula,groundtruth,newdata = samples,nmin = 1, maxdist = maxdist, idp = idp)
  
  idw_matrix <- cbind(st_coordinates(idw_sf),idw_sf$var1.pred)
  
  
  ras <- raster::rasterFromXYZ(idw_matrix)
  
  if(all(grepl("polygon",st_geometry_type(extent),ignore.case = TRUE))){
    ras <- raster::mask(ras,st_as_sf(st_zm(extent)))
  }
  ras
}
```


```{r}
meuse_idw <- my_idw(meuse_sf,"copper",cellsize = 10,idp = 3)

ggplot() +
  geom_stars(data = st_as_stars(meuse_idw)) +
  scale_fill_viridis_c() +
  theme_void() +
  labs(fill = "copper") +
  coord_equal()
  

```


#### Kriging

```{r}
my_krige <- function(groundtruth,column,cellsize, nmax = Inf, maxdist = Inf, extent = NULL){
  require(gstat)
  require(sf)
  require(raster)
  if(is.null(extent)){
    extent <- groundtruth
  }
  
  samples <- st_make_grid(extent,cellsize,what = "centers") %>% st_as_sf()
  my_formula <- formula(paste(column,"~1"))
  idw_sf <- gstat::krige(formula = my_formula,groundtruth,newdata = samples,nmin = 1, maxdist = maxdist)
  
  idw_matrix <- cbind(st_coordinates(idw_sf),idw_sf$var1.pred)
  
  
  ras <- raster::rasterFromXYZ(idw_matrix)
  
  if(all(grepl("polygon",st_geometry_type(extent),ignore.case = TRUE))){
    ras <- raster::mask(ras,st_as_sf(st_zm(extent)))
  }
  ras
}
```


```{r}
meuse_krige <- my_krige(meuse_sf,"copper",cellsize = 10,nmax = 30, maxdist = 500)

ggplot() +
  geom_stars(data = st_as_stars(meuse_krige)) +
  scale_fill_viridis_c(na.value = NA) +
  theme_void() +
  labs(fill = "copper") +
  coord_equal()
```

#### Natural Neighbor

Nearest Neighbor:

```{r}

meuse_thiessen <- st_voronoi(st_union(meuse_sf))
meuse_thiessen <- st_cast(meuse_thiessen)
meuse_bbox <- meuse_sf %>%
  st_bbox() %>%
  st_as_sfc()

meuse_thiessen <- st_intersection(meuse_thiessen,meuse_bbox)

meuse_thiessen <- st_as_sf(meuse_thiessen)
meuse_thiessen <- st_join(meuse_thiessen,meuse_sf)

ggplot() + 
  geom_sf(data = meuse_thiessen, aes(fill = copper)) +
  geom_sf(data = meuse_sf) +
  scale_fill_viridis_c() +
  theme_void()
```


#### Spline


